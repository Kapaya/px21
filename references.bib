
@article{2003,
  title = {American {{Educational Research Association}} 2004 {{Annual Meeting}}: {{April}} 12\textendash 16, {{San Diego}}},
  shorttitle = {American {{Educational Research Association}} 2004 {{Annual Meeting}}},
  year = {2003},
  month = dec,
  volume = {32},
  pages = {35--43},
  issn = {0013-189X, 1935-102X},
  doi = {10.3102/0013189X032009035},
  file = {/Users/geoffreylitt/Zotero/storage/JSMCHX9E/2003 - American Educational Research Association 2004 Ann.pdf},
  journal = {Educational Researcher},
  language = {en},
  number = {9}
}

@misc{2019,
  title = {End-User Programming},
  year = {2019},
  month = mar,
  abstract = {A vision for empowered computing that reaches back forty years. Our research lab examines why it has been so hard to achieve.},
  file = {/Users/geoffreylitt/Zotero/storage/VN9ZZWVZ/end-user-programming.html},
  howpublished = {https://www.inkandswitch.com/end-user-programming.html},
  journal = {Ink and Switch},
  language = {en-US}
}

@book{2019a,
  title = {Studying {{Diversity}}, {{Migration}} and {{Urban Multiculture}}},
  year = {2019},
  month = jul,
  publisher = {{UCL Press}},
  doi = {10.14324/111.9781787354784},
  file = {/Users/geoffreylitt/Zotero/storage/ANRQZ7TX/2019 - Studying Diversity, Migration and Urban Multicultu.pdf;/Users/geoffreylitt/Zotero/storage/X5X2JASA/tr2012001_steps.pdf},
  isbn = {978-1-78735-478-4},
  language = {en}
}

@misc{2020,
  title = {Reduxjs/Redux-Devtools},
  year = {2020},
  month = may,
  abstract = {DevTools for Redux with hot reloading, action replay, and customizable UI},
  howpublished = {Redux}
}

@misc{2020a,
  title = {Airtable},
  shorttitle = {Airtable},
  year = {2020},
  abstract = {Airtable works like a spreadsheet but gives you the power of a database to organize anything. Sign up for free.},
  file = {/Users/geoffreylitt/Zotero/storage/8UKHXPNG/airtable.com.html},
  howpublished = {https://airtable.com},
  journal = {Airtable}
}

@misc{2020b,
  title = {Glide},
  year = {2020},
  abstract = {Glide turns spreadsheets into beautiful, easy-to-use apps, without code. Pick a spreadsheet or start with a template, customize your app, then share it instantly with anyone. Start today for free!},
  file = {/Users/geoffreylitt/Zotero/storage/YRRWLQM8/www.glideapps.com.html},
  howpublished = {https://www.glideapps.com/},
  language = {en}
}

@misc{2020c,
  title = {A {{Better Cheatsheet}} \textbullet{} {{Hillel Wayne}}},
  year = {2020},
  month = jul,
  abstract = {Now that teach workshops for a living, I spend a lot of time on making better workshops. One improvement I made was creating progressive cheatsheets. I'll discuss the motivation and implementation below, but this is the high level picture:  .gallery \{ display: flex; text-align: center; \} .gallery a \{ margin: 5px; border-width: 1px; border-style: solid; \}      Progressions \#1 and \#2 of the cheatsheet. Click for full size.},
  chapter = {Post},
  file = {/Users/geoffreylitt/Zotero/storage/6IZR9QBW/cheatsheets.html},
  howpublished = {https://www.hillelwayne.com/post/cheatsheets/},
  journal = {Hillel Wayne},
  language = {en}
}

@article{abadi,
  title = {Consistency {{Tradeoffs}} in {{Modern Distributed Database System Design}}},
  author = {Abadi, Daniel J},
  pages = {6},
  file = {/Users/geoffreylitt/Zotero/storage/T8AL8MG3/Abadi - Consistency Tradeoffs in Modern Distributed Databa.pdf},
  language = {en}
}

@incollection{abou-saleh2016,
  title = {Reflections on {{Monadic Lenses}}},
  booktitle = {A {{List}} of {{Successes That Can Change}} the {{World}}},
  author = {{Abou-Saleh}, Faris and Cheney, James and Gibbons, Jeremy and McKinna, James and Stevens, Perdita},
  editor = {Lindley, Sam and McBride, Conor and Trinder, Phil and Sannella, Don},
  year = {2016},
  volume = {9600},
  pages = {1--31},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-319-30936-1_1},
  abstract = {Bidirectional transformations (bx) have primarily been modeled as pure functions, and do not account for the possibility of the side-effects that are available in most programming languages. Recently several formulations of bx that use monads to account for effects have been proposed, both among practitioners and in academic research. The combination of bx with effects turns out to be surprisingly subtle, leading to problems with some of these proposals and increasing the complexity of others. This paper reviews the proposals for monadic lenses to date, and offers some improved definitions, paying particular attention to the obstacles to naively adding monadic effects to existing definitions of pure bx such as lenses and symmetric lenses, and the subtleties of equivalence of symmetric bidirectional transformations in the presence of effects.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/Monadic Lenses (abou-saleh2016).md;/Users/geoffreylitt/Zotero/storage/KYYE4XFG/Abou-Saleh et al. - 2016 - Reflections on Monadic Lenses.pdf},
  isbn = {978-3-319-30935-4 978-3-319-30936-1},
  language = {en}
}

@inproceedings{adar1999,
  title = {Haystack: Per-User Information Environments},
  shorttitle = {Haystack},
  booktitle = {Proceedings of the Eighth International Conference on {{Information}} and Knowledge Management},
  author = {Adar, Eytan and Karger, David and Stein, Lynn Andrea},
  year = {1999},
  month = nov,
  pages = {413--422},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/319950.323231},
  abstract = {Traditional Information Retrieval (IR) systems are designed to provide uniform access to centralized corpora by large numbers of people. The Haystack project emphasizes the relationship between a particular individual and his corpus. An individual's own haystack priviliges information with which that user interacts, gathers data about those interactions, and uses this metadata to further personalize the retrieval process. This paper describes the prototype Haystack system.},
  file = {/Users/geoffreylitt/Zotero/storage/EUESPSSL/Adar et al. - 1999 - Haystack per-user information environments.pdf},
  isbn = {978-1-58113-146-8},
  series = {{{CIKM}} '99}
}

@incollection{adar2010,
  title = {The Temporal Dimension in End User Programming for the {{Web}}},
  booktitle = {No {{Code Required}}},
  author = {Adar, Eytan and Dontcheva, Mira and Fogarty, James A. and Weld, Daniel S.},
  year = {2010},
  pages = {251--266},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00013-4},
  abstract = {Despite the dynamic nature of the Web, most people only view and interact with a static snapshot. Search engines, browsers, and higher-level end user programming environments only support observing and manipulating a single point in time \textendash{} the ``now.'' We propose that moving beyond this static viewpoint is important because (1) maintaining a temporal view of the Web allows users to more clearly understand the behavior of their ``programs,'' both in static and dynamic contexts; and (2) temporally changing information on the Web is interesting in its own right. In this chapter we discuss the opportunities and challenges of integrating the temporal dimension in end user programming environments and our experiences with Zoetrope, a tool for interacting with the ephemeral (i.e., dynamic) Web.},
  file = {/Users/geoffreylitt/Zotero/storage/YGB2WIUB/Adar et al. - 2010 - The temporal dimension in end user programming for.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@article{ainsworth1999,
  title = {The Functions of Multiple Representations},
  author = {Ainsworth, Shaaron},
  year = {1999},
  month = sep,
  volume = {33},
  pages = {131--152},
  issn = {03601315},
  doi = {10.1016/S0360-1315(99)00029-9},
  abstract = {Multiple representations and multi-media can support learning in many dierent ways. In this paper, it is claimed that by identifying the functions that they can serve, many of the con\textasciimacron icting \textregistered ndings arising out of the existing evaluations of multi-representational learning environments can be explained. This will lead to more systematic design principles. To this end, this paper describes a functional taxonomy of MERs. This taxonomy is used to ask how translation across representations should be supported to maximise learning outcomes and what information should be gathered from empirical evaluation in order to determine the eectiveness of multi-representational learning environments. \# 2000 Elsevier Science Ltd. All rights reserved.},
  file = {/Users/geoffreylitt/Zotero/storage/HF2GC8JY/Ainsworth - 1999 - The functions of multiple representations.pdf},
  journal = {Computers \& Education},
  language = {en},
  number = {2-3}
}

@inproceedings{alkhatib2019,
  title = {Street-{{Level Algorithms}}: {{A Theory}} at the {{Gaps Between Policy}} and {{Decisions}}},
  shorttitle = {Street-{{Level Algorithms}}},
  booktitle = {Proceedings of the 2019 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Alkhatib, Ali and Bernstein, Michael},
  year = {2019},
  pages = {530:1-530:13},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3290605.3300760},
  abstract = {Errors and biases are earning algorithms increasingly malignant reputations in society. A central challenge is that algorithms must bridge the gap between high-level policy and on-the-ground decisions, making inferences in novel situations where the policy or training data do not readily apply. In this paper, we draw on the theory of street-level bureaucracies, how human bureaucrats such as police and judges interpret policy to make on-the-ground decisions. We present by analogy a theory of street-level algorithms, the algorithms that bridge the gaps between policy and decisions about people in a socio-technical system. We argue that unlike street-level bureaucrats, who reflexively refine their decision criteria as they reason through a novel situation, street-level algorithms at best refine their criteria only after the decision is made. This loop-and-a-half delay results in illogical decisions when handling new or extenuating circumstances. This theory suggests designs for street-level algorithms that draw on historical design patterns for street-level bureaucracies, including mechanisms for self-policing and recourse in the case of error.},
  isbn = {978-1-4503-5970-2},
  keywords = {artificial intelligence,street-level algorithms,street-level bureaucracies},
  series = {{{CHI}} '19}
}

@inproceedings{alrashed2020,
  title = {{{ScrAPIr}}: {{Making Web Data APIs Accessible}} to {{End Users}}},
  shorttitle = {{{ScrAPIr}}},
  booktitle = {Proceedings of the 2020 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Alrashed, Tarfah and Almahmoud, Jumana and Zhang, Amy X. and Karger, David R.},
  year = {2020},
  month = apr,
  pages = {1--12},
  publisher = {{Association for Computing Machinery}},
  address = {{Honolulu, HI, USA}},
  doi = {10.1145/3313831.3376691},
  abstract = {Users have long struggled to extract and repurpose data from websites by laboriously copying or scraping content from web pages. An alternative is to write scripts that pull data through APIs. This provides a cleaner way to access data than scraping; however, APIs are effortful for programmers and nigh-impossible for non-programmers to use. In this work, we empower users to access APIs without programming. We evolve a schema for declaratively specifying how to interact with a data API. We then develop ScrAPIr: a standard query GUI that enables users to fetch data through any API for which a specification exists, and a second GUI that lets users author and share the specification for a given API. From a lab evaluation, we find that even non-programmers can access APIs using ScrAPIr, while programmers can access APIs 3.8 times faster on average using ScrAPIr than using programming.},
  file = {/Users/geoffreylitt/Zotero/storage/AXSUQGM7/Alrashed et al. - 2020 - ScrAPIr Making Web Data APIs Accessible to End Us.pdf},
  isbn = {978-1-4503-6708-0},
  keywords = {api description language,web apis,web scraping},
  series = {{{CHI}} '20}
}

@inproceedings{amershi2019,
  title = {Guidelines for {{Human}}-{{AI Interaction}}},
  booktitle = {Proceedings of the 2019 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Amershi, Saleema and Inkpen, Kori and Teevan, Jaime and {Kikin-Gil}, Ruth and Horvitz, Eric and Weld, Dan and Vorvoreanu, Mihaela and Fourney, Adam and Nushi, Besmira and Collisson, Penny and Suh, Jina and Iqbal, Shamsi and Bennett, Paul N.},
  year = {2019},
  pages = {1--13},
  publisher = {{ACM Press}},
  address = {{Glasgow, Scotland}},
  doi = {10.1145/3290605.3300233},
  abstract = {Advances in artifcial intelligence (AI) frame opportunities and challenges for user interface design. Principles for humanAI interaction have been discussed in the human-computer interaction community for over two decades, but more study and innovation are needed in light of advances in AI and the growing uses of AI technologies in human-facing applications. We propose 18 generally applicable design guidelines for human-AI interaction. These guidelines are validated through multiple rounds of evaluation including a user study with 49 design practitioners who tested the guidelines against 20 popular AI-infused products. The results verify the relevance of the guidelines over a spectrum of interaction scenarios and reveal gaps in our knowledge, highlighting opportunities for further research. Based on the evaluations, we believe the set of design guidelines can serve as a resource to practitioners working on the design of applications and features that harness AI technologies, and to researchers interested in the further development of guidelines for human-AI interaction design.},
  isbn = {978-1-4503-5970-2},
  language = {en}
}

@article{anupam2000,
  title = {Automating {{Web}} Navigation with the {{WebVCR}}},
  author = {Anupam, Vinod and Freire, Juliana and Kumar, Bharat and Lieuwen, Daniel},
  year = {2000},
  month = jun,
  volume = {33},
  pages = {503--517},
  issn = {1389-1286},
  doi = {10.1016/S1389-1286(00)00073-6},
  abstract = {Recent developments in Web technology such as the inclusion of scripting languages, frames, and the growth of dynamic content, have made the process of retrieving Web content more complicated, and sometimes tedious. For example, Web browsers do not provide a method for a user to bookmark a frame-based Web site once the user navigates within the initial frameset. Also, some sites, such as travel sites and online classifieds, require users to go through a sequence of steps and fill out a sequence of forms in order to access their data. Using the bookmark facilities implemented in all popular browsers, often it is not possible to create a shortcut to access such data, and these steps must be manually repeated every time the data is needed. However, hard-to-reach pages are often the best candidates for a shortcut, because significantly more effort is required to reach them than to reach a standard page with a well-defined URL. The WebVCR system addresses this problem by letting users record and replay a series of browsing steps in smart bookmarks \textemdash{} shortcuts to Web content that require multiple steps to be retrieved. It provides a VCR-style interface to transparently record and replay users' actions. Creating and updating smart bookmarks is a simple process involving only the usual browsing actions and requiring no programming by the user. In addition to saving users time by providing shortcuts to hard-to-reach Web content, smart bookmarks can be used as building blocks for many interesting Web applications and new e-commerce services. In this paper, we describe the WebVCR and the techniques it uses to record and replay smart bookmarks, as well as our experiences in building the system. We also discuss some applications that are simplified/enabled by smart bookmarks.},
  file = {/Users/geoffreylitt/Zotero/storage/RTEBNIVU/Anupam et al. - 2000 - Automating Web navigation with the WebVCR.pdf;/Users/geoffreylitt/Zotero/storage/DSTLQZGB/S1389128600000736.html},
  journal = {Computer Networks},
  keywords = {Affiliate programs,Bookmarks,Dynamic content,Electronic commerce,Notification,Personalization,Smart bookmarks,Tutorials,Web clipping,Wrappers},
  language = {en},
  number = {1}
}

@article{apt2019,
  title = {Fifty Years of {{Hoare}}'s {{Logic}}},
  author = {Apt, Krzysztof R. and Olderog, Ernst-Ruediger},
  year = {2019},
  month = oct,
  abstract = {We present a history of Hoare's logic.},
  archivePrefix = {arXiv},
  eprint = {1904.03917},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/HYGDZ4YS/Apt and Olderog - 2019 - Fifty years of Hoare's Logic.pdf},
  journal = {arXiv:1904.03917 [cs]},
  keywords = {Computer Science - Logic in Computer Science},
  language = {en},
  primaryClass = {cs}
}

@article{azoulay,
  title = {3 {{Funding Breakthrough Research}}: {{Promises}} and {{Challenges}} of the ``{{ARPA Model}}''},
  author = {Azoulay, Pierre and Fuchs, Erica and Goldstein, Anna P and Kearney, Michael},
  pages = {28},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/azoulay.md;/Users/geoffreylitt/Zotero/storage/3B2SZJQS/Azoulay et al. - 3 Funding Breakthrough Research Promises and Chal.pdf},
  language = {en}
}

@inproceedings{badros1999,
  title = {Constraint Cascading Style Sheets for the {{Web}}},
  booktitle = {Proceedings of the 12th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology  - {{UIST}} '99},
  author = {Badros, Greg J. and Borning, Alan and Marriott, Kim and Stuckey, Peter},
  year = {1999},
  pages = {73--82},
  publisher = {{ACM Press}},
  address = {{Asheville, North Carolina, United States}},
  doi = {10.1145/320719.322588},
  abstract = {Cascading Style Sheets have recently been introduced by the W3C as a mechanism for controlling the appearance of HTML documents. In this paper, we demonstrate how constraints provide a powerful unifying formalism for declaratively understanding and specifying style sheets for web documents. With constraints we can naturally and declaratively specify complex behaviour such as inheritance of properties and cascading of conflicting style rules. We give a detailed description of a constraint-based style sheet model, CCSS, which is compatible with virtually all of the CSS 2.0 specification. It allows more flexible specification of layout, and also allows the designer to provide multiple layouts that better meet the desires of the user and environmental restrictions. We also describe a prototype extension of the Amaya browser that demonstrates the feasibility of CCSS.},
  file = {/Users/geoffreylitt/Zotero/storage/L4S7BNEI/Badros et al. - 1999 - Constraint cascading style sheets for the Web.pdf},
  isbn = {978-1-58113-075-1},
  language = {en}
}

@inproceedings{baker2015,
  title = {{{StructJumper}}: {{A Tool}} to {{Help Blind Programmers Navigate}} and {{Understand}} the {{Structure}} of {{Code}}},
  shorttitle = {{{StructJumper}}},
  booktitle = {Proceedings of the 33rd {{Annual ACM Conference}} on {{Human Factors}} in {{Computing Systems}} - {{CHI}} '15},
  author = {Baker, Catherine M. and Milne, Lauren R. and Ladner, Richard E.},
  year = {2015},
  pages = {3043--3052},
  publisher = {{ACM Press}},
  address = {{Seoul, Republic of Korea}},
  doi = {10.1145/2702123.2702589},
  abstract = {It can be difficult for a blind developer to understand and navigate through a large amount of code quickly, as they are unable to skim as easily as their sighted counterparts. To help blind developers overcome this problem, we present StructJumper, an Eclipse plugin that creates a hierarchical tree based on the nesting structure of a Java class. The programmer can use the TreeView to get an overview of the code structure of the class (including all the methods and control flow statements) and can quickly switch between the TreeView and the Text Editor to get an idea of where they are within the nested structure. To evaluate StructJumper, we had seven blind programmers complete three tasks with and without our tool. We found that the users thought they would use StructJumper and there was a trend that they were faster completing the tasks with StructJumper.},
  file = {/Users/geoffreylitt/Zotero/storage/JPRJMHUC/Baker et al. - 2015 - StructJumper A Tool to Help Blind Programmers Nav.pdf},
  isbn = {978-1-4503-3145-6},
  language = {en}
}

@inproceedings{bakke2016,
  title = {Expressive {{Query Construction}} through {{Direct Manipulation}} of {{Nested Relational Results}}},
  booktitle = {Proceedings of the 2016 {{International Conference}} on {{Management}} of {{Data}} - {{SIGMOD}} '16},
  author = {Bakke, Eirik and Karger, David R.},
  year = {2016},
  pages = {1377--1392},
  publisher = {{ACM Press}},
  address = {{San Francisco, California, USA}},
  doi = {10.1145/2882903.2915210},
  abstract = {Despite extensive research on visual query systems, the standard way to interact with relational databases remains to be through SQL queries and tailored form interfaces. We consider three requirements to be essential to a successful alternative: (1) query specification through direct manipulation of results, (2) the ability to view and modify any part of the current query without departing from the direct manipulation interface, and (3) SQL-like expressiveness. This paper presents the first visual query system to meet all three requirements in a single design. By directly manipulating nested relational results, and using spreadsheet idioms such as formulas and filters, the user can express a relationally complete set of query operators plus calculation, aggregation, outer joins, sorting, and nesting, while always remaining able to track and modify the state of the complete query. Our prototype gives the user an experience of responsive, incremental query building while pushing all actual query processing to the database layer. We evaluate our system with formative and controlled user studies on 28 spreadsheet users; the controlled study shows our system significantly outperforming Microsoft Access on the System Usability Scale.},
  file = {/Users/geoffreylitt/Zotero/storage/UAXRC2LC/Bakke and Karger - 2016 - Expressive Query Construction through Direct Manip.pdf},
  isbn = {978-1-4503-3531-7},
  language = {en}
}

@article{barbosa,
  title = {Matching {{Lenses}}: {{Alignment}} and {{View Update}}},
  author = {Barbosa, Davi M J and Cretin, Julien and Foster, Nate and Greenberg, Michael and Pierce, Benjamin C},
  pages = {12},
  abstract = {Bidirectional programming languages are a practical approach to the view update problem. Programs in these languages, called lenses, define both a view and an update policy\textemdash i.e., every program can be read as a function mapping sources to views as well as one mapping updated views back to updated sources.},
  file = {/Users/geoffreylitt/Zotero/storage/AKLVEW7Y/AKLVEW7Y.pdf},
  language = {en}
}

@article{barik,
  title = {Error {{Messages}} as {{Rational Reconstructions}}},
  author = {Barik, Titus},
  pages = {271},
  file = {/Users/geoffreylitt/Zotero/storage/XDYRAP9C/Barik - Error Messages as Rational Reconstructions.pdf},
  language = {en}
}

@article{basman,
  title = {What {{Lies}} in the {{Path}} of the {{Revolution}}},
  author = {Basman, Antranig and Tchernavskij, Philip},
  pages = {16},
  abstract = {Increasingly, the rights and capabilities to own technological artefacts, where they exist at all, are reserved to corporations and not to citizens. There are historical, economic, metaphysical, ideological and cognitive reasons for this situation, in addition to purely technological factors, which we will trace by following the fate of various concrete examples, analysed into five categories of ownable elements. These categories are those of ownable function, ownable expression, ownable data, ownable installations and ownable economies. In this paper, we attempt to align these goals of ownability into a research and activism program by describing a set of revolutionary goals in each category, and tracing ways we could reach them.},
  file = {/Users/geoffreylitt/Zotero/storage/9SEP8XK6/Basman and Tchernavskij - What Lies in the Path of the Revolution.pdf},
  keywords = {toread},
  language = {en}
}

@inproceedings{beaudouin-lafon2000,
  title = {Reification, {{Polymorphism}} and {{Reuse}}: {{Three Principles}} for {{Designing Visual Interfaces}}},
  shorttitle = {Reification, {{Polymorphism}} and {{Reuse}}},
  booktitle = {Proceedings of the {{Working Conference}} on {{Advanced Visual Interfaces}}},
  author = {{Beaudouin-Lafon}, Michel and Mackay, Wendy E.},
  year = {2000},
  pages = {102--109},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/345513.345267},
  abstract = {This paper presents three design principles to support the development of large-scale applications and take advantage of recent research in new interaction techniques: Reification turns concepts into first class objects, polymorphism permits commands to be applied to objects of different types, and reuse makes both user input and system output accessible for later use. We show that the power of these principles lies in their combination. Reification creates new objects that can be acted upon by a small set of polymorphic commands, creating more opportunities for reuse. The result is a simpler yet more powerful interface. To validate these principles, we describe their application in the redesign of a complex interface for editing and simulating Coloured Petri Nets. The cpn2000 interface integrates floating palettes, toolglasses and marking menus in a consistent manner with a new metaphor for managing the workspace. It challenges traditional ideas about user interfaces, getting rid of pull-down menus, scrollbars, and even selection, while providing the same or greater functionality. Preliminary tests with users show that they find the new system both easier to use and more efficient.},
  file = {/Users/geoffreylitt/Zotero/storage/ZUTWDQ9X/Beaudouin-Lafon and Mackay - 2000 - Reification, Polymorphism and Reuse Three Princip.pdf},
  isbn = {978-1-58113-252-6},
  keywords = {design principles,direct manipulation,instrumental interaction,interaction model,polymorphism,reification,reuse},
  series = {{{AVI}} '00}
}

@inproceedings{beaudouin-lafon2000a,
  title = {Instrumental {{Interaction}}: {{An Interaction Model}} for {{Designing}} Post-{{WIMP User Interfaces}}},
  shorttitle = {Instrumental {{Interaction}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {{Beaudouin-Lafon}, Michel},
  year = {2000},
  pages = {446--453},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/332040.332473},
  abstract = {This article introduces a new interaction model called Instrumental Interaction that extends and generalizes the principles of direct manipulation. It covers existing interaction styles, including traditional WIMP interfaces, as well as new interaction styles such as two-handed input and augmented reality. It defines a design space for new interaction techniques and a set of properties for comparing them. Instrumental Interaction describes graphical user interfaces in terms of domain objects and interaction instruments. Interaction between users and domain objects is mediated by interaction instruments, similar to the tools and instruments we use in the real world to interact with physical objects. The article presents the model, applies it to describe and compare a number of interaction techniques, and shows how it was used to create a new interface for searching and replacing text.},
  isbn = {978-1-58113-216-8},
  keywords = {direct manipulation,instrumental interaction,interaction model,post-WIMP interfaces,WIMP interfaces},
  series = {{{CHI}} '00}
}

@inproceedings{beaudouin-lafon2000b,
  title = {Instrumental Interaction: An Interaction Model for Designing Post-{{WIMP}} User Interfaces},
  shorttitle = {Instrumental Interaction},
  booktitle = {Proceedings of the {{SIGCHI}} Conference on {{Human Factors}} in {{Computing Systems}}},
  author = {{Beaudouin-Lafon}, Michel},
  year = {2000},
  month = apr,
  pages = {446--453},
  publisher = {{Association for Computing Machinery}},
  address = {{The Hague, The Netherlands}},
  doi = {10.1145/332040.332473},
  abstract = {This article introduces a new interaction model called Instrumental Interaction that extends and generalizes the principles of direct manipulation. It covers existing interaction styles, including traditional WIMP interfaces, as well as new interaction styles such as two-handed input and augmented reality. It defines a design space for new interaction techniques and a set of properties for comparing them. Instrumental Interaction describes graphical user interfaces in terms of domain objects and interaction instruments. Interaction between users and domain objects is mediated by interaction instruments, similar to the tools and instruments we use in the real world to interact with physical objects. The article presents the model, applies it to describe and compare a number of interaction techniques, and shows how it was used to create a new interface for searching and replacing text.},
  file = {/Users/geoffreylitt/Zotero/storage/9D4KR683/Beaudouin-Lafon - 2000 - Instrumental interaction an interaction model for.pdf},
  isbn = {978-1-58113-216-8},
  keywords = {direct manipulation,instrumental interaction,interaction model,post-WIMP interfaces,WIMP interfaces},
  series = {{{CHI}} '00}
}

@inproceedings{beaudouin-lafon2018,
  title = {Rethinking {{Interaction}}: {{From Instrumental Interaction}} to {{Human}}-{{Computer Partnerships}}},
  shorttitle = {Rethinking {{Interaction}}},
  booktitle = {Extended {{Abstracts}} of the 2018 {{CHI Conference}}},
  author = {{Beaudouin-Lafon}, Michel and Mackay, Wendy},
  year = {2018},
  month = apr,
  publisher = {{ACM Press}},
  address = {{Montreal QC, Canada}},
  doi = {10.1145/3170427.3170635},
  abstract = {The extraordinary advances in hardware and networking technology over the past 50 years have not been matched by equivalent advances in software. Today's interactive systems are fraught with limitations and incompatibilities: they lack interoperability and flexibility for end users. The goal of this workshop is to rethink interaction by identifying frameworks, principles and approaches that break these limitations and create true human-computer partnerships.},
  file = {/Users/geoffreylitt/Zotero/storage/GSRQR3NU/Beaudouin-Lafon and Mackay - 2018 - Rethinking Interaction From Instrumental Interact.pdf},
  keywords = {Design Principles,Human-Computer Partnerships,Information Substrates,Instrumental Interaction}
}

@article{becker1996,
  title = {The {{Visual Design}} and {{Control}} of {{Trellis Display}}},
  author = {Becker, Richard A. and Cleveland, William S. and Shyu, Ming-Jen},
  year = {1996},
  volume = {5},
  pages = {123--155},
  issn = {1061-8600},
  doi = {10.2307/1390777},
  abstract = {Trellis display is a framework for the visualization of data. Its most prominent aspect is an overall visual design, reminiscent of a garden trelliswork, in which panels are laid out into rows, columns, and pages. On each panel of the trellis, a subset of the data is graphed by a display method such as a scatterplot, curve plot, boxplot, 3-D wireframe, normal quantile plot, or dot plot. Each panel shows the relationship of certain variables conditional on the values of other variables. A number of display methods employed in the visual design of Trellis display enable it to succeed in uncovering the structure of data even when the structure is quite complicated. For example, Trellis display provides a powerful mechanism for understanding interactions in studies of how a response depends on explanatory variables. Three examples demonstrate this; in each case, we make important discoveries not appreciated in the original analyses. Several control methods are also essential to Trellis display. A control method is a technique for specifying information so that a display can be drawn. The control methods of Trellis display form a basic conceptual framework that can be used in designing software. We have demonstrated the viability of the control methods by implementing them in the S/S-PLUS system for graphics and data analysis, but they can be implemented in any software system with a basic capability for drawing graphs.},
  journal = {Journal of Computational and Graphical Statistics},
  number = {2}
}

@article{bembenek,
  title = {Formulog = {{Datalog}} + {{ML}} + {{SMT}}},
  author = {Bembenek, Aaron and Greenberg, Michael and Chong, Stephen},
  volume = {1},
  pages = {52},
  abstract = {Satisfiability modulo theories (SMT) solving has become a critical part of many static analyses, including symbolic execution, refinement type checking, and model checking. We propose Formulog, a domain-specific language that makes it possible to write a range of SMT-based static analyses in a way that is both close to their formal specifications and amenable to high-level optimizations and efficient evaluation. Formulog extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas, while ensuring that neither normal evaluation nor SMT solving goes wrong. Our case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and that \textemdash{} thanks to this encoding \textemdash{} high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses.},
  file = {/Users/geoffreylitt/Zotero/storage/W2BE4QAC/Bembenek et al. - Formulog = Datalog + ML + SMT.pdf},
  language = {en},
  number = {1}
}

@inproceedings{benson2014,
  title = {Spreadsheet Driven Web Applications},
  booktitle = {Proceedings of the 27th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '14},
  author = {Benson, Edward and Zhang, Amy X. and Karger, David R.},
  year = {2014},
  pages = {97--106},
  publisher = {{ACM Press}},
  address = {{Honolulu, Hawaii, USA}},
  doi = {10.1145/2642918.2647387},
  abstract = {Creating and publishing read-write-compute web applications requires programming skills beyond what most end users possess. But many end users know how to make spreadsheets that act as simple information management applications, often with computation. We present a system for creating basic web applications using such spreadsheets in place of a server and using HTML to describe the client UI. Authors connect the two by placing spreadsheet references inside HTML attributes. Data computation is provided by spreadsheet formulas. The result is a reactive read-write-compute web page without a single line of Javascript code. Nearly all of the fifteen HTML novices we studied were able to connect HTML to spreadsheets using our method with minimal instruction. We draw conclusions from their experience and discuss future extensions to this programming model.},
  file = {/Users/geoffreylitt/Zotero/storage/GGLIRAZC/Benson et al. - 2014 - Spreadsheet driven web applications.pdf},
  isbn = {978-1-4503-3069-5},
  language = {en}
}

@incollection{bergman1995,
  title = {Towards {{Accessible Human}}-{{Computer Interaction}}},
  booktitle = {Advances in {{Human}}-{{Computer Interaction}}},
  author = {Bergman, Eric A. and Johnson, Earl W.},
  editor = {Nielsen, Jakob},
  year = {1995},
  volume = {5},
  publisher = {{Ablex Publishing Corporation}},
  address = {{Norwood, NJ}},
  abstract = {In spite of the growing focus on user-centered interface design promoted by humancomputer interaction researchers and practitioners, there remains a large and diverse user population that is generally overlooked: users with disabilities. There are compelling legal, economic, social, and moral arguments for providing users with disabilities access to information technologies. Although we will touch on some of those arguments here, the primary purpose of this chapter is to provide a broad overview of the software humancomputer interaction (HCI) issues surrounding access to computer systems.},
  keywords = {Freedom of information laws by country,Human–computer interaction,User interface,User-centered design}
}

@misc{berners-lee2018,
  title = {One {{Small Step}} for the {{Web}}\ldots},
  author = {{Berners-Lee}, Tim},
  year = {2018},
  month = sep,
  abstract = {I've always believed the web is for everyone. That's why I and others fight fiercely to protect it. The changes we've managed to bring have\ldots},
  file = {/Users/geoffreylitt/Zotero/storage/MSSQR3BL/one-small-step-for-the-web-87f92217d085.html},
  howpublished = {https://medium.com/@timberners\_lee/one-small-step-for-the-web-87f92217d085},
  journal = {Medium},
  language = {en}
}

@misc{berners-lee2019,
  title = {One {{Small Step}} for the {{Web}}\ldots},
  author = {{Berners-Lee}, Tim},
  year = {2019},
  month = jan,
  abstract = {I've always believed the web is for everyone. That's why I and others fight fiercely to protect it. The changes we've managed to bring have\ldots},
  file = {/Users/geoffreylitt/Zotero/storage/DMNQSFG7/one-small-step-for-the-web-87f92217d085.html},
  howpublished = {https://medium.com/@timberners\_lee/one-small-step-for-the-web-87f92217d085},
  journal = {Medium},
  language = {en}
}

@inproceedings{bernstein2010,
  title = {Soylent: {{A Word Processor}} with a {{Crowd Inside}}},
  booktitle = {Proceedings of the 23nd {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  author = {Bernstein, Michael S. and Little, Greg and Miller, Robert C. and Hartmann, Bj{\"o}rn and Ackerman, Mark S. and Karger, David R. and Crowell, David and Panovich, Katrina},
  year = {2010},
  month = oct,
  pages = {313--322},
  publisher = {{ACM}},
  address = {{New York, NY}},
  abstract = {This paper introduces architectural and interaction patterns for integrating crowdsourced human contributions directly into user interfaces. We focus on writing and editing, complex endeavors that span many levels of conceptual and pragmatic activity. Authoring tools offer help with pragmatics, but for higher-level help, writers commonly turn to other people. We thus present Soylent, a word processing interface that enables writers to call on Mechanical Turk workers to shorten, proofread, and otherwise edit parts of their documents on demand. To improve worker quality, we introduce the Find-Fix-Verify crowd programming pattern, which splits tasks into a series of generation and review stages. Evaluation studies demonstrate the feasibility of crowdsourced editing and investigate questions of reliability, cost, wait time, and work time for edits.},
  language = {en}
}

@incollection{bertin1981,
  title = {Postmortem of {{An Example}}},
  booktitle = {Graphics and {{Graphic Information}}-{{Processing}}},
  author = {Bertin, Jacques},
  year = {1981},
  edition = {Reprint 2011},
  publisher = {{De Gruyter}},
  address = {{Berlin, Germany}},
  isbn = {978-3-11-085468-8},
  language = {ENGL},
  translator = {Berg, William J. and Scott, Paul}
}

@book{bertin2010,
  title = {Semiology of {{Graphics}}: {{Diagrams}}, {{Networks}}, {{Maps}}},
  shorttitle = {Semiology of {{Graphics}}},
  author = {Bertin, Jacques and Berg, William J.},
  year = {2010},
  edition = {1st ed},
  publisher = {{ESRI Press}},
  address = {{Redlands, Calif}},
  isbn = {978-1-58948-261-6},
  keywords = {Graphic methods,Information visualization,Statistical maps,Statistics},
  language = {eng},
  lccn = {QA90 .B47513 2010}
}

@inproceedings{bickmore2009,
  title = {Taking the {{Time}} to {{Care}}: {{Empowering Low Health Literacy Hospital Patients}} with {{Virtual Nurse Agents}}},
  shorttitle = {Taking the {{Time}} to {{Care}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Bickmore, Timothy W. and Pfeifer, Laura M. and Jack, Brian W.},
  year = {2009},
  pages = {1265--1274},
  publisher = {{ACM}},
  address = {{New York, NY}},
  doi = {10.1145/1518701.1518891},
  abstract = {Ninety million Americans have inadequate health literacy, resulting in a reduced ability to read and follow directions in the healthcare environment. We describe an animated, empathic virtual nurse interface for educating and counseling hospital patients with inadequate health literacy in their hospital beds at the time of discharge. The development methodology, design rationale, and two iterations of user testing are described. Results indicate that hospital patients with low health literacy found the system easy to use, reported high levels of satisfaction, and most said they preferred receiving the discharge information from the agent over their doctor or nurse. Patients also expressed appreciation for the time and attention provided by the virtual nurse, and felt that it provided an additional authoritative source for their medical information.},
  isbn = {978-1-60558-246-7},
  keywords = {embodied conversational agent,health literacy,patient education,relational agent,universal access},
  series = {{{CHI}} '09}
}

@inproceedings{bigham2008,
  title = {Trailblazer: Enabling Blind Users to Blaze Trails through the Web},
  shorttitle = {Trailblazer},
  booktitle = {Proceedingsc of the 13th International Conference on {{Intelligent}} User Interfaces - {{IUI}} '09},
  author = {Bigham, Jeffrey P. and Lau, Tessa and Nichols, Jeffrey},
  year = {2008},
  pages = {177},
  publisher = {{ACM Press}},
  address = {{Sanibel Island, Florida, USA}},
  doi = {10.1145/1502650.1502677},
  abstract = {For blind Web users, completing tasks on the Web can be frustrating. Each step can require a timeconsuming linear search of the current Web page to find the needed interactive element or piece of information. Existing interactive help systems and the playback components of some programming by demonstration tools identify the needed elements of a page as they guide the user through predefined tasks, obviating the need for a linear search on each step. TrailBlazer is a system that provides an accessible, nonvisual interface to guide blind users through existing how-to knowledge. A formative study indicated that participants saw the value of TrailBlazer but wanted to use it for tasks and Web sites for which no existing script was available. To address this, TrailBlazer offers suggestionbased help created on the fly from a short, user-provided task description and an existing repository of how-to knowledge. In an evaluation on 15 tasks, the correct prediction was contained within the top 5 suggestions 75.9\% of the time.},
  file = {/Users/geoffreylitt/Zotero/storage/GVDQ7WFL/Bigham et al. - 2008 - Trailblazer enabling blind users to blaze trails .pdf},
  isbn = {978-1-60558-168-2},
  language = {en}
}

@incollection{blackwell2001,
  title = {Cognitive {{Dimensions}} of {{Notations}}: {{Design Tools}} for {{Cognitive Technology}}},
  shorttitle = {Cognitive {{Dimensions}} of {{Notations}}},
  booktitle = {Cognitive {{Technology}}: {{Instruments}} of {{Mind}}},
  author = {Blackwell, A. F. and Britton, C. and Cox, A. and Green, T. R. G. and Gurr, C. and Kadoda, G. and Kutar, M. S. and Loomes, M. and Nehaniv, C. L. and Petre, M. and Roast, C. and Roe, C. and Wong, A. and Young, R. M.},
  editor = {Beynon, Meurig and Nehaniv, Chrystopher L. and Dautenhahn, Kerstin},
  year = {2001},
  volume = {2117},
  pages = {325--341},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  abstract = {The Cognitive Dimensions of Notations framework has been created to assist the designers of notational systems and information artifacts to evaluate their designs with respect to the impact that they will have on the users of those designs. The framework emphasizes the design choices available to such designers, including characterization of the user's activity, and the inevitable tradeoffs that will occur between potential design options. The resulting framework has been under development for over 10 years, and now has an active community of researchers devoted to it. This paper first introduces Cognitive Dimensions. It then summarizes the current activity, especially the results of a one-day workshop devoted to Cognitive Dimensions in December 2000, and reviews the ways in which it applies to the field of Cognitive Technology.},
  isbn = {978-3-540-42406-2 978-3-540-44617-0},
  language = {en}
}

@incollection{blomberg2012,
  title = {An {{Ethnographic Approach}} to {{Design}}},
  booktitle = {Human\textendash{{Computer Interaction Handbook}}},
  author = {Blomberg, Jeanette and Burrell, Mark and Guest, Greg},
  year = {2012},
  month = may,
  volume = {20126252},
  pages = {1025--1052},
  publisher = {{Lawrence Erlbaum Associates, Publishers}},
  address = {{Mahway, NJ}},
  isbn = {978-1-4398-2943-1 978-1-4398-2944-8},
  language = {en}
}

@inproceedings{bolin2005,
  title = {Automation and Customization of Rendered Web Pages},
  booktitle = {Proceedings of the 18th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology  - {{UIST}} '05},
  author = {Bolin, Michael and Webber, Matthew and Rha, Philip and Wilson, Tom and Miller, Robert C.},
  year = {2005},
  pages = {163},
  publisher = {{ACM Press}},
  address = {{Seattle, WA, USA}},
  doi = {10.1145/1095034.1095062},
  abstract = {On the desktop, an application can expect to control its user interface down to the last pixel, but on the World Wide Web, a content provider has no control over how the client will view the page, once delivered to the browser. This creates an opportunity for end-users who want to automate and customize their web experiences, but the growing complexity of web pages and standards prevents most users from realizing this opportunity. We describe Chickenfoot, a programming system embedded in the Firefox web browser, which enables end-users to automate, customize, and integrate web applications without examining their source code. One way Chickenfoot addresses this goal is a novel technique for identifying page components by keyword pattern matching. We motivate this technique by studying how users name web page components, and present a heuristic keyword matching algorithm that identifies the desired component from the user's name.},
  file = {/Users/geoffreylitt/Zotero/storage/JS89G2G2/Bolin et al. - 2005 - Automation and customization of rendered web pages.pdf},
  isbn = {978-1-59593-271-6},
  keywords = {Wildcard},
  language = {en}
}

@book{bonvillian2019,
  title = {The {{DARPA Model}} for {{Transformative Technologies}}: {{Perspectives}} on the {{U}}.{{S}}. {{Defense Advanced Research Projects Agency}}},
  shorttitle = {The {{DARPA Model}} for {{Transformative Technologies}}},
  author = {Bonvillian, William Boone and Windham (eds.), Richard Van Atta {and} Patrick},
  year = {2019},
  publisher = {{Open Book Publishers}},
  doi = {10.11647/OBP.0184},
  abstract = {Perspectives on the U.S. Defense Advanced Research Projects Agency},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/bonvillian2019.md;/Users/geoffreylitt/Zotero/storage/Y7G6Y2N5/DARPA Model for Transformative Technology .pdf;/Users/geoffreylitt/Zotero/storage/NM5WDXL2/1079.html},
  isbn = {978-1-78374-791-7},
  language = {en-gb}
}

@article{borkin2016,
  title = {Beyond {{Memorability}}: {{Visualization Recognition}} and {{Recall}}},
  shorttitle = {Beyond {{Memorability}}},
  author = {Borkin, M. A. and Bylinskii, Z. and Kim, N. W. and Bainbridge, C. M. and Yeh, C. S. and Borkin, D. and Pfister, H. and Oliva, A.},
  year = {2016},
  month = jan,
  volume = {22},
  pages = {519--528},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2015.2467732},
  abstract = {In this paper we move beyond memorability and investigate how visualizations are recognized and recalled. For this study we labeled a dataset of 393 visualizations and analyzed the eye movements of 33 participants as well as thousands of participant-generated text descriptions of the visualizations. This allowed us to determine what components of a visualization attract people's attention, and what information is encoded into memory. Our findings quantitatively support many conventional qualitative design guidelines, including that (1) titles and supporting text should convey the message of a visualization, (2) if used appropriately, pictograms do not interfere with understanding and can improve recognition, and (3) redundancy helps effectively communicate the message. Importantly, we show that visualizations memorable ``at-a-glance'' are also capable of effectively conveying the message of the visualization. Thus, a memorable visualization is often also an effective one.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  keywords = {Adult,Atmospheric measurements,Computer Graphics,data visualisation,Data visualization,Encoding,Eye Movements,eye-tracking study,Female,Humans,Information visualization,Male,memorability,Mental Recall,participant-generated text description,Particle measurements,qualitative design guidelines,recall,recognition,Redundancy,Target recognition,Task Performance and Analysis,Visual Perception,Visualization,visualization message,visualization recall,visualization recognition,Young Adult},
  number = {1}
}

@incollection{borodin2010,
  title = {Social {{Accessibility}}},
  booktitle = {No {{Code Required}}},
  author = {Borodin, Yevgen and Kawanaka, Shinya and Takagi, Hironobu and Kobayashi, Masatomo and Sato, Daisuke and Asakawa, Chieko},
  year = {2010},
  pages = {347--366},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00018-3},
  abstract = {This chapter challenges the assumption that Web site owners are the ones who are responsible for the accessibility of Web content. Web designers and Web developers have been notorious for not following official accessibility guidelines. At the same time, the amount of user-generated Web content made it practically impossible for site owners to ensure content accessibility in a centralized fashion. However, the dawn of social computing promises that collaborative approaches will overcome these problems. This chapter overviews the applications of social computing to Web accessibility and introduces Social Accessibility \textendash{} a collaborative framework, which brings together end users and volunteers for the purpose of creating external accessibility metadata. In making the Web accessible, the Social Accessibility approach bypasses content owners, considerably reducing the time for accessibility renovations. In addition, the centralized metadata can be used to educate Web designers and developers about creating accessible content, while providing a central point for collaborative accessibility verification.},
  file = {/Users/geoffreylitt/Zotero/storage/J42AHV3J/Borodin et al. - 2010 - Social Accessibility.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@article{bostock2011,
  title = {{{D}}{$^3$} {{Data}}-{{Driven Documents}}},
  author = {Bostock, M. and Ogievetsky, V. and Heer, J.},
  year = {2011},
  month = dec,
  volume = {17},
  pages = {2301--2309},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2011.185},
  abstract = {Data-Driven Documents (D3) is a novel representation-transparent approach to visualization for the web. Rather than hide the underlying scenegraph within a toolkit-specific abstraction, D3 enables direct inspection and manipulation of a native representation: the standard document object model (DOM). With D3, designers selectively bind input data to arbitrary document elements, applying dynamic transforms to both generate and modify content. We show how representational transparency improves expressiveness and better integrates with developer tools than prior approaches, while offering comparable notational efficiency and retaining powerful declarative components. Immediate evaluation of operators further simplifies debugging and allows iterative development. Additionally, we demonstrate how D3 transforms naturally enable animation and interaction with dramatic performance improvements over intermediate representations.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  language = {en},
  number = {12}
}

@book{braben2008,
  title = {Scientific {{Freedom}}: {{The Elixir}} of {{Civilization}}},
  shorttitle = {Scientific {{Freedom}}},
  author = {Braben, Donald W.},
  year = {2008},
  month = feb,
  edition = {1st Edition},
  publisher = {{Wiley-Interscience}},
  address = {{Hoboken, N.J}},
  abstract = {Scientific Freedom outlines what needs to be done to restore the freedom that can transform scientific understanding. The author defines Transformative Research (Venture Research) and explains how an initiative might be designed and implemented; discusses the revolutionary concept of low-risk, high-reward research; explains the wider significance of instability, and introduces the formidable Damocles Zone; explores threats to the university as an institution; and describes how a Transformative Research initiative might work in practice.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/braben2008.md},
  isbn = {978-0-470-22654-4},
  language = {English}
}

@misc{bracha2010,
  title = {Room 101: {{The Brave New World}} of {{Full Service Computing}}},
  shorttitle = {Room 101},
  author = {Bracha, Gilad},
  year = {2010},
  month = apr,
  file = {/Users/geoffreylitt/Zotero/storage/CVCA4C49/brave-new-world-of-full-service.html},
  journal = {Room 101},
  keywords = {Web Platform and Objects as Software Services}
}

@inproceedings{brandt2010,
  title = {Example-Centric Programming: Integrating Web Search into the Development Environment},
  shorttitle = {Example-Centric Programming},
  booktitle = {Proceedings of the 28th {{International Conference}} on {{Human Factors}} in {{Computing Systems}} - {{CHI}} '10},
  author = {Brandt, Joel and Dontcheva, Mira and Weskamp, Marcos and Klemmer, Scott R.},
  year = {2010},
  pages = {513},
  publisher = {{ACM Press}},
  address = {{Atlanta, Georgia, USA}},
  doi = {10.1145/1753326.1753402},
  abstract = {The ready availability of online source-code examples has fundamentally changed programming practices. However, current search tools are not designed to assist with programming tasks and are wholly separate from editing tools. This paper proposes that embedding a task-specific search engine in the development environment can significantly reduce the cost of finding information and thus enable programmers to write better code more easily. This paper describes the design, implementation, and evaluation of Blueprint, a Web search interface integrated into the Adobe Flex Builder development environment that helps users locate example code. Blueprint automatically augments queries with code context, presents a code-centric view of search results, embeds the search experience into the editor, and retains a link between copied code and its source. A comparative laboratory study found that Blueprint enables participants to write significantly better code and find example code significantly faster than with a standard Web browser. Analysis of three months of usage logs with 2,024 users suggests that task-specific search interfaces can significantly change how and when people search the Web.},
  isbn = {978-1-60558-929-9},
  language = {en}
}

@incollection{brandt2010a,
  title = {How the {{Web}} Helps People Turn Ideas into Code},
  booktitle = {No {{Code Required}}},
  author = {Brandt, Joel and Guo, Philip J. and Lewenstein, Joel and Dontcheva, Mira and Klemmer, Scott R.},
  year = {2010},
  pages = {439--451},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00023-7},
  abstract = {This chapter investigates the role of online resources in building software. We look specifically at how programmers \textendash{} an exemplar form of knowledge workers \textendash{} opportunistically interleave Web foraging, learning, and writing code. To understand this, we have both studied how programmers work in the lab and analyzed Web search logs of programming resources. The lab provides rich, detailed information and context about how programmers work; online studies offer a naturalistic setting and the advantages of scale. We found that programmers engage in just-in-time learning of new skills and approaches, clarify and extend their existing knowledge, and remind themselves of details deemed not worth remembering. The results also suggest that queries for different purposes have different styles and durations. These results contribute to a theory of online resource usage in programming, and suggest opportunities for tools to facilitate online knowledge work.},
  file = {/Users/geoffreylitt/Zotero/storage/QR9YPLCF/Brandt et al. - 2010 - How the Web helps people turn ideas into code.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@inproceedings{brewer1999,
  title = {Color {{Use Guidelines}} for {{Data Representation}}},
  booktitle = {Proceedings of the {{Section}} on {{Statistical Graphics}}, {{American Statistical Association}}},
  author = {Brewer, Cynthia A.},
  year = {1999},
  pages = {55--60},
  address = {{Alexandria, VA}},
  abstract = {Matching the organization of the perceptual dimensions of color (hue, lightness, saturation) to the organization of data being represented is one key to gaining insight from data visualizations. Geographic mappings of data are akin to three-variable graphs and thus benefit from the multi-dimensional nature of color symbolization. Systematic paths within perceptually ordered color systems, such as Munsell and CIELAB, produce logical progressions of color. Colors that progress from light to dark through a series of adjacent hues are an effective way to symbolize quantitative data that are monotonically increasing. Alternatively, emphasis on a critical value midway through a data range is accomplished by using the lightest color in a scheme to represent the critical value and then diverging toward different hues for high and low data extremes. Common spectral schemes (red-orange-yellow-green-blue) are well suited as diverging schemes by centering light yellow on a middle value, such as a mean or median. Visual comparisons between map distributions are aided by systematic two-variable color schemes. A topology of ten perceptually ordered schemes will be presented. In addition, vision research results are used to guide selection of combinations of hues that are easily distinguished by people who are colorblind (4 percent of the population).},
  language = {en}
}

@inproceedings{brown1984,
  title = {A System for Algorithm Animation},
  booktitle = {Proceedings of the 11th Annual Conference on {{Computer}} Graphics and Interactive Techniques},
  author = {Brown, Marc H. and Sedgewick, Robert},
  year = {1984},
  month = jan,
  pages = {177--186},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/800031.808596},
  abstract = {A software environment is described which provides facilities at a variety of levels for ``animating'' algorithms: exposing properties of programs by displaying multiple dynamic views of the program and associated data structures. The system is operational on a network of graphics-based, personal workstations and has been used successfully in several applications for teaching and research in computer science and mathematics. In this paper, we outline the conceptual framework that we have developed for animating algorithms, describe the system that we have implemented, and give several examples drawn from the host of algorithms that we have animated.},
  file = {/Users/geoffreylitt/Zotero/storage/4XLPNHXX/Brown and Sedgewick - 1984 - A system for algorithm animation.pdf},
  isbn = {978-0-89791-138-2},
  series = {{{SIGGRAPH}} '84}
}

@incollection{bruls2000,
  title = {Squarified {{Treemaps}}},
  booktitle = {Data {{Visualization}} 2000},
  author = {Bruls, Mark and Huizing, Kees and {van Wijk}, Jarke J.},
  editor = {{de Leeuw}, Willem Cornelis and {van Liere}, Robert},
  year = {2000},
  pages = {33--42},
  publisher = {{Springer Vienna}},
  address = {{Vienna}},
  abstract = {An extension to the treemap method for the visualization of hierarchical information, such as directory structures and organization structures, is presented. The standard treemap method often gives thin, elongated rectangles. As a result, rectangles are difficult to compare and to select. A new method is presented to generate lay-outs in which the rectangles approximate squares. To strenghten the visualization of the structure, shaded frames are used around groups of related nodes.},
  isbn = {978-3-211-83515-9 978-3-7091-6783-0},
  language = {en}
}

@article{bush1945,
  title = {As {{We May Think}}},
  author = {Bush, Vannevar},
  year = {1945},
  month = jul,
  journal = {The Atlantic Monthly}
}

@misc{buxton2007,
  title = {Multi-{{Touch Systems}} That {{I}} Have {{Known}} and {{Loved}}},
  author = {Buxton, Bill},
  year = {2007},
  month = jan,
  howpublished = {http://www.billbuxton.com/multitouchOverview.html},
  journal = {Bill Buxton}
}

@book{buxton2011,
  title = {Sketching {{User Experiences}}: {{Getting}} the {{Design Right}} and the {{Right Design}}},
  shorttitle = {Sketching {{User Experiences}}},
  author = {Buxton, Bill},
  year = {2011},
  publisher = {{Morgan Kaufmann}},
  address = {{Amsterdam}},
  isbn = {978-0-12-374037-3},
  language = {en}
}

@inproceedings{card1986,
  title = {User {{Technology}}: {{From Pointing}} to {{Pondering}}},
  booktitle = {{{ACM Conference}} on the {{History}} of {{Personal Workstations}}},
  author = {Card, Stuart K. and Moran, Thomas P.},
  year = {1986},
  pages = {183--98},
  language = {en}
}

@inproceedings{card1986a,
  title = {User Technology\&\#x2014;from Pointing to Pondering},
  booktitle = {Proceedings of the {{ACM Conference}} on {{The}} History of Personal Workstations},
  author = {Card, Stuart and Moran, Thomas},
  year = {1986},
  month = jan,
  pages = {183--198},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/12178.12189},
  abstract = {From its beginning, the technology of personal workstations has been driven by visions of a future in which people would work in intimate partnership with computer systems on significant intellectual tasks. These visions have been expressed in various forms: Memex (Bush, 1945), Man-Machine Symbiosis (Licklider, 1960), NLS (Engelbart, 1963), Dynabook (Kay, 1977), and others. The tight coupling between human and computer required by these visions necessitated advances in the ways humans and computers interact. These advances have slowly begun to accumulate into what might be called a user technology. This user technology includes hardware and software techniques for building effective user interfaces: bitmapped displays, menus, pointing devices, ``modeless'' command languages, animation, and interface metaphors. But it must include a technical understanding of the user himself and of the nature of human-computer interaction. This latter part, the scientific base of user technology, is necessary in order to understand why interaction techniques are (or are not) successful, to help us invent new techniques, and to pave the way for machines that aid humans in performing significant intellectual tasks. In this paper, we trace some of the history of our understanding of users and their interaction with workstation\textemdash the personal part of personal workstations. In keeping with the spirit of other papers at this conference, we have centered this review around our own experiences, perspectives, and work and have not attempted a complete history of the field. In concentrating on our own work, we do not wish to mimimize the importance of others' work; we simply want to tell our own story. Our focus is on what we have learned about users in our years of studying them and how we see our findings relating to the original visions of the personal workstation.},
  file = {/Users/geoffreylitt/Zotero/storage/SEGT9G8P/Card and Moran - 1986 - User technology&#x2014\;from pointing to pondering.pdf},
  isbn = {978-0-89791-176-4},
  series = {{{HPW}} '86}
}

@article{card1991,
  title = {A {{Morphological Analysis}} of the {{Design Space}} of {{Input Devices}}},
  author = {Card, Stuart K. and Mackinlay, Jock D. and Robertson, George G.},
  year = {1991},
  month = apr,
  volume = {9},
  pages = {99--122},
  issn = {10468188},
  doi = {10.1145/123078.128726},
  journal = {ACM Transactions on Information Systems},
  language = {en},
  number = {2}
}

@article{chajed,
  title = {Amber: {{Decoupling User Data}} from {{Web Applications}}},
  author = {Chajed, Tej and Gjengset, Jon and Mickens, James and Morris, Robert and Zeldovich, Nickolai},
  pages = {6},
  abstract = {User-generated content is becoming increasingly common on the Web, but current web applications isolate their users' data, enabling only restricted sharing and cross-service integration. We believe users should be able to share their data seamlessly between their applications and with other users. To that end, we propose Amber, an architecture that decouples users' data from applications, while providing applications with powerful global queries to find user data. We demonstrate how multi-user applications, such as e-mail, can use these global queries to efficiently collect and monitor relevant data created by other users. Amber puts users in control of which applications they use with their data and with whom it is shared, and enables a new class of applications by removing the artificial partitioning of users' data by application.},
  file = {/Users/geoffreylitt/Zotero/storage/MY7XQ97R/Chajed et al. - Amber Decoupling User Data from Web Applications.pdf},
  language = {en}
}

@inproceedings{chang2014,
  title = {Creating Interactive Web Data Applications with Spreadsheets},
  booktitle = {Proceedings of the 27th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '14},
  author = {Chang, Kerry Shih-Ping and Myers, Brad A.},
  year = {2014},
  pages = {87--96},
  publisher = {{ACM Press}},
  address = {{Honolulu, Hawaii, USA}},
  doi = {10.1145/2642918.2647371},
  abstract = {While more and more data are available through web services, it remains difficult for end-users to create web applications that make use of these data without having to write complex code. We present Gneiss, a live programming environment that extends the spreadsheet metaphor to support creating interactive web applications that dynamically use local and web data from multiple sources. Gneiss closely integrates a spreadsheet editor with a web interface builder to let users demonstrate bindings between properties of web GUI elements and cells in the spreadsheet while working with real web service data. The spreadsheet editor provides two-way connections to web services, to both visualize and retrieve different data based on the user input in the web interface. Gneiss achieves rich interactivity without the need for event-based programming by extending the ``pull model'' of formulas that is familiar to the spreadsheet users. We use a series of examples to demonstrate Gneiss's ability to create a variety of interactive web data applications.},
  file = {/Users/geoffreylitt/Zotero/storage/VKRPDATE/Chang and Myers - 2014 - Creating interactive web data applications with sp.pdf},
  isbn = {978-1-4503-3069-5},
  language = {en}
}

@article{chang2019,
  title = {Dependent Type Systems as Macros},
  author = {Chang, Stephen and Ballantyne, Michael and Turner, Milo and Bowman, William J.},
  year = {2019},
  month = dec,
  volume = {4},
  pages = {1--29},
  issn = {24751421},
  doi = {10.1145/3371071},
  file = {/Users/geoffreylitt/Zotero/storage/DL7ZUBWU/Chang et al. - 2019 - Dependent type systems as macros.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  keywords = {toread},
  language = {en},
  number = {POPL}
}

@inproceedings{chari2018,
  title = {Self-Contained Development Environments},
  booktitle = {Proceedings of the 14th {{ACM SIGPLAN International Symposium}} on {{Dynamic Languages}} - {{DLS}} 2018},
  author = {Chari, Guido and Pim{\'a}s, Javier and Vitek, Jan and Fl{\"u}ckiger, Olivier},
  year = {2018},
  pages = {76--87},
  publisher = {{ACM Press}},
  address = {{Boston, MA, USA}},
  doi = {10.1145/3276945.3276948},
  abstract = {Operating systems are traditionally implemented in lowlevel, performance-oriented programming languages. These languages typically rely on minimal runtime support and provide unfettered access to the underlying hardware. Tradition has benefits: developers control the resources that the operating system manages and few performance bottlenecks cannot be overcome with clever feats of programming. On the other hand, this makes operating systems harder to understand and maintain. Furthermore, those languages have few built-in barriers against bugs. This paper is an experiment in side-stepping operating systems, and pushing functionality into the runtime of high-level programming languages. The question we try to answer is how much support is needed to run an application written in, say, Smalltalk or Python on bare metal, that is, with no underlying operating system. We present a framework named NopSys that allows this, and we validate it with the implementation of CogNos a Smalltalk virtual machine running on bare x86 hardware. Experimental results suggest that this approach is promising.},
  file = {/Users/geoffreylitt/Zotero/storage/DXJEGUFU/Chari et al. - 2018 - Self-contained development environments.pdf},
  isbn = {978-1-4503-6030-2},
  language = {en}
}

@inproceedings{chasins2018,
  title = {Rousillon: {{Scraping Distributed Hierarchical Web Data}}},
  shorttitle = {Rousillon},
  booktitle = {The 31st {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}} - {{UIST}} '18},
  author = {Chasins, Sarah E. and Mueller, Maria and Bodik, Rastislav},
  year = {2018},
  pages = {963--975},
  publisher = {{ACM Press}},
  address = {{Berlin, Germany}},
  doi = {10.1145/3242587.3242661},
  abstract = {Programming by Demonstration (PBD) promises to enable data scientists to collect web data. However, in formative interviews with social scientists, we learned that current PBD tools are insufficient for many real-world web scraping tasks. The missing piece is the capability to collect hierarchicallystructured data from across many different webpages. We present Rousillon, a programming system for writing complex web automation scripts by demonstration. Users demonstrate how to collect the first row of a `universal table' view of a hierarchical dataset to teach Rousillon how to collect all rows. To offer this new demonstration model, we developed novel relation selection and generalization algorithms. In a withinsubject user study on 15 computer scientists, users can write hierarchical web scrapers 8 times more quickly with Rousillon than with traditional programming.},
  file = {/Users/geoffreylitt/Zotero/storage/DJQ79QKU/Chasins et al. - 2018 - Rousillon Scraping Distributed Hierarchical Web D.pdf},
  isbn = {978-1-4503-5948-1},
  language = {en}
}

@inproceedings{chen2020,
  title = {Multi-Modal Synthesis of Regular Expressions},
  booktitle = {Proceedings of the 41st {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  author = {Chen, Qiaochu and Wang, Xinyu and Ye, Xi and Durrett, Greg and Dillig, Isil},
  year = {2020},
  month = jun,
  pages = {487--502},
  publisher = {{ACM}},
  address = {{London UK}},
  doi = {10.1145/3385412.3385988},
  abstract = {In this paper, we propose a multi-modal synthesis technique for automatically constructing regular expressions (regexes) from a combination of examples and natural language. Using multiple modalities is useful in this context because natural language alone is often highly ambiguous, whereas examples in isolation are often not sufficient for conveying user intent. Our proposed technique first parses the English description into a so-called hierarchical sketch that guides our programming-by-example (PBE) engine. Since the hierarchical sketch captures crucial hints, the PBE engine can leverage this information to both prioritize the search as well as make useful deductions for pruning the search space.},
  file = {/Users/geoffreylitt/Zotero/storage/PRUWQ9ZS/Chen et al. - 2020 - Multi-modal synthesis of regular expressions.pdf},
  isbn = {978-1-4503-7613-6},
  language = {en}
}

@incollection{chilton2010,
  title = {Why We Customize the {{Web}}},
  booktitle = {No {{Code Required}}},
  author = {Chilton, Lydia B. and Miller, Robert C. and Little, Greg and Yu, Chen-Hsiang},
  year = {2010},
  pages = {23--35},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00002-X},
  abstract = {The Web is increasingly an application platform comparable to the desktop, but its openness enables more customizations than were possible on the desktop. This chapter examines the kinds of customization seen on the Web, focusing on the highly extensible Mozilla Firefox Web browser, and compares and contrasts the motivations for Web customization with desktop customization.},
  file = {/Users/geoffreylitt/Zotero/storage/CPDBUMWR/Chilton et al. - 2010 - Why we customize the Web.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@article{chis2015,
  title = {Practical Domain-Specific Debuggers Using the {{Moldable Debugger}} Framework},
  author = {Chi{\c s}, Andrei and Denker, Marcus and G{\^i}rba, Tudor and Nierstrasz, Oscar},
  year = {2015},
  month = dec,
  volume = {44},
  pages = {89--113},
  issn = {14778424},
  doi = {10.1016/j.cl.2015.08.005},
  abstract = {Understanding the run-time behaviour of software systems can be a challenging activity. Debuggers are an essential category of tools used for this purpose as they give developers direct access to the running systems. Nevertheless, traditional debuggers rely on generic mechanisms to introspect and interact with the running systems, while developers reason about and formulate domain-specific questions using concepts and abstractions from their application domains. This mismatch creates an abstraction gap between the debugging needs and the debugging support leading to an inefficient and error-prone debugging effort, as developers need to recover concrete domain concepts using generic mechanisms. To reduce this gap, and increase the efficiency of the debugging process, we propose a framework for developing domain-specific debuggers, called the Moldable Debugger, that enables debugging at the level of the application domain. The Moldable Debugger is adapted to a domain by creating and combining domain-specific debugging operations with domain-specific debugging views, and adapts itself to a domain by selecting, at run time, appropriate debugging operations and views. To ensure the proposed model has practical applicability (i.e., can be used in practice to build real debuggers), we discuss, from both a performance and usability point of view, three implementation strategies. We further motivate the need for domain-specific debugging, identify a set of key requirements and show how our approach improves debugging by adapting the debugger to several domains.},
  file = {/Users/geoffreylitt/Zotero/storage/VP5FBI92/Chiş et al. - 2015 - Practical domain-specific debuggers using the Mold.pdf},
  journal = {Computer Languages, Systems \& Structures},
  language = {en}
}

@article{chlipala2016,
  title = {The {{End}} of {{History}}? {{Using}} a {{Proof Assistant}} to {{Replace Language Design}} with {{Library Design}}},
  author = {Chlipala, Adam and Delaware, Benjamin and Duchovni, Samuel and {Pit-Claudel}, Cl{\'e}ment and Suriyakarn, Sorawit and Wang, Peng and Ye, Katherine},
  year = {2016},
  pages = {14},
  abstract = {Functionality of software systems has exploded in part because of advances in programminglanguage support for packaging reusable functionality as libraries. Developers benefit from the uniformity that comes of exposing many interfaces in the same language, as opposed to stringing together hodgepodges of command-line tools. Domain-specific languages may be viewed as an evolution of the power of reusable interfaces, when those interfaces become so flexible as to deserve to be called programming languages. However, common approaches to domain-specific languages give up many of the hard-won advantages of library-building in a rich common language, and even the traditional approach poses significant challenges in learning new APIs. We suggest that instead of continuing to develop new domain-specific languages, our community should embrace library-based ecosystems within very expressive languages that mix programming and theorem proving. Our prototype framework Fiat, a library for the Coq proof assistant, turns languages into easily comprehensible libraries via the key idea of modularizing functionality and performance away from each other, the former via macros that desugar into higher-order logic and the latter via optimization scripts that derive efficient code from logical programs.},
  file = {/Users/geoffreylitt/Zotero/storage/I3EUUHAE/Chlipala et al. - 2016 - The End of History Using a Proof Assistant to Rep.pdf},
  keywords = {toread},
  language = {en}
}

@article{coblenz2020,
  title = {User-{{Centered Programming Language Design}}: {{A Course}}-{{Based Case Study}}},
  shorttitle = {User-{{Centered Programming Language Design}}},
  author = {Coblenz, Michael and Davis, Ariel and Hofmann, Megan and Huang, Vivian and Jin, Siyue and Krieger, Max and Liang, Kyle and Wei, Brian and Yong, Mengchen Sam and Aldrich, Jonathan},
  year = {2020},
  month = nov,
  abstract = {Recently, user-centered methods have been proposed to improve the design of programming languages. In order to explore what benefits these methods might have for novice programming language designers, we taught a collection of user-centered programming language design methods to a group of eight students. We observed that natural programming and usability studies helped the students refine their language designs and identify opportunities for improvement, even in the short duration of a course project.},
  archivePrefix = {arXiv},
  eprint = {2011.07565},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/KPXCGN7G/Coblenz et al. - 2020 - User-Centered Programming Language Design A Cours.pdf;/Users/geoffreylitt/Zotero/storage/BLSU36GQ/2011.html},
  journal = {arXiv:2011.07565 [cs]},
  keywords = {Computer Science - Programming Languages,D.2,D.3},
  primaryClass = {cs}
}

@article{coblenz2020a,
  title = {{{PLIERS}}: {{A Process}} That {{Integrates User}}-{{Centered Methods}} into {{Programming Language Design}}},
  shorttitle = {{{PLIERS}}},
  author = {Coblenz, Michael and Kambhatla, Gauri and Koronkevich, Paulette and Wise, Jenna L. and Barnaby, Celeste and Sunshine, Joshua and Aldrich, Jonathan and Myers, Brad A.},
  year = {2020},
  month = aug,
  abstract = {Programming language design requires making many usability-related design decisions. However, existing HCI methods can be impractical to apply to programming languages: they have high iteration costs, programmers require significant learning time, and user performance has high variance. To address these problems, we adapted both formative and summative HCI methods to make them more suitable for programming language design. We integrated these methods into a new process, PLIERS, for designing programming languages in a user-centered way. We evaluated PLIERS by using it to design two new programming languages. Glacier extends Java to enable programmers to express immutability properties effectively and easily. Obsidian is a language for blockchains that includes verification of critical safety properties. Summative usability studies showed that programmers were able to program effectively in both languages after short training periods.},
  archivePrefix = {arXiv},
  eprint = {1912.04719},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/ZV4NTKM2/ZV4NTKM2.pdf;/Users/geoffreylitt/Zotero/storage/XC6WSIMP/1912.html},
  journal = {arXiv:1912.04719 [cs]},
  keywords = {Computer Science - Human-Computer Interaction,Computer Science - Programming Languages,Computer Science - Software Engineering,D.3.3,H.5.2},
  primaryClass = {cs}
}

@inproceedings{cook2007,
  title = {{{AppleScript}}},
  booktitle = {Proceedings of the Third {{ACM SIGPLAN}} Conference on {{History}} of Programming Languages  - {{HOPL III}}},
  author = {Cook, William R.},
  year = {2007},
  pages = {1-1-1-21},
  publisher = {{ACM Press}},
  address = {{San Diego, California}},
  doi = {10.1145/1238844.1238845},
  file = {/Users/geoffreylitt/Zotero/storage/4ZFGV2YC/4ZFGV2YC.pdf},
  language = {en}
}

@article{correll2014,
  title = {Error {{Bars Considered Harmful}}: {{Exploring Alternate Encodings}} for {{Mean}} and {{Error}}},
  shorttitle = {Error {{Bars Considered Harmful}}},
  author = {Correll, Michael and Gleicher, Michael},
  year = {2014},
  month = dec,
  volume = {20},
  pages = {2142--2151},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2014.2346298},
  abstract = {When making an inference or comparison with uncertain, noisy, or incomplete data, measurement error and confidence intervals can be as important for judgment as the actual mean values of different groups. These often misunderstood statistical quantities are frequently represented by bar charts with error bars. This paper investigates drawbacks with this standard encoding, and considers a set of alternatives designed to more effectively communicate the implications of mean and error data to a general audience, drawing from lessons learned from the use of visual statistics in the information visualization community. We present a series of crowd-sourced experiments that confirm that the encoding of mean and error significantly changes how viewers make decisions about uncertain data. Careful consideration of design tradeoffs in the visual presentation of data results in human reasoning that is more consistently aligned with statistical inferences. We suggest the use of gradient plots (which use transparency to encode uncertainty) and violin plots (which use width) as better alternatives for inferential tasks than bar charts with error bars.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  language = {en},
  number = {12}
}

@article{costa2020,
  title = {Alternatives for Facilitating Automatic Transformation of {{BIM}} Data Using Semantic Query Languages},
  author = {Costa, G. and Sicilia, A.},
  year = {2020},
  month = dec,
  volume = {120},
  pages = {103384},
  issn = {09265805},
  doi = {10.1016/j.autcon.2020.103384},
  abstract = {In the Architecture Engineering and Construction (AEC) industry, Building Information Model (BIM) authoring tools enable the creation of digital representations of buildings. Each tool implements its own building data model, which makes it difficult to achieve the desired interoperability when building data have to be exchanged with other software (e.g., building energy simulation tools). The representation of BIM models through open standards (e.g., IFC) and Semantic Web technologies can facilitate building data transformation in an automated and flexible way. This is achieved by taking advantage of the logical basis of the Resource Description Framework (RDF) data model and queries created in the Semantic Web query languages. The result is a prag\- matic mechanism to transform the data from one data domain to another. This article analyses the potential of Semantic Web query languages to facilitate the data transformation of building data through different alter\- natives. The first contribution is the identification of fourteen data mapping patterns and three cases of data transformation that enable transforming one data model into another, considering the semantic and structural differences between them. The second contribution is the review and comparison of query languages to carry out the transformations through two different alternatives: using SPARQL-Generate and SPARQL Construct queries. And finally, the third contribution is the definition of a metric to assess the complexity of SPARQL queries.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/costa2020.md;/Users/geoffreylitt/Zotero/storage/9XBF93FL/Costa and Sicilia - 2020 - Alternatives for facilitating automatic transforma.pdf},
  journal = {Automation in Construction},
  language = {en}
}

@article{crichton2021,
  title = {The {{Role}} of {{Working Memory}} in {{Program Tracing}}},
  author = {Crichton, Will and Agrawala, Maneesh and Hanrahan, Pat},
  year = {2021},
  month = jan,
  doi = {10.1145/3411764.3445257},
  abstract = {Program tracing, or mentally simulating a program on concrete inputs, is an important part of general program comprehension. Programs involve many kinds of virtual state that must be held in memory, such as variable/value pairs and a call stack. In this work, we examine the influence of short-term working memory (WM) on a person's ability to remember program state during tracing. We first confirm that previous findings in cognitive psychology transfer to the programming domain: people can keep about 7 variable/value pairs in WM, and people will accidentally swap associations between variables due to WM load. We use a restricted focus viewing interface to further analyze the strategies people use to trace through programs, and the relationship of tracing strategy to WM. Given a straight-line program, we find half of our participants traced a program from the top-down line-by-line (linearly), and the other half start at the bottom and trace upward based on data dependencies (on-demand). Participants with an on-demand strategy made more WM errors while tracing straight-line code than with a linear strategy, but the two strategies contained an equal number of WM errors when tracing code with functions. We conclude with the implications of these findings for the design of programming tools: first, programs should be analyzed to identify and refactor human-memory-intensive sections of code. Second, programming environments should interactively visualize variable metadata to reduce WM load in accordance with a person's tracing strategy. Third, tools for program comprehension should enable externalizing program state while tracing.},
  archivePrefix = {arXiv},
  eprint = {2101.06305},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/UXSA7B6D/UXSA7B6D.pdf;/Users/geoffreylitt/Zotero/storage/KDAZBW99/2101.html},
  journal = {arXiv:2101.06305 [cs]},
  keywords = {Computer Science - Human-Computer Interaction},
  primaryClass = {cs}
}

@book{cypher1993,
  title = {Watch {{What I Do}}: {{Programming}} by {{Demonstration}}},
  shorttitle = {Watch {{What I Do}}},
  editor = {Cypher, Allen and Halbert, Daniel C. and Kurlander, David and Lieberman, Henry and Maulsby, David and Myers, Brad A. and Turransky, Alan},
  year = {1993},
  month = may,
  edition = {1st edition},
  publisher = {{The MIT Press}},
  address = {{Cambridge, Mass}},
  abstract = {Until recently most programming power has been in the hands of the professional programmer rather than the end user. Programming by Demonstration is a method that allows end users to create, customize, and extend programs by demonstrating what the program should do. Programming by Demonstration systems have existed since 1975, yet this is the first time that information on all of the best of these systems has been gathered in one place. The first section of the book describes 18 computer implementations of Programming by Demonstration, and the second section discusses the problems and opportunities for this method in more general terms.Included in the appendices is a test suite, a collection of practical examples illustrating the broad variety of tasks that are amenable to Programming by Demonstration. The test suite is also useful for researchers, who can evaluate their own systems in terms of how well they are able to automate these tasks.ContentsIntroductionSection 1: Systems; Pygmalion; Tinker; A Predictive Calculator; Rehearsal World; SmallStar; Peridot; Metamouse; TELS, Eager; Garnet; The Turvy Experience; Chimera; The Geometer's Sketchpad; Tourmaline; A History-Based Macro by Example System; Mondrian; Triggers; The AIDE ProjectSection II: Components; A History of Editable Graphical, Histories; Graphical Representation and Feedback in a PBD System; PBD Invocation Techniques; A System-Wide Macro Facility Based on Aggregate Events; Making Programming Accessible to Visual Problem Solvers; Using Voice Input to Disambiguate IntentSection III: Perspectives; Characterizing PBD Systems; Demonstrational Interfaces; Just-in-Time Programming},
  isbn = {978-0-262-03213-1},
  language = {English}
}

@incollection{cypher2010,
  title = {End User Programming on the {{Web}}},
  booktitle = {No {{Code Required}}},
  author = {Cypher, Allen},
  year = {2010},
  pages = {3--22},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00001-8},
  abstract = {This introduction explains who end users are and why they want to program. In the past 25 years, there have been two main approaches to enable end users to create their own programs: scripting languages and programming by demonstration. After outlining the challenges that confront these approaches, we shall see how the Web has removed some of the most significant barriers, opening the way for the recent progress that is detailed in this book.},
  file = {/Users/geoffreylitt/Zotero/storage/DS4X22YE/Cypher - 2010 - End user programming on the Web.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@incollection{cypher2010a,
  title = {Collaborative Scripting for the {{Web}}},
  booktitle = {No {{Code Required}}},
  author = {Cypher, Allen and Drews, Clemens and Haber, Eben and Kandogan, Eser and Lin, James and Lau, Tessa and Leshed, Gilly and Matthews, Tara and Wilcox, Eric},
  year = {2010},
  pages = {85--104},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00005-5},
  abstract = {Today's knowledge workers interact with a variety of Web-based tasks in the course of their jobs. We have found that two of the challenges faced by these workers are automation of repetitive tasks, and support for complex or hard-to-remember tasks. This chapter presents CoScripter, a system that enables users to capture, share, and automate tasks on the Web. CoScripter's most notable features include ClearScript, a scripting language that is both human-readable and machine-understandable, and built-in support for sharing via a Web-based script repository. CoScripter has been used by tens of thousands of people on the Web. Our user studies show that CoScripter has helped people both automate repetitive Web tasks, and share how-to knowledge inside the enterprise.},
  file = {/Users/geoffreylitt/Zotero/storage/U84JQNIC/Cypher et al. - 2010 - Collaborative scripting for the Web.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@misc{czaplicki,
  title = {The {{Elm Architecture}} {$\cdot$} {{An Introduction}} to {{Elm}}},
  author = {Czaplicki, Evan},
  file = {/Users/geoffreylitt/Zotero/storage/P4VFX8C7/architecture.html},
  howpublished = {https://guide.elm-lang.org/architecture/}
}

@incollection{czarnecki2009,
  title = {Bidirectional {{Transformations}}: {{A Cross}}-{{Discipline Perspective}}},
  shorttitle = {Bidirectional {{Transformations}}},
  booktitle = {Theory and {{Practice}} of {{Model Transformations}}},
  author = {Czarnecki, Krzysztof and Foster, J. Nathan and Hu, Zhenjiang and L{\"a}mmel, Ralf and Sch{\"u}rr, Andy and Terwilliger, James F.},
  editor = {Paige, Richard F.},
  year = {2009},
  volume = {5563},
  pages = {260--283},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-02408-5_19},
  abstract = {The GRACE International Meeting on Bidirectional Transformations was held in December 2008 near Tokyo, Japan. The meeting brought together researchers and practitioners from a variety of subdisciplines of computer science to share research efforts and help create a new community. In this report, we survey the state of the art and summarize the technical presentations delivered at the meeting. We also describe some insights gathered from our discussions and introduce a new effort to establish a benchmark for bidirectional transformations.},
  file = {/Users/geoffreylitt/Zotero/storage/AVQKHFF3/Czarnecki et al. - 2009 - Bidirectional Transformations A Cross-Discipline .pdf},
  isbn = {978-3-642-02407-8 978-3-642-02408-5},
  language = {en}
}

@incollection{czarnecki2009a,
  title = {Bidirectional {{Transformations}}: {{A Cross}}-{{Discipline Perspective}}},
  shorttitle = {Bidirectional {{Transformations}}},
  booktitle = {Theory and {{Practice}} of {{Model Transformations}}},
  author = {Czarnecki, Krzysztof and Foster, J. Nathan and Hu, Zhenjiang and L{\"a}mmel, Ralf and Sch{\"u}rr, Andy and Terwilliger, James F.},
  editor = {Paige, Richard F.},
  year = {2009},
  volume = {5563},
  pages = {260--283},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-02408-5_19},
  abstract = {The GRACE International Meeting on Bidirectional Transformations was held in December 2008 near Tokyo, Japan. The meeting brought together researchers and practitioners from a variety of subdisciplines of computer science to share research efforts and help create a new community. In this report, we survey the state of the art and summarize the technical presentations delivered at the meeting. We also describe some insights gathered from our discussions and introduce a new effort to establish a benchmark for bidirectional transformations.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/czarnecki2009a.md;/Users/geoffreylitt/Zotero/storage/B6Q32Z7T/Czarnecki et al. - 2009 - Bidirectional Transformations A Cross-Discipline .pdf},
  isbn = {978-3-642-02407-8 978-3-642-02408-5},
  language = {en}
}

@article{dangelo2018,
  title = {Spacetime {{Characterization}} of {{Real}}-{{Time Collaborative Editing}}},
  author = {D'Angelo, Gabriele and Di Iorio, Angelo and Zacchiroli, Stefano},
  year = {2018},
  month = nov,
  volume = {2},
  pages = {1--19},
  issn = {2573-0142, 2573-0142},
  doi = {10.1145/3274310},
  file = {/Users/geoffreylitt/Zotero/storage/QT397IGN/D'Angelo et al. - 2018 - Spacetime Characterization of Real-Time Collaborat.pdf},
  journal = {Proceedings of the ACM on Human-Computer Interaction},
  language = {en},
  number = {CSCW}
}

@book{daub2020,
  title = {What {{Tech Calls Thinking}}: {{An Inquiry}} into the {{Intellectual Bedrock}} of {{Silicon Valley}}},
  shorttitle = {What {{Tech Calls Thinking}}},
  author = {Daub, Adrian},
  year = {2020},
  month = oct,
  publisher = {{FSG Originals}},
  address = {{New York}},
  abstract = {From FSGO x Logic: a Stanford professor's spirited dismantling of Silicon Valley's intellectual originsAdrian Daub's What Tech Calls Thinking is a lively dismantling of the ideas that form the intellectual bedrock of Silicon Valley. Equally important to Silicon Valley's world-altering innovation are the language and ideas it uses to explain and justify itself. And often, those fancy new ideas are simply old motifs playing dress-up in a hoodie. From the myth of dropping out to the war cry of ``disruption,'' Daub locates the Valley's supposedly original, radical thinking in the ideas of Heidegger and Ayn Rand, the New Age Esalen Foundation in Big Sur, and American traditions from the tent revival to predestination. Written with verve and imagination, What Tech Calls Thinking is an intellectual refutation of Silicon Valley's ethos, pulling back the curtain on the self-aggrandizing myths the Valley tells about itself.FSG Originals \texttimes{} Logic dissects the way technology functions in everyday lives. The titans of Silicon Valley, for all their utopian imaginings, never really had our best interests at heart: recent threats to democracy, truth, privacy, and safety, as a result of tech's reckless pursuit of progress, have shown as much. We present an alternate story, one that delights in capturing technology in all its contradictions and innovation, across borders and socioeconomic divisions, from history through the future, beyond platitudes and PR hype, and past doom and gloom. Our collaboration features four brief but provocative forays into the tech industry's many worlds, and aspires to incite fresh conversations about technology focused on nuanced and accessible explorations of the emerging tools that reorganize and redefine life today.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/daub2020.md},
  isbn = {978-0-374-53864-4},
  language = {English}
}

@inproceedings{dell2012,
  title = {"{{Yours}} Is Better!": Participant Response Bias in {{HCI}}},
  shorttitle = {"{{Yours}} Is Better!"},
  booktitle = {Proceedings of the 2012 {{ACM}} Annual Conference on {{Human Factors}} in {{Computing Systems}} - {{CHI}} '12},
  author = {Dell, Nicola and Vaidyanathan, Vidya and Medhi, Indrani and Cutrell, Edward and Thies, William},
  year = {2012},
  pages = {1321},
  publisher = {{ACM Press}},
  address = {{Austin, Texas, USA}},
  doi = {10.1145/2207676.2208589},
  abstract = {Although HCI researchers and practitioners frequently work with groups of people that differ significantly from themselves, little attention has been paid to the effects these differences have on the evaluation of HCI systems. Via 450 interviews in Bangalore, India, we measure participant response bias due to interviewer demand characteristics and the role of social and demographic factors in influencing that bias. We find that respondents are about 2.5x more likely to prefer a technological artifact they believe to be developed by the interviewer, even when the alternative is identical. When the interviewer is a foreign researcher requiring a translator, the bias towards the interviewer's artifact increases to 5x. In fact, the interviewer's artifact is preferred even when it is degraded to be obviously inferior to the alternative. We conclude that participant response bias should receive more attention within the CHI community, especially when designing for underprivileged populations.},
  file = {/Users/geoffreylitt/Zotero/storage/Q2GS6MM5/Dell et al. - 2012 - Yours is better! participant response bias in H.pdf},
  isbn = {978-1-4503-1015-4},
  keywords = {study-design},
  language = {en}
}

@inproceedings{dennis2006,
  title = {Modular Verification of Code with {{SAT}}},
  booktitle = {Proceedings of the 2006 International Symposium on {{Software}} Testing and Analysis  - {{ISSTA}}'06},
  author = {Dennis, Greg and ShengHo, Felix and Jackson, Chang Daniel},
  year = {2006},
  pages = {109},
  publisher = {{ACM Press}},
  address = {{Portland, Maine, USA}},
  doi = {10.1145/1146238.1146251},
  abstract = {An approach is described for checking the methods of a class against a full specification. It shares with traditional model checking the idea of exhausting the entire space of executions within some finite bounds, and with traditional verification the idea of modular analysis, in which a method is analyzed, in isolation, for all possible calling contexts.},
  file = {/Users/geoffreylitt/Zotero/storage/IPCABAY3/Dennis et al. - 2006 - Modular verification of code with SAT.pdf},
  isbn = {978-1-59593-263-1},
  language = {en}
}

@inproceedings{dennis2006a,
  title = {Modular Verification of Code with {{SAT}}},
  booktitle = {Proceedings of the 2006 International Symposium on {{Software}} Testing and Analysis  - {{ISSTA}}'06},
  author = {Dennis, Greg and ShengHo, Felix and Jackson, Chang Daniel},
  year = {2006},
  pages = {109},
  publisher = {{ACM Press}},
  address = {{Portland, Maine, USA}},
  doi = {10.1145/1146238.1146251},
  abstract = {An approach is described for checking the methods of a class against a full specification. It shares with traditional model checking the idea of exhausting the entire space of executions within some finite bounds, and with traditional verification the idea of modular analysis, in which a method is analyzed, in isolation, for all possible calling contexts.},
  file = {/Users/geoffreylitt/Zotero/storage/HUVZ43XS/Dennis et al. - 2006 - Modular verification of code with SAT.pdf},
  isbn = {978-1-59593-263-1},
  language = {en}
}

@book{dent2009,
  title = {Cartography: {{Thematic Map Design}}},
  shorttitle = {Cartography},
  author = {Dent, Borden D. and Torguson, Jeffrey S. and Hodler, Thomas W.},
  year = {2009},
  edition = {6th edition},
  publisher = {{McGraw-Hill Higher Education}},
  address = {{New York}},
  isbn = {978-0-07-294382-5},
  keywords = {Cartography,Thematic maps},
  language = {en},
  lccn = {GA105.3 .D45 2009}
}

@article{disessa1986,
  title = {Boxer: A Reconstructible Computational Medium},
  shorttitle = {Boxer},
  author = {{diSessa}, A. A and Abelson, H.},
  year = {1986},
  month = sep,
  volume = {29},
  pages = {859--868},
  issn = {00010782},
  doi = {10.1145/6592.6595},
  file = {/Users/geoffreylitt/Zotero/storage/EWBMP8Z2/diSessa and Abelson - 1986 - Boxer a reconstructible computational medium.pdf},
  journal = {Communications of the ACM},
  language = {en},
  number = {9}
}

@book{disessa2000,
  title = {Changing {{Minds}}: {{Computers}}, {{Learning}}, and {{Literacy}}},
  shorttitle = {Changing {{Minds}}},
  author = {{diSessa}, Andrea A.},
  year = {2000},
  publisher = {{MIT Press}},
  address = {{Cambridge, MA, USA}}
}

@article{dontcheva,
  title = {Relations, {{Cards}}, and {{Search Templates}}: {{User}}-{{Guided Web Data Integration}} and {{Layout}}},
  author = {Dontcheva, Mira and Drucker, Steven M and Salesin, David and Cohen, Michael F},
  pages = {10},
  abstract = {We present three new interaction techniques for aiding users in collecting and organizing Web content. First, we demonstrate an interface for creating associations between websites, which facilitate the automatic retrieval of related content. Second, we present an authoring interface that allows users to quickly merge content from many different websites into a uniform and personalized representation, which we call a card. Finally, we introduce a novel search paradigm that leverages the relationships in a card to direct search queries to extract relevant content from multiple Web sources and fill a new series of cards instead of just returning a list of webpage URLs. Preliminary feedback from users is positive and validates our design.},
  file = {/Users/geoffreylitt/Zotero/storage/52C7ASCN/Dontcheva et al. - Relations, Cards, and Search Templates User-Guide.pdf},
  language = {en}
}

@inproceedings{dontcheva2006,
  title = {Summarizing Personal Web Browsing Sessions},
  booktitle = {Proceedings of the 19th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '06},
  author = {Dontcheva, Mira and Drucker, Steven M. and Wade, Geraldine and Salesin, David and Cohen, Michael F.},
  year = {2006},
  pages = {115},
  publisher = {{ACM Press}},
  address = {{Montreux, Switzerland}},
  doi = {10.1145/1166253.1166273},
  abstract = {We describe a system, implemented as a browser extension, that enables users to quickly and easily collect, view, and share personal Web content. Our system employs a novel interaction model, which allows a user to specify webpage extraction patterns by interactively selecting webpage elements and applying these patterns to automatically collect similar content. Further, we present a technique for creating visual summaries of the collected information by combining user labeling with predefined layout templates. These summaries are interactive in nature: depending on the behaviors encoded in their templates, they may respond to mouse events, in addition to providing a visual summary. Finally, the summaries can be saved or sent to others to continue the research at another place or time. Informal evaluation shows that our approach works well for popular websites, and that users can quickly learn this interaction model for collecting content from the Web.},
  file = {/Users/geoffreylitt/Zotero/storage/EDNRA7W9/Dontcheva et al. - 2006 - Summarizing personal web browsing sessions.pdf},
  isbn = {978-1-59593-313-3},
  language = {en}
}

@incollection{dontcheva2010,
  title = {From {{Web Summaries}} to Search Templates},
  booktitle = {No {{Code Required}}},
  author = {Dontcheva, Mira and Drucker, Steven M. and Salesin, David and Cohen, Michael F.},
  year = {2010},
  pages = {235--250},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00012-2},
  abstract = {This chapter describes the Web Summaries system, which is designed to aid people in accomplishing exploratory Web research. Web Summaries enables users to produce automation artifacts, such as extraction patterns, relations, and personalized task-specific search templates, in the context of existing tasks. By leveraging the growing amount of structured Web pages and pervasive search capabilities Web Summaries provides a set of semiautomatic interaction techniques for collecting and organizing personal Web content.},
  file = {/Users/geoffreylitt/Zotero/storage/6BKSRPQ2/Dontcheva et al. - 2010 - From Web Summaries to search templates.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@inproceedings{dourish2006,
  title = {Implications for {{Design}}},
  booktitle = {{{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Dourish, Paul},
  year = {2006},
  month = apr,
  pages = {541--550},
  address = {{Montreal, Canada}},
  abstract = {Although ethnography has become a common approach in HCI research and design, considerable confusion still attends both ethnographic practice and the criteria by which it should be evaluated in HCI. Often, ethnography is seen as an approach to field investigation that can generate requirements for systems development; by that token, the major evaluative criterion for an ethnographic study is the implications it can provide for design. Exploring the nature of ethnographic inquiry, this paper suggests that ``implications for design'' may not be the best metric for evaluation and may, indeed, fail to capture the value of ethnographic investigations.},
  language = {en}
}

@article{dourish2007,
  title = {The {{Infrastructure}} of {{Experience}} and the {{Experience}} of {{Infrastructure}}: {{Meaning}} and {{Structure}} in {{Everyday Encounters}} with {{Space}}},
  shorttitle = {The {{Infrastructure}} of {{Experience}} and the {{Experience}} of {{Infrastructure}}},
  author = {Dourish, Paul and Bell, Genevieve},
  year = {2007},
  month = jun,
  volume = {34},
  pages = {414--430},
  issn = {0265-8135},
  doi = {10.1068/b32035t},
  abstract = {Although the current developments in ubiquitous and pervasive computing are driven largely by technological opportunities, they have radical implications not just for technology design but also for the ways in which we experience and interact with computation. In particular, the move of computation `off the desktop' and into the world, whether embedded in the environment around us or carried or worn on our bodies, suggests that computation is beginning to manifest itself in new ways as an aspect of the everyday environment. One particularly interesting issue in this transformation is the move from a concern with virtual spaces to a concern with physical ones. Basically, once computation moves off the desktop, computer science suddenly has to be concerned with where it might have gone. Whereas computer science and human-computer interaction have previously been concerned with disembodied cognition, they must now look more directly at embodied action and bodily encounters between people and technology. In this paper, we explore some of the implications of the development of ubiquitous computing for encounters with space. We look on space here as infrastructure\textemdash not just a technological infrastructure, but an infrastructure through which we experience the world. Drawing on studies of both the practical organization of space and the cultural organization of space, we begin to explore the ways in which ubiquitous computing may condition, and be conditioned by, the social organization of everyday space.},
  journal = {Environment and Planning B: Planning and Design},
  language = {en},
  number = {3}
}

@incollection{dourish2014,
  title = {Reading and {{Interpreting Ethnography}}},
  booktitle = {Ways of Knowing in {{HCI}}},
  author = {Dourish, Paul},
  editor = {Olson, Judith S. and Kellogg, Wendy},
  year = {2014},
  pages = {1--24},
  publisher = {{Springer}},
  address = {{New York}},
  isbn = {978-1-4939-0377-1},
  keywords = {Human-computer interaction},
  language = {en},
  lccn = {QA76.9.H85 W39 2014}
}

@article{dow2010,
  title = {Parallel {{Prototyping Leads}} to {{Better Design Results}}, {{More Divergence}}, and {{Increased Self}}-{{Efficacy}}},
  author = {Dow, Steven P. and Glassco, Alana and Kass, Jonathan and Schwarz, Melissa and Schwartz, Daniel L. and Klemmer, Scott R.},
  year = {2010},
  month = dec,
  volume = {17},
  pages = {1--24},
  issn = {10730516},
  doi = {10.1145/1879831.1879836},
  journal = {ACM Transactions on Computer-Human Interaction},
  language = {en},
  number = {4}
}

@inproceedings{dubroy2017,
  title = {Incremental Packrat Parsing},
  booktitle = {Proceedings of the 10th {{ACM SIGPLAN International Conference}} on {{Software Language Engineering}}},
  author = {Dubroy, Patrick and Warth, Alessandro},
  year = {2017},
  month = oct,
  pages = {14--25},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3136014.3136022},
  abstract = {Packrat parsing is a popular technique for implementing top-down, unlimited-lookahead parsers that operate in guaranteed linear time. In this paper, we describe a method for turning a standard packrat parser into an incremental parser through a simple modification to its memoization strategy. By 'incremental', we mean that the parser can perform syntax analysis without completely reparsing the input after each edit operation. This makes packrat parsing suitable for interactive use in code editors and IDEs - even with large inputs. Our experiments show that with our technique, an incremental packrat parser for JavaScript can outperform even a hand-optimized, non-incremental parser.},
  isbn = {978-1-4503-5525-4},
  keywords = {incremental parsing,packrat parsing},
  series = {{{SLE}} 2017}
}

@inproceedings{eagan2011,
  title = {Cracking the Cocoa Nut: User Interface Programming at Runtime},
  shorttitle = {Cracking the Cocoa Nut},
  booktitle = {Proceedings of the 24th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '11},
  author = {Eagan, James R. and {Beaudouin-Lafon}, Michel and Mackay, Wendy E.},
  year = {2011},
  pages = {225},
  publisher = {{ACM Press}},
  address = {{Santa Barbara, California, USA}},
  doi = {10.1145/2047196.2047226},
  abstract = {This article introduces runtime toolkit overloading, a novel approach to help third-party developers modify the interaction and behavior of existing software applications without access to their underlying source code. We describe the abstractions provided by this approach as well as the mechanisms for implementing them in existing environments. We describe Scotty, a prototype implementation for Mac OS X Cocoa that enables developers to modify existing applications at runtime, and we demonstrate a collection of interaction and functional transformations on existing off-the-shelf applications. We show how Scotty helps a developer make sense of unfamiliar software, even without access to its source code. We further discuss what features of future environments would facilitate this kind of runtime software development.},
  file = {/Users/geoffreylitt/Zotero/storage/EBX2GJRX/Eagan et al. - 2011 - Cracking the cocoa nut user interface programming.pdf},
  isbn = {978-1-4503-0716-1},
  language = {en}
}

@inproceedings{eagan2017,
  title = {Grab 'n' {{Drop}}: {{User Configurable Toolglasses}}},
  shorttitle = {Grab 'n' {{Drop}}},
  booktitle = {{{INTERACT}}},
  author = {Eagan, James R.},
  year = {2017},
  doi = {10.1007/978-3-319-67687-6_21},
  abstract = {We introduce the grab `n' drop toolglass, an extension of the toolglass bi-manual interaction technique. It enables users to create and configure their own toolglasses from existing user interfaces that were not designed for toolglasses. Users compose their own toolglass interactions at runtime from an application's user interface elements, bringing interaction closer to the objects of interest in a workspace. Through a proof-of-concept implementation for Mac OS X, we show how grab `n' drop capabilities could be added to existing applications at the toolkit level, without modifying application source code or UI design. Finally, we evaluate the power and flexibility of this approach by applying it to a variety of applications. We further identify limitations and risks associated with this approach and propose changes to existing toolkits to foster such user-reconfigurable interaction.},
  file = {/Users/geoffreylitt/Zotero/storage/9W5Z7WHT/Eagan - 2017 - Grab 'n' Drop User Configurable Toolglasses.pdf}
}

@article{edwards,
  title = {Example {{Centric Programming}}},
  author = {Edwards, Jonathan},
  pages = {8},
  abstract = {Programmers tend to understand programs by thinking of concrete examples. Example Centric Programming seeks to add IDE support for examples throughout the process of programming. Instead of programmers interpreting examples in their head, the examples are written down and the IDE interprets them automatically. Advanced UI techniques are used to present the results closely integrated with the code. Traditionally distinct programming tools (the editor, Read-Eval-Print-Loop, debugger, and test runner) are unified into a single tool that might be called an example-enlightened editor. This is expected to benefit a wide spectrum of programming activities, for both novice and experienced programmers. Some novel methods for testing and development are made possible. In the longer term, example centrism has implications for the design of future programming languages. A prototype has been implemented for Java in Eclipse.},
  file = {/Users/geoffreylitt/Zotero/storage/NQKBYW9D/Edwards - Example Centric Programming.pdf},
  language = {en}
}

@article{edwardsa,
  title = {Evaluating Programming Systems Design},
  author = {Edwards, Jonathan and Kell, Stephen and Petricek, Tomas and Church, Luke},
  pages = {11},
  abstract = {Research on programming systems design needs to consider a wide range of aspects in their full complexity. This includes user interaction, implementation, interoperability but also the sustainability of its ecosystem and wider societal impact. Established methods of evaluation, such as formal proofs or user studies, impose a reductionist view that makes it difficult to see programming systems in their full complexity and, consequently, force researchers to adopt simplistic perspectives.},
  file = {/Users/geoffreylitt/Zotero/storage/76G9FCAD/Edwards et al. - Evaluating programming systems design.pdf},
  language = {en}
}

@misc{elliott2016,
  title = {39 {{Studies About Human Perception}} in 30 {{Minutes}}},
  author = {Elliott, Kennedy},
  year = {2016},
  month = may,
  journal = {Medium}
}

@article{ellis2019,
  title = {Write, {{Execute}}, {{Assess}}: {{Program Synthesis}} with a {{REPL}}},
  shorttitle = {Write, {{Execute}}, {{Assess}}},
  author = {Ellis, Kevin and Nye, Maxwell and Pu, Yewen and Sosa, Felix and Tenenbaum, Josh and {Solar-Lezama}, Armando},
  year = {2019},
  month = jun,
  abstract = {We present a neural program synthesis approach integrating components which write, execute, and assess code to navigate the search space of possible programs. We equip the search process with an interpreter or a read-eval-print-loop (REPL), which immediately executes partially written programs, exposing their semantics. The REPL addresses a basic challenge of program synthesis: tiny changes in syntax can lead to huge changes in semantics. We train a pair of models, a policy that proposes the new piece of code to write, and a value function that assesses the prospects of the code written so-far. At test time we can combine these models with a Sequential Monte Carlo algorithm. We apply our approach to two domains: synthesizing text editing programs and inferring 2D and 3D graphics programs.},
  archivePrefix = {arXiv},
  eprint = {1906.04604},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/32JSLXEC/Ellis et al. - 2019 - Write, Execute, Assess Program Synthesis with a R.pdf;/Users/geoffreylitt/Zotero/storage/9X59CLS3/1906.html},
  journal = {arXiv:1906.04604 [cs]},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Machine Learning,Computer Science - Programming Languages,Computer Science - Software Engineering},
  primaryClass = {cs}
}

@techreport{engelbart1962,
  title = {Augmenting {{Human Intellect}}: {{A Conceptual Framework}}},
  author = {Engelbart, Douglas C.},
  year = {1962},
  address = {{Washington, D.C.}},
  institution = {{Director of Information Sciences, Air Force Office of Scientific Research}},
  abstract = {This is an initial summary report of project taking new and systematic approach to improving the intellectual effectiveness of the individual human being detailed conceptual framework explores the nature of the system composed of the individual and the tools concepts and methods that match his basic capabilities to his problems One of the tools that shows the greatest immediate promise is the computer when it can be harnessed for direct online assistance integrated with new concepts and methods},
  number = {AFOSR-3223},
  type = {Summary {{Report}}}
}

@misc{engelbart1968,
  title = {The {{Mother}} of {{All Demos}}},
  author = {Engelbart, Douglas C.},
  year = {1968},
  month = dec,
  address = {{San Francisco, CA}}
}

@misc{engelbart1986,
  title = {Doug {{Engelbart}}, ``{{The Augmented Knowledge Workshop}}''},
  author = {Engelbart, Douglas},
  year = {1986},
  month = jan,
  abstract = {[Recorded: January 9, 1986] Presentation given by Doug Engelbart (introduced by Charles Irby) at the ACM Conference on the History of Personal Workstations, held at Rickey's Hyatt House in Palo Alto, California, on January 9 and 10, 1986. The conference was sponsored by the Association for Computing Machinery (ACM) and hosted by the Xerox Palo Alto Research Center (PARC). Catalog Number: 102737952},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/The Augmented Knowledge Workshop (engelbart1986).md}
}

@article{engelbart2003,
  title = {Improving {{Our Ability}} to {{Improve}}: {{A Call}} for {{Investment}} in a {{New Future}}},
  author = {Engelbart, Dr Douglas C and Dr, Kaiser},
  year = {2003},
  pages = {14},
  abstract = {In the past fifty years we have seen enormous growth in computing capability \textendash{} computing is everywhere and has impacted nearly everything. In this talk, Dr. Douglas Engelbart, who pioneered much of what we now take for granted as interactive computing, examines the forces that have shaped this growth. He argues that our criteria for investment in innovation are, in fact, short-sighted and focused on the wrong things. He proposes, instead, investment in an improvement infrastructure that can result in sustained, radical innovation capable of changing computing and expanding the kinds of problems that we can address through computing.},
  file = {/Users/geoffreylitt/Zotero/storage/5MCRAG23/Engelbart and Dr - 2003 - Improving Our Ability to Improve A Call for Inves.pdf},
  keywords = {toread},
  language = {en}
}

@article{faaborg,
  title = {Chapter 4 - {{A}} Goal-Oriented {{Web}} Browser},
  author = {Faaborg, Alexander and Lieberman, Henry},
  pages = {20},
  abstract = {Many users are familiar with the interesting but limited functionality of data detector interfaces like Microsoft's Smart Tags and Google's AutoLink. In this chapter we significantly expand the breadth and functionality of this type of user interface through the use of large-scale knowledge bases of semantic information. The result is a Web browser that is able to generate personalized semantic hypertext, providing a goal-oriented browsing experience.},
  file = {/Users/geoffreylitt/Zotero/storage/R8UMLLRD/Faaborg and Lieberman - Chapter 4 - A goal-oriented Web browser.pdf},
  language = {en}
}

@inproceedings{fallman2003,
  title = {Design-Oriented {{Human}}-Computer {{Interaction}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Fallman, Daniel},
  year = {2003},
  pages = {225--232},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/642611.642652},
  abstract = {We argue that HCI has emerged as a design-oriented field of research, directed at large towards innovation, design, and construction of new kinds of information and interaction technology. But the understanding of such an attitude to research in terms of philosophical, theoretical, and methodological underpinnings seems however relatively poor within the field. This paper intends to specifically address what design 'is' and how it is related to HCI. First, three candidate accounts from design theory of what design 'is' are introduced; the conservative, the romantic, and the pragmatic. By examining the role of sketching in design, it is found that the designer becomes involved in a necessary dialogue, from which the design problem and its solution are worked out simultaneously as a closely coupled pair. In conclusion, it is proposed that we need to acknowledge, first, the role of design in HCI conduct, and second, the difference between the knowledge-generating Design-oriented Research and the artifact-generating conduct of Research-oriented Design.},
  isbn = {978-1-58113-630-2},
  keywords = {design,design-orientation,design-oriented research,research-oriented design,sketching,theory},
  series = {{{CHI}} '03}
}

@article{ferdowsifard,
  title = {Small-{{Step Live Programming}} by {{Example}}},
  author = {Ferdowsifard, Kasra and Ordookhanians, Allen and Peleg, Hila and Lerner, Sorin and Polikarpova, Nadia},
  pages = {13},
  abstract = {Live programming is a paradigm in which the programming environment continually displays runtime values. Program synthesis is a technique that can generate programs or program snippets from examples. Previous works that combine the two have taken a holistic approach to the way examples describe the behavior of functions and programs. This paper presents a new programming paradigm called Small-Step Live Programming by Example that lets the user apply Programming by Example locally. When using Small-Step Live Programming by Example, programmers can change the runtime values displayed by the live visualization to generate local program snippets. We implemented this new paradigm in a tool called SNIPPY, and performed a user study on 13 programmers. Our study fnds that Small-Step Live Programming by Example with SNIPPY helps users solve harder problems faster, and that for certain types of queries, users prefer it to searching the web. Additionally, we identify the user-synthesizer gap, in which users' mental models of the tool do not match its ability, and needs to be taken into account in the design of future synthesis tools.},
  file = {/Users/geoffreylitt/Zotero/storage/IL4Y7RNP/Ferdowsifard et al. - Small-Step Live Programming by Example.pdf},
  language = {en}
}

@inproceedings{ferdowsifard2020,
  title = {Small-{{Step Live Programming}} by {{Example}}},
  booktitle = {Proceedings of the 33rd {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  author = {Ferdowsifard, Kasra and Ordookhanians, Allen and Peleg, Hila and Lerner, Sorin and Polikarpova, Nadia},
  year = {2020},
  month = oct,
  pages = {614--626},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3379337.3415869},
  abstract = {Live programming is a paradigm in which the programming environment continually displays runtime values. Program synthesis is a technique that can generate programs or program snippets from examples. \textbackslash deltextThis paper presents a new programming paradigm called Synthesis-Aided Live Programming that combines these two prior ideas in a synergistic way. When using Synthesis-Aided Live Programming, programmers can change the runtime values displayed by the live \textbackslash addtextPrevious works that combine the two have taken a holistic approach to the way examples describe the behavior of functions and programs. This paper presents a new programming paradigm called Small-Step Live Programming by Example that lets the user apply Programming by Example locally. When using Small-Step Live Programming by Example, programmers can change the runtime values displayed by the live visualization to generate local program snippets. \% Live programming and program \% synthesis work perfectly together because the live programming environment \% reifies values, which makes it easy for programmers to provide the examples \% needed by the synthesizer. We implemented this new paradigm in a tool called \textbackslash toolname, and performed a user study on \$13\$ programmers. Our study finds that Small-Step Live Programming by Example with \textbackslash toolname helps users solve harder problems faster, and that for certain types of queries, users prefer it to searching the web. Additionally, we identify the \textbackslash usersynthgap, in which users' mental models of the tool do not match its ability, and needs to be taken into account in the design of future synthesis tools.},
  file = {/Users/geoffreylitt/Zotero/storage/EQYRK8E6/Ferdowsifard et al. - 2020 - Small-Step Live Programming by Example.pdf},
  isbn = {978-1-4503-7514-6},
  keywords = {live programming,program synthesis},
  series = {{{UIST}} '20}
}

@article{fielding2000,
  title = {Architectural {{Styles}} and the {{Design}} of {{Network}}-Based {{Software Architectures}}},
  author = {Fielding, Roy Thomas},
  year = {2000},
  pages = {180},
  file = {/Users/geoffreylitt/Zotero/storage/KVXZAYWW/Fielding - 2000 - in Information and Computer Science.pdf},
  language = {en}
}

@article{flatt,
  title = {Scribble: {{Closing}} the {{Book}} on {{Ad Hoc Documentation Tools}}},
  author = {Flatt, Matthew and Barzilay, Eli and Findler, Robert Bruce},
  pages = {12},
  abstract = {Scribble is a system for writing library documentation, user guides, and tutorials. It builds on PLT Scheme's technology for language extension, and at its heart is a new approach to connecting prose references with library bindings. Besides the base system, we have built Scribble libraries for JavaDoc-style API documentation, literate programming, and conference papers. We have used Scribble to produce thousands of pages of documentation for PLT Scheme; the new documentation is more complete, more accessible, and better organized, thanks in large part to Scribble's flexibility and the ease with which we cross-reference information across levels. This paper reports on the use of Scribble and on its design as both an extension and an extensible part of PLT Scheme.},
  file = {/Users/geoffreylitt/Zotero/storage/I6TKM7Q5/Flatt et al. - Scribble Closing the Book on Ad Hoc Documentation.pdf},
  language = {en}
}

@inproceedings{fogarty2017,
  title = {Code and {{Contribution}} in {{Interactive Systems Research}}},
  author = {Fogarty, James},
  year = {2017},
  abstract = {The scale and complexity of interactive systems research often require care in distinguishing: (1) the code that implements a system, versus (2) the research contribution demonstrated or embodied in a system. This position paper for the CHI 2017 workshop on \#HCI.Tools reflects on this contrast and some common forms of contribution in interactive systems research. We explore several forms of interactive systems contribution based in differentiating: (1) what a system accomplishes, versus (2) how it accomplishes that. We argue some interactive systems should be considered sketches that use code as a medium to explore their research contributions, while others embody their contributions more directly in their code. Finally, we argue the progress and impact of our field requires diverse forms of contribution across interactive systems. INTRODUCTION The scale and complexity of modern interactive systems is daunting along several dimensions. Weiser characterized important aspects of this in a trend from many-to-1 (i.e., many people sharing a single device), to 1-to-1 (i.e., each person with a dedicated device), to 1-to-many (i.e., each person having many devices), to many-to-many (i.e., many people connected through many devices) [14]. As technology enters later stages of this trend, researchers now explore interactive systems that span multiple devices, require massive volumes of data to enable seemingly simple interactions, or require entire social networks before key aspects of their design can surface. Such barriers to real-world deployment of interactive systems create important challenges for interactive systems research. This reflection focuses primarily on the relationship between code and contribution. Interactive systems research generally contains both, but they are not always well-distinguished. Prior discussions include consideration of the limitations of usability testing [6], examination of common pitfalls in evaluating interactive systems [11], and discussion of technical HCI research as an activity of invention that contrasts with activities of discovery [8]. Additional discussion considers how these challenges manifest or can be magnified in social computing systems [1], with their corresponding need for a critical mass of participation [7]. Our reflection is intended to complement existing discussions without contradiction. This position paper first considers the case where code is closely linked to contribution. It then explores cases where the link is less direct. Consistent with the workshop's proposal to explore conceptual roles for toolkits in HCI research, we examine several forms of interactive systems contribution based in a differentiation of: (1) what a system accomplishes, versus (2) how it accomplishes that. We conclude with brief comments on our prior interactive systems research as a background for participation in the \#HCI.Tools workshop. WHEN CODE IS THE CONTRIBUTION Some interactive systems research contributions are directly manifested in code. Although these are a minority, they are important for both: (1) their own research value and impact, and (2) the contrast they can provide for other styles of research. A well-known example is the \$1 Recognizer, a template-based unistroke gesture recognizer implemented in approximately 100 lines of code [15]. The paper has been widely cited, both in applications that use the recognizer and in later extensions of the underlying recognition technique. A project website also hosts community implementations of the recognizer in multiple programming languages. The contribution and impact of this research thus directly results from solving a technical challenge in code that people can easily adopt and adapt in their applications and contexts. Replication, Validation, and Extension Discussions of replication within the CHI community often focus on experimental replication, which remains relevant in our current context. For example, the \$1 Recognizer's project website includes data to replicate its performance experiments. But contributions associated with code also provide opportunity for stronger validation: each future use of that code in a new application, or in a context beyond the original research, validates the underlying research contribution. This validation is riskier and therefore stronger than simply re-executing the original data analysis or replicating the prior experiment. Figures 1 and 2 illustrate this using a simple visual language we develop in figures throughout this paper. In Figure 1, we distill the contribution of the \$1 Recognizer down to a circle. The circle is filled (i.e., purple) to indicate that contribution is novel. In contrast, we will use empty circles (i.e., white) to illustrate components of a system that are not themselves novel (e.g., replicate a prior result, otherwise already known). Figure 2 illustrates this in a research progression based on the \$1 Recognizer. This progression begins with Protractor, a recognizer informed by techniques in the \$1 Recognizer [9]. Protractor is then used in implementing Gesture Script, a novel tool for interactively authoring compound gestures [10]. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for third-party components of this work must be honored. For all other uses, contact the Owner/Author. Copyright is held by the owner/author(s). Presented at the CHI 2017 Workshop on \#HCI.Tools: Strategies and Best Practices for Designing, Evaluating, and Sharing Technical HCI Toolkits.},
  file = {/Users/geoffreylitt/Zotero/storage/MHDZ42SV/Fogarty - 2017 - Code and Contribution in Interactive Systems Resea.pdf},
  keywords = {meta-research}
}

@article{foster,
  title = {{{BIDIRECTIONAL PROGRAMMING LANGUAGES}}},
  author = {Foster, John Nathan},
  pages = {211},
  abstract = {The need to edit data through a view arises in a host of applications across many different areas of computing. Unfortunately, few existing systems provide support for updatable views. In practice, when they are needed, updatable views are usually implemented using two separate programs: one to compute the view from the source and another to handle updates. This rudimentary design is tedious for programmers, dif cult to reason about, and a nightmare to maintain.},
  file = {/Users/geoffreylitt/Zotero/storage/6XMTDH9Z/Foster - BIDIRECTIONAL PROGRAMMING LANGUAGES.pdf},
  language = {en}
}

@article{foster2007,
  title = {Combinators for Bidirectional Tree Transformations: {{A}} Linguistic Approach to the View-Update Problem},
  shorttitle = {Combinators for Bidirectional Tree Transformations},
  author = {Foster, J. Nathan and Greenwald, Michael B. and Moore, Jonathan T. and Pierce, Benjamin C. and Schmitt, Alan},
  year = {2007},
  month = may,
  volume = {29},
  pages = {17},
  issn = {0164-0925, 1558-4593},
  doi = {10.1145/1232420.1232424},
  file = {/Users/geoffreylitt/Zotero/storage/N8278PUU/Foster et al. - 2007 - Combinators for bidirectional tree transformations.pdf},
  journal = {ACM Transactions on Programming Languages and Systems},
  language = {en},
  number = {3}
}

@article{foster2007a,
  title = {Exploiting Schemas in Data Synchronization},
  author = {Foster, J. Nathan and Greenwald, Michael B. and Kirkegaard, Christian and Pierce, Benjamin C. and Schmitt, Alan},
  year = {2007},
  month = jun,
  volume = {73},
  pages = {669--689},
  issn = {00220000},
  doi = {10.1016/j.jcss.2006.10.024},
  abstract = {Increased reliance on optimistic data replication has led to burgeoning interest in tools and frameworks for synchronizing disconnected updates to replicated data. But good data synchronizers are challenging both to specify and to build.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/foster2007a.md;/Users/geoffreylitt/Zotero/storage/2VZ42CAD/Foster et al. - 2007 - Exploiting schemas in data synchronization.pdf},
  journal = {Journal of Computer and System Sciences},
  language = {en},
  number = {4}
}

@incollection{foster2012,
  title = {Three {{Complementary Approaches}} to {{Bidirectional Programming}}},
  booktitle = {Generic and {{Indexed Programming}}},
  author = {Foster, Nate and Matsuda, Kazutaka and Voigtl{\"a}nder, Janis},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Gibbons, Jeremy},
  year = {2012},
  volume = {7470},
  pages = {1--46},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-32202-0_1},
  abstract = {This paper surveys three distinct approaches to bidirectional programming. The first approach, syntactic bidirectionalization, takes a program describing the forward transformation as input and calculates a well-behaved reverse transformation. The second approach, semantic bidirectionalization, is similar, but takes the forward transformation itself as input rather than a program describing it. It requires the transformation to be a polymorphic function and uses parametricity and free theorems in the proof of well-behavedness. The third approach, based on bidirectional combinators, focuses on the use of types to ensure wellbehavedness and special constructs for dealing with alignment problems. In presenting these approaches, we pay particular attention to use of complements, which are structures that represent the information discarded by the transformation in the forward direction.},
  file = {/Users/geoffreylitt/Zotero/storage/JAUPHB6S/Foster et al. - 2012 - Three Complementary Approaches to Bidirectional Pr.pdf},
  isbn = {978-3-642-32201-3 978-3-642-32202-0},
  language = {en}
}

@article{fostera,
  title = {A {{Logic Your Typechecker Can Count On}}:},
  author = {Foster, J Nathan and Pierce, Benjamin C and Schmitt, Alan},
  pages = {11},
  abstract = {Type systems featuring counting constraints are often studied, but seldom implemented. We describe an efficient implementation of a type system for unordered, edge-labeled trees based on Presburger arithmetic constraints. We begin with a type system for unordered trees and give a compilation into counting automata. We then describe an optimized implementation that provides the fundamental operations of membership and emptiness testing. Although each operation has worst-case exponential complexity, we show how to achieve reasonable performance in practice using a combination of techniques, including syntactic translations, lazy automata unfolding, hash-consing, memoization, and incremental tree processing implemented using partial evaluation. These techniques avoid constructing and examining large structures in many cases and amortize the costs of expensive operations across many computations. To demonstrate the effectiveness of these optimizations, we present experimental data from executions on realistically sized examples drawn from the Harmony data synchronizer.},
  file = {/Users/geoffreylitt/Zotero/storage/ULKSXVPT/Foster et al. - A Logic Your Typechecker Can Count On.pdf},
  language = {en}
}

@article{fowler2020,
  title = {Model-{{View}}-{{Update}}-{{Communicate}}: {{Session Types}} Meet the {{Elm Architecture}}},
  shorttitle = {Model-{{View}}-{{Update}}-{{Communicate}}},
  author = {Fowler, Simon},
  year = {2020},
  month = jan,
  abstract = {Session types are a type discipline for communication channel endpoints which allow conformance to protocols to be checked statically. Safely implementing session types requires linearity, usually in the form of a linear type system. Unfortunately, linear typing is difficult to integrate with graphical user interfaces (GUIs), and to date most programs using session types are command line applications. In this paper, we propose the first principled integration of session typing and GUI development by building upon the Model-View-Update (MVU) architecture, pioneered by the Elm programming language. We introduce \$\textbackslash lambda\_\{\textbackslash textsf\{MVU\}\}\$, the first formal model of the MVU architecture, and prove it sound. By extending \$\textbackslash lambda\_\{\textbackslash textsf\{MVU\}\}\$ with \textbackslash emph\{commands\} as found in Elm, along with \textbackslash emph\{linearity\} and \textbackslash emph\{model transitions\}, we show the first formal integration of session typing and GUI programming. We implement our approach in the Links web programming language, and show examples including a two-factor authentication workflow and multi-room chat server.},
  archivePrefix = {arXiv},
  eprint = {1910.11108},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/689LC7JQ/Fowler - 2020 - Model-View-Update-Communicate Session Types meet .pdf;/Users/geoffreylitt/Zotero/storage/NFXV2J5L/1910.html},
  journal = {arXiv:1910.11108 [cs]},
  keywords = {Computer Science - Programming Languages},
  primaryClass = {cs}
}

@article{fox,
  title = {Towards a {{Dynamic Multiscale Personalized Information Space}}},
  author = {Fox, Amy and Guo, Philip and Klokmose, Clemens Nylandsted and Xia, Haijun and Hollan, James D},
  pages = {21},
  abstract = {The historical moment when a person worked in front of a single computer has passed. Computers are now ubiquitous and embedded in virtually every new device and system, ranging from the omnipresent cellphone to the complex web of sociotechnical systems that envelop most every sphere of personal and professional life. They connect our activities to ever-expanding information resources with previously unimaginable computational power. Yet with all the increases in capacity, speed, and connectivity, information-based activities too often remain difficult, awkward, and frustrating. Even after six decades of design evolution there is little of the naturalness and contextual sensitivity required for convivial interaction with computer-mediated information.},
  file = {/Users/geoffreylitt/Zotero/storage/8Z64K2BY/Fox et al. - Towards a Dynamic Multiscale Personalized Informat.pdf},
  language = {en}
}

@incollection{friedman2006,
  title = {Value {{Sensitive Design}} and {{Information Systems}}},
  booktitle = {Human-{{Computer Interaction}} and {{Management Information Systems}}: {{Foundations}}},
  author = {Friedman, Batya and Kahn, Peter H. and Borning, Alan},
  editor = {Zhang, Ping and Galletta, Dennis F.},
  year = {2006},
  month = jul,
  pages = {27},
  publisher = {{Routledge}},
  address = {{New York, NY}},
  language = {en},
  series = {Advances in {{Management}}}
}

@article{frumhoff2015,
  title = {The Climate Responsibilities of Industrial Carbon Producers},
  author = {Frumhoff, Peter C. and Heede, Richard and Oreskes, Naomi},
  year = {2015},
  month = sep,
  volume = {132},
  pages = {157--171},
  issn = {0165-0009, 1573-1480},
  doi = {10.1007/s10584-015-1472-5},
  abstract = {Responsibility for climate change lies at the heart of societal debate over actions to address it. The United Nations Framework Convention on Climate Change established the principle of Bcommon but differentiated responsibilities\^ among nations, suggesting that industrialized nations that had produced the greatest share of historic emissions bore particular responsibility for preventing dangerous interference with the climate system. But climate responsibilities can be attributed in other ways as well. Here, we explore the conceptual territory of responsibility. We consider the distinctive responsibilities of the major investor-owned producers of fossil fuels, assessing the actions these companies took and could have taken to act upon the scientific evidence of climate change. We conclude that major investor-owned fossil energy companies carry significant responsibility for climate change. It is still possible for these companies to effectively contribute to a solution. Significant progress in reducing emissions and limiting climate change could be achieved if companies 1) unequivocally communicate to the public, shareholders, and policymakers the climate risks resulting from continued use of their products, and therefore the need for restrictions on greenhouse gas emissions consistent with the 2 \textdegree C global temperature target; 2) firmly reject contrary claims by industry trade associations and lobbying groups; and, 3) accelerate their transition to the production of low-carbon energy. Evidence from history strongly suggests that a heightened societal focus on their climate responsibilities will be needed to hasten such a transition.},
  file = {/Users/geoffreylitt/Zotero/storage/MKC489EE/Frumhoff et al. - 2015 - The climate responsibilities of industrial carbon .pdf},
  journal = {Climatic Change},
  language = {en},
  number = {2}
}

@inproceedings{gajos2008,
  title = {Improving the Performance of Motor-Impaired Users with Automatically-Generated, Ability-Based Interfaces},
  booktitle = {Proceedings of the {{Twenty}}-{{Sixth Annual Chi Conference}} on {{Human Factors}} in {{Computing Systems}} - {{CHI}} '08},
  author = {Gajos, Krzysztof Z. and Wobbrock, Jacob O. and Weld, Daniel S.},
  year = {2008},
  pages = {1257},
  publisher = {{ACM Press}},
  address = {{Florence, Italy}},
  doi = {10.1145/1357054.1357250},
  abstract = {We evaluate two systems for automatically generating personalized interfaces adapted to the individual motor capabilities of users with motor impairments. The first system, SUPPLE, adapts to users' capabilities indirectly by first using the ARNAULD preference elicitation engine to model a user's preferences regarding how he or she likes the interfaces to be created. The second system, SUPPLE++, models a user's motor abilities directly from a set of one-time motor performance tests. In a study comparing these approaches to baseline interfaces, participants with motor impairments were 26.4\% faster using ability-based user interfaces generated by SUPPLE++. They also made 73\% fewer errors, strongly preferred those interfaces to the manufacturers' defaults, and found them more efficient, easier to use, and much less physically tiring. These findings indicate that rather than requiring some users with motor impairments to adapt themselves to software using separate assistive technologies, software can now adapt itself to the capabilities of its users.},
  isbn = {978-1-60558-011-1},
  language = {en}
}

@article{gelernterdavid,
  title = {Linda in {{Context}}},
  author = {{Gelernter, David}},
  file = {/Users/geoffreylitt/Zotero/storage/JMHV92B4/caprierogelernter.pdf}
}

@unpublished{gelman2013,
  title = {The Garden of Forking Paths: {{Why}} Multiple Comparisons Can Be a Problem, Even When There Is No ``Fishing Expedition'' or ``p-Hacking'' and the Research Hypothesis Was Posited Ahead of Time},
  author = {Gelman, Andrew and Loken, Eric},
  year = {2013},
  abstract = {Researcher degrees of freedom can lead to a multiple comparisons problem, even in settings where researchers perform only a single analysis on their data. The problem is there can be a large number of potential comparisons when the details of data analysis are highly contingent on data, without the researcher having to perform any conscious procedure of fishing or examining multiple p-values. We discuss in the context of several examples of published papers where data-analysis decisions were theoretically-motivated based on previous literature, but where the details of data selection and analysis were not pre-specified and, as a result, were contingent on data.},
  language = {en}
}

@inproceedings{gilbert2009,
  title = {Predicting Tie Strength with Social Media},
  booktitle = {Proceedings of the 27th {{International Conference}} on {{Human Factors}} in {{Computing Systems}} - {{CHI}} 09},
  author = {Gilbert, Eric and Karahalios, Karrie},
  year = {2009},
  pages = {211},
  publisher = {{ACM Press}},
  address = {{Boston, MA, USA}},
  doi = {10.1145/1518701.1518736},
  abstract = {Social media treats all users the same: trusted friend or total stranger, with little or nothing in between. In reality, relationships fall everywhere along this spectrum, a topic social science has investigated for decades under the theme of tie strength. Our work bridges this gap between theory and practice. In this paper, we present a predictive model that maps social media data to tie strength. The model builds on a dataset of over 2,000 social media ties and performs quite well, distinguishing between strong and weak ties with over 85\% accuracy. We complement these quantitative findings with interviews that unpack the relationships we could not predict. The paper concludes by illustrating how modeling tie strength can improve social media design elements, including privacy controls, message routing, friend introductions and information prioritization.},
  isbn = {978-1-60558-246-7},
  language = {en}
}

@phdthesis{gilpin2020,
  title = {Anomaly Detection through Explanations},
  author = {Gilpin, Leilani Hendrina},
  year = {2020},
  abstract = {Under most conditions, complex machines are imperfect. When errors occur, as they inevitably will, these machines need to be able to (1) localize the error and (2) take appropriate action to mitigate the repercussions of a possible failure. My thesis contributes a system architecture that reconciles local errors and inconsistencies amongst parts. I represent a complex machine as a hierarchical model of introspective sub-systems working together towards a common goal. The subsystems communicate in a common symbolic language. In the process of this investigation, I constructed a set of reasonableness monitors to diagnose and explain local errors, and a system-wide architecture, Anomaly Detection through Explanations (ADE), which reconciles system-wide failures. The ADE architecture contributes an explanation synthesizer that produces an argument tree, which in turn can be backtracked and queried for support and counterfactual explanations. I have applied my results to explain incorrect labels in semi-autonomous vehicle data. A series of test simulations show the accuracy and performance of this architecture based on real-world, anomalous driving scenarios. My work has opened up the new area of explanatory anomaly detection, towards a vision in which: complex machines will be articulate by design; dynamic, internal explanations will be part of the design criteria, and system-level explanations will be able to be challenged in an adversarial proceeding.},
  annotation = {Accepted: 2021-01-06T19:35:30Z},
  copyright = {MIT theses may be protected by copyright. Please reuse MIT thesis content according to the MIT Libraries Permissions Policy, which is available through the URL provided.},
  file = {/Users/geoffreylitt/Zotero/storage/7VXM92CE/Gilpin - 2020 - Anomaly detection through explanations.pdf;/Users/geoffreylitt/Zotero/storage/KYY3GTYS/129250.html;/Users/geoffreylitt/Zotero/storage/LILTMTN7/129250.html},
  language = {eng},
  school = {Massachusetts Institute of Technology},
  type = {Thesis}
}

@inproceedings{glassman,
  title = {Interactive {{Program Synthesis}} by {{Augmented Examples}}},
  booktitle = {{{UIST}}},
  author = {Glassman, Elena and Zhang, Tianyi},
  abstract = {Programming-by-example (PBE) has become an increasinglypopular component in software development tools, human-robot interaction, and end-user programming. A long-standingchallenge in PBE is the inherent ambiguity in user-providedexamples.  This paper presents an interaction model to dis-ambiguate user intent and reduce the cognitive load of un-derstanding and validating synthesized programs. Our modelprovides two types of augmentations to user-given examples:1)semantic augmentationwhere a user can specify how differ-ent aspects of an example should be treated by a synthesizervia light-weight annotations, and 2)data augmentationwherethe synthesizer generates additional examples to help the userunderstand and validate synthesized programs.   We implement and demonstrate this interaction model in the domain ofregular expressions, which is a popular mechanism for textprocessing and data wrangling and is often considered hard tomaster even for experienced programmers. A within-subjectsuser study with twelve participants shows that, compared withonly inspecting and annotating synthesized programs, inter-acting with augmented examples significantly increases thesuccess rate of finishing a programming task with less timeand increases users' confidence of synthesized programs.},
  file = {/Users/geoffreylitt/Zotero/storage/RAEQPC9V/Interactive Program Synthesis by Augmented Examples.pdf},
  keywords = {program-synthesis,toread}
}

@article{goldsmith,
  title = {Relational {{Queries Over Program Traces}}},
  author = {Goldsmith, Simon and O'Callahan, Robert and Aiken, Alex},
  pages = {18},
  abstract = {Instrumenting programs with code to monitor runtime behavior is a common technique for profiling and debugging. In practice, instrumentation is either inserted manually by programmers, or automatically by specialized tools that monitor particular properties. We propose Program Trace Query Language (PTQL), a language based on relational queries over program traces, in which programmers can write expressive, declarative queries about program behavior. We also describe our compiler, PARTIQLE. Given a PTQL query and a Java program, PARTIQLE instruments the program to execute the query on-line. We apply several PTQL queries to a set of benchmark programs, including the Apache Tomcat Web server. Our queries reveal significant performance bugs in the jack SpecJVM98 benchmark, in Tomcat, and in the IBM Java class library, as well as some correct though uncomfortably subtle code in the Xerces XML parser. We present performance measurements demonstrating that our prototype system has usable performance.},
  file = {/Users/geoffreylitt/Zotero/storage/UEJJS5IP/Goldsmith et al. - Relational Queries Over Program Traces.pdf},
  language = {en}
}

@article{gould1985,
  title = {Designing for {{Usability}}: {{Key Principles}} and {{What Designers Think}}},
  shorttitle = {Designing for {{Usability}}},
  author = {Gould, John D. and Lewis, Clayton},
  year = {1985},
  month = mar,
  volume = {28},
  pages = {300--311},
  issn = {0001-0782},
  doi = {10.1145/3166.3170},
  abstract = {This article is both theoretical and empirical. Theoretically, it describes three principles of system design which we believe must be followed to produce a useful and easy to use computer system. These principles are: early and continual focus on users; empirical measurement of usage; and iterative design whereby the system (simulated, prototype, and real) is modified, tested, modified again, tested again, and the cycle is repeated again and again. This approach is contrasted to other principled design approaches, for example, get it right the first time, reliance on design guidelines. Empirically, the article presents data which show that our design principles are not always intuitive to designers; identifies the arguments which designers often offer for not using these principles\textemdash and answers them; and provides an example in which our principles have been used successfully.},
  journal = {Commun. ACM},
  number = {3}
}

@article{greenberg,
  title = {The {{Dynamic Practice}} and {{Static Theory}} of {{Gradual Typing}}},
  author = {Greenberg, Michael},
  pages = {20},
  abstract = {We can tease apart the research on gradual types into two `lineages': a pragmatic, implementationoriented dynamic-first lineage and a formal, type-theoretic, static-first lineage. The dynamic-first lineage's focus is on taming particular idioms\textemdash `pre-existing conditions' in untyped programming languages. The static-first lineage's focus is on interoperation and individual type system features, rather than the collection of features found in any particular language. Both appear in programming languages research under the name ``gradual typing'', and they are in active conversation with each other.},
  file = {/Users/geoffreylitt/Zotero/storage/3ATN95TK/Greenberg - The Dynamic Practice and Static Theory of Gradual .pdf},
  language = {en}
}

@inproceedings{greenberg2008,
  title = {Usability Evaluation Considered Harmful (Some of the Time)},
  booktitle = {Proceeding of the Twenty-Sixth Annual {{CHI}} Conference on {{Human}} Factors in Computing Systems  - {{CHI}} '08},
  author = {Greenberg, Saul and Buxton, Bill},
  year = {2008},
  pages = {111},
  publisher = {{ACM Press}},
  address = {{Florence, Italy}},
  doi = {10.1145/1357054.1357074},
  abstract = {Current practice in Human Computer Interaction as encouraged by educational institutes, academic review processes, and institutions with usability groups advocate usability evaluation as a critical part of every design process. This is for good reason: usability evaluation has a significant role to play when conditions warrant it. Yet evaluation can be ineffective and even harmful if naively done `by rule' rather than `by thought'. If done during early stage design, it can mute creative ideas that do not conform to current interface norms. If done to test radical innovations, the many interface issues that would likely arise from an immature technology can quash what could have been an inspired vision. If done to validate an academic prototype, it may incorrectly suggest a design's scientific worthiness rather than offer a meaningful critique of how it would be adopted and used in everyday practice. If done without regard to how cultures adopt technology over time, then today's reluctant reactions by users will forestall tomorrow's eager acceptance. The choice of evaluation methodology \textendash{} if any \textendash{} must arise from and be appropriate for the actual problem or research question under consideration.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/Usability Evaluation Considered Harmful (greenberg2008).md;/Users/geoffreylitt/Zotero/storage/SVUKW5D3/SVUKW5D3.pdf},
  isbn = {978-1-60558-011-1},
  keywords = {study-design},
  language = {en}
}

@article{greenberg2020,
  title = {Executable Formal Semantics for the {{POSIX}} Shell},
  author = {Greenberg, Michael and Blatt, Austin J.},
  year = {2020},
  month = jan,
  volume = {4},
  pages = {1--30},
  issn = {2475-1421, 2475-1421},
  doi = {10.1145/3371111},
  abstract = {CCS Concepts: \textbullet{} Software and its engineering \textrightarrow{} Scripting languages; Command and control languages; Language features; Semantics; \textbullet{} General and reference \textrightarrow{} Design; \textbullet{} Human-centered computing \textrightarrow{} Command line interfaces.},
  file = {/Users/geoffreylitt/Zotero/storage/CGSTDSDP/Greenberg and Blatt - 2020 - Executable formal semantics for the POSIX shell.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  number = {POPL}
}

@article{greenberga,
  title = {The {{POSIX}} Shell Is an Interactive {{DSL}} for Concurrency},
  author = {Greenberg, Michael},
  pages = {3},
  file = {/Users/geoffreylitt/Zotero/storage/PRUNL2XJ/Greenberg - The POSIX shell is an interactive DSL for concurre.pdf},
  language = {en}
}

@article{greenbergb,
  title = {Declarative, Composable Views},
  author = {Greenberg, Michael},
  pages = {11},
  abstract = {Widespread use of HTML [W3Cb], JavaScript, and the DOM [W3Ca] has led to sub-optimal `best practices'. We apply the bidirectional programming formalism of lenses [FGM+05] to define user interfaces in JavaScript that are declarative, composable, clear, and concise \textemdash{} in half the code. Additionally, we define two new bidirectional combinator over lists, order and list map.},
  file = {/Users/geoffreylitt/Zotero/storage/ZLIXJB8C/Greenberg - Declarative, composable views.pdf},
  language = {en}
}

@article{gulwani,
  title = {Programming by {{Example}} (and Its Applications in {{Data Wrangling}})},
  author = {Gulwani, Sumit},
  pages = {22},
  abstract = {Programming by Examples (PBE) has the potential to revolutionize enduser programming by enabling end users, most of whom are non-programmers, to create scripts for automating repetitive tasks. PBE involves synthesizing intended programs in an underlying domain-specific language (DSL) from example based specifications (Ispec). We formalize the notion of Ispec and discuss some principles behind designing useful DSLs for synthesis.},
  file = {/Users/geoffreylitt/Zotero/storage/IMYCHZHC/Gulwani - (and its applications in Data Wrangling).pdf},
  language = {en}
}

@article{gulwani2017,
  title = {Program Synthesis},
  author = {Gulwani, Sumit and Polozov, Oleksandr and Singh, Rishabh},
  year = {2017},
  publisher = {{Now Publishers}},
  address = {{Hanover, MA Delft}},
  file = {/Users/geoffreylitt/Zotero/storage/X8ANEF3Q/Gulwani et al. - 2017 - Program synthesis.pdf},
  isbn = {9781680832921},
  journal = {Foundations and trends in programming languages},
  language = {en},
  number = {4.2017, 1-2},
  series = {Foundations and Trends in Programming Languages}
}

@inproceedings{guo2013,
  title = {Online Python Tutor: Embeddable Web-Based Program Visualization for Cs Education},
  shorttitle = {Online Python Tutor},
  booktitle = {Proceeding of the 44th {{ACM}} Technical Symposium on {{Computer}} Science Education},
  author = {Guo, Philip J.},
  year = {2013},
  month = mar,
  pages = {579--584},
  publisher = {{Association for Computing Machinery}},
  address = {{Denver, Colorado, USA}},
  doi = {10.1145/2445196.2445368},
  abstract = {This paper presents Online Python Tutor, a web-based program visualization tool for Python, which is becoming a popular language for teaching introductory CS courses. Using this tool, teachers and students can write Python programs directly in the web browser (without installing any plugins), step forwards and backwards through execution to view the run-time state of data structures, and share their program visualizations on the web. In the past three years, over 200,000 people have used Online Python Tutor to visualize their programs. In addition, instructors in a dozen universities such as UC Berkeley, MIT, the University of Washington, and the University of Waterloo have used it in their CS1 courses. Finally, Online Python Tutor visualizations have been embedded within three web-based digital Python textbook projects, which collectively attract around 16,000 viewers per month and are being used in at least 25 universities. Online Python Tutor is free and open source software, available at pythontutor.com.},
  file = {/Users/geoffreylitt/Zotero/storage/N52WHB3D/Guo - 2013 - Online python tutor embeddable web-based program .pdf},
  isbn = {978-1-4503-1868-6},
  keywords = {CS1,program visualization,python},
  series = {{{SIGCSE}} '13}
}

@incollection{haines2010,
  title = {A World Wider than the {{Web}}},
  booktitle = {No {{Code Required}}},
  author = {Haines, Will and Gervasio, Melinda and Blythe, Jim and Lerman, Kristina and Spaulding, Aaron},
  year = {2010},
  pages = {213--231},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00011-0},
  abstract = {As Web services become more diverse and powerful, end user programming (EUP) systems for the Web become increasingly compelling. However, many user workflows do not exist exclusively online. To support these workflows completely, EUP systems must allow the user to program across multiple applications in different domains. To this end, we created Integrated Task Learning (ITL), a system that integrates several learning components to learn end user workflows as user-editable executable procedures. In this chapter, we illustrate a motivating cross-domain task and describe the various learning techniques that support learning such a task with ITL. These techniques include dataflow reasoning to learn procedures from demonstration, symbolic analysis and compositional search to support procedure editing, and machine learning to infer new semantic types. Then, we describe the central engineering concept that ITL uses to facilitate cross-domain learning: pluggable domain models, which are independently generated type and action models over different application domains that can be combined to support cross-domain procedure learning. Finally, we briefly discuss some open questions that cross-domain EUP systems will need to address in the future.},
  file = {/Users/geoffreylitt/Zotero/storage/CVIKVD3V/Haines et al. - 2010 - A world wider than the Web.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@inproceedings{hall2017,
  title = {Infra: Structure All the Way down: Structured Data as a Visual Programming Language},
  shorttitle = {Infra},
  booktitle = {Proceedings of the 2017 {{ACM SIGPLAN International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}} - {{Onward}}! 2017},
  author = {Hall, Christopher and Standley, Trevor and Hollerer, Tobias},
  year = {2017},
  pages = {180--197},
  publisher = {{ACM Press}},
  address = {{Vancouver, BC, Canada}},
  doi = {10.1145/3133850.3133852},
  abstract = {We present Infra, a new baseline medium for representing data. With Infra, arbitrarily-complex structured data can be encoded, viewed, edited, and processed, all while remaining in an efficient non-textual form. It is suitable for the full range of information modalities, from free-form input, to compact schema-conforming structures. With its own equivalent of a text editor and text-field widget, Infra is designed to target the domain currently dominated by flat character strings while simultaneously enabling the expression of sub-structure, inter-reference, dynamic dependencies, abstraction, computation, and context (metadata). Existing metaformats fit neatly into two categories. They are either textual for human readability (such as XML and JSON) or binary for compact serialization (such as Thrift and Protocol Buffers). In contrast, Infra unifies those two paradigms. In order to have the desirable properties of binary formats, Infra has no textual representation. And yet, it is designed to be easily read and authored by end-users.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/hall2017.md;/Users/geoffreylitt/Zotero/storage/LCVWB83T/Hall et al. - 2017 - Infra structure all the way down structured data.pdf},
  isbn = {978-1-4503-5530-8},
  language = {en}
}

@article{hannan1992,
  title = {From Operational Semantics to Abstract Machines},
  author = {Hannan, John and Miller, Dale},
  year = {1992},
  month = dec,
  volume = {2},
  pages = {415--459},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129500001559},
  abstract = {Evaluation System (AES) that captures and abstracts some of this commonality. We assume some familiarity with term rewriting, its terminology and the notion of computation in a rewriting system [HO80]. Recall that a term rewriting system is a pair ({$\Sigma$}, R) such that {$\Sigma$} is a signature and R is a set of directed equations \{li {$\Rightarrow$} ri\}i{$\in$}I with li, ri {$\in$} T{$\Sigma$}(X) and V(ri) {$\subseteq$} V(li). Here, T{$\Sigma$}(X) denotes the set of first-order terms with constants from the signature {$\Sigma$} and free variables from X, and V(t) denotes the set of free variables occurring in t. We restrict our attention to first-order systems, i.e., {$\Sigma$} is a first-order signature, though this is not essential.},
  file = {/Users/geoffreylitt/Zotero/storage/I8I7PZTN/Hannan and Miller - 1992 - From operational semantics to abstract machines.pdf},
  journal = {Mathematical Structures in Computer Science},
  language = {en},
  number = {4}
}

@article{harper,
  title = {John {{C}}. {{Mitchell AT}}\&{{T Bell Laboratories Murray Hill}}, {{NJ}} 07974},
  author = {Harper, Robert},
  pages = {19},
  file = {/Users/geoffreylitt/Zotero/storage/5ZPL7REQ/Harper - John C. Mitchell AT&T Bell Laboratories Murray Hil.pdf},
  language = {en}
}

@article{harrison,
  title = {The {{Three Paradigms}} of {{HCI}}},
  author = {Harrison, Steve},
  pages = {18},
  abstract = {Informal histories of HCI commonly document two major intellectual waves that have formed the field: the first orienting from engineering/human factors with its focus on optimizing man-machine fit, and the second stemming from cognitive science, with an increased emphasis on theory and on what is happening not only in the computer but, simultaneously, in the human mind. In this paper, we document underlying forces that constitute a third wave in HCI and suggest systemic consequences for the CHI community. We provisionally name this the `phenomenological matrix'. In the course of creating technologies such as ubiquitous computing, visualization, affective and educational technology, a variety of approaches are addressing issues that are bad fits to prior paradigms, ranging from embodiment to situated meaning to values and social issues. We demonstrate the underlying unity of these approaches, and document how they suggest the centrality of currently marginal criteria for design, evaluation, appreciation, and developmental methodology in CHI work.},
  file = {/Users/geoffreylitt/Zotero/storage/TAFADZCR/Harrison - The Three Paradigms of HCI.pdf},
  keywords = {HCI,meta},
  language = {en}
}

@incollection{hartmann2010,
  title = {Programming by a Sample},
  booktitle = {No {{Code Required}}},
  author = {Hartmann, Bj{\"o}rn and Wu, Leslie and Collins, Kevin and Klemmer, Scott R.},
  year = {2010},
  pages = {191--211},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00010-9},
  abstract = {Many popular Web sites offer a public API that allows Web developers to access site data and functionality programmatically. The site and its API offer two complementary views of the same underlying functionality. This chapter introduces d.mix, a Web development tool that leverages this site-to-service correspondence to rapidly create Web-service based applications. With d.mix, users browse annotated Web sites and select elements on the page they would like to access programmatically. It then generates code for the underlying Web service calls that yield those elements. This code can be edited, executed, and shared in a wiki-based hosting environment. The application d.mix leverages prexisting Web sites as example sets and supports rapid composition and modification of examples.},
  file = {/Users/geoffreylitt/Zotero/storage/2Y4SNX4C/Hartmann et al. - 2010 - Programming by a sample.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@incollection{hayes2014,
  title = {Knowing by {{Doing}}: {{Action Research}} as an {{Approach}} to {{HCI}}},
  booktitle = {Ways of Knowing in {{HCI}}},
  author = {Hayes, Gillian R.},
  editor = {Olson, Judith S. and Kellogg, Wendy},
  year = {2014},
  pages = {49--68},
  publisher = {{Springer}},
  address = {{New York}},
  isbn = {978-1-4939-0377-1},
  keywords = {Human-computer interaction},
  language = {en},
  lccn = {QA76.9.H85 W39 2014}
}

@article{healey2012,
  title = {Attention and {{Visual Memory}} in {{Visualization}} and {{Computer Graphics}}},
  author = {Healey, Christopher G. and Enns, James T.},
  year = {2012},
  month = jul,
  volume = {18},
  pages = {1170--1188},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2011.127},
  abstract = {A fundamental goal of visualization is to produce images of data that support visual analysis, exploration, and discovery of novel insights. An important consideration during visualization design is the role of human visual perception. How we "see'' details in an image can directly impact a viewer's efficiency and effectiveness. This paper surveys research on attention and visual perception, with a specific focus on results that have direct relevance to visualization and visual analytics. We discuss theories of low-level visual perception, then show how these findings form a foundation for more recent work on visual memory and visual attention. We conclude with a brief overview of how knowledge of visual attention and visual memory is being applied in visualization and graphics. We also discuss how challenges in visualization are motivating research in psychophysics.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  keywords = {attention,Attention,Bars,color,computer graphics,Computer Graphics,data analysis,data visualisation,Data visualization,Feature extraction,human visual perception,Humans,Memory,Models; Theoretical,motion,nonphotorealism,Pattern Recognition; Visual,psychophysics,Psychophysics,Research,texture,visual analysis,visual analytics,visual attention,visual memory,visual perception,Visual perception,Visual Perception,Visualization,visualization design,visualization.},
  number = {7}
}

@incollection{hearst2009,
  title = {Chapter 10: {{Information Visualization}} for {{Search Interfaces}}},
  booktitle = {Search {{User Interfaces}}},
  author = {Hearst, Marti},
  year = {2009},
  publisher = {{Cambridge University Press}},
  address = {{Cambridge, UK}}
}

@incollection{hearst2009a,
  title = {Chapter 11: {{Information Visualization}} for {{Text Analysis}}},
  booktitle = {Search {{User Interfaces}}},
  author = {Hearst, Marti},
  year = {2009},
  publisher = {{Cambridge University Press}},
  address = {{Cambridge, UK}}
}

@article{heede2014,
  title = {Tracing Anthropogenic Carbon Dioxide and Methane Emissions to Fossil Fuel and Cement Producers, 1854\textendash 2010},
  author = {Heede, Richard},
  year = {2014},
  month = jan,
  volume = {122},
  pages = {229--241},
  issn = {0165-0009, 1573-1480},
  doi = {10.1007/s10584-013-0986-y},
  abstract = {This paper presents a quantitative analysis of the historic fossil fuel and cement production records of the 50 leading investor-owned, 31 state-owned, and 9 nation-state producers of oil, natural gas, coal, and cement from as early as 1854 to 2010. This analysis traces emissions totaling 914 GtCO2e\textemdash 63 \% of cumulative worldwide emissions of industrial CO2 and methane between 1751 and 2010\textemdash to the 90 ``carbon major'' entities based on the carbon content of marketed hydrocarbon fuels (subtracting for non-energy uses), process CO2 from cement manufacture, CO2 from flaring, venting, and own fuel use, and fugitive or vented methane. Cumulatively, emissions of 315 GtCO2e have been traced to investor-owned entities, 288 GtCO2e to state-owned enterprises, and 312 GtCO2e to nation-states. Of these emissions, half has been emitted since 1986. The carbon major entities possess fossil fuel reserves that will, if produced and emitted, intensify anthropogenic climate change. The purpose of the analysis is to understand the historic emissions as a factual matter, and to invite consideration of their possible relevance to public policy.},
  file = {/Users/geoffreylitt/Zotero/storage/WSFNTAET/Heede - 2014 - Tracing anthropogenic carbon dioxide and methane e.pdf},
  journal = {Climatic Change},
  language = {en},
  number = {1-2}
}

@article{heer2007,
  title = {Animated {{Transitions}} in {{Statistical Data Graphics}}},
  author = {Heer, Jeffrey and Robertson, George G.},
  year = {2007},
  month = nov,
  volume = {13},
  pages = {1240--1247},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2007.70539},
  abstract = {In this paper we investigate the effectiveness of animated transitions between common statistical data graphics such as bar charts, pie charts, and scatter plots. We extend theoretical models of data graphics to include such transitions, introducing a taxonomy of transition types. We then propose design principles for creating effective transitions and illustrate the application of these principles in DynaVis, a visualization system featuring animated data graphics. Two controlled experiments were conducted to assess the efficacy of various transition types, finding that animated transitions can significantly improve graphical perception.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  keywords = {animated transitions,animation,Animation,bar charts,Collaboration,computer animation,data visualisation,Data visualization,design,Drilling,DynaVis,experiment,graphical perception,Graphics,Guidelines,Information analysis,information visualization,Marketing and sales,pie charts,scatter plots,Scattering,statistical analysis,statistical data graphics,Statistical data graphics,Taxonomy,transitions,visualization system},
  number = {6}
}

@inproceedings{heer2010,
  title = {Crowdsourcing {{Graphical Perception}}: {{Using Mechanical Turk}} to {{Assess Visualization Design}}},
  shorttitle = {Crowdsourcing {{Graphical Perception}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Heer, Jeffrey and Bostock, Michael},
  year = {2010},
  pages = {203--212},
  publisher = {{ACM}},
  address = {{New York, NY}},
  doi = {10.1145/1753326.1753357},
  abstract = {Understanding perception is critical to effective visualization design. With its low cost and scalability, crowdsourcing presents an attractive option for evaluating the large design space of visualizations; however, it first requires validation. In this paper, we assess the viability of Amazon's Mechanical Turk as a platform for graphical perception experiments. We replicate previous studies of spatial encoding and luminance contrast and compare our results. We also conduct new experiments on rectangular area perception (as in treemaps or cartograms) and on chart size and gridline spacing. Our results demonstrate that crowdsourced perception experiments are viable and contribute new insights for visualization design. Lastly, we report cost and performance data from our experiments and distill recommendations for the design of crowdsourced studies.},
  isbn = {978-1-60558-929-9},
  keywords = {crowdsourcing,evaluation,experimentation,graphical perception,information visualization,mechanical turk,user study},
  series = {{{CHI}} '10}
}

@article{heer2012,
  title = {Interactive {{Dynamics}} for {{Visual Analysis}}},
  author = {Heer, Jeffrey and Shneiderman, Ben},
  year = {2012},
  month = apr,
  volume = {55},
  pages = {45},
  issn = {00010782},
  doi = {10.1145/2133806.2133821},
  journal = {Communications of the ACM},
  language = {en},
  number = {4}
}

@inproceedings{hill1992,
  title = {Edit {{Wear}} and {{Read Wear}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Hill, William C. and Hollan, James D. and Wroblewski, Dave and McCandless, Tim},
  year = {1992},
  pages = {3--9},
  publisher = {{ACM}},
  address = {{New York, NY}},
  doi = {10.1145/142750.142751},
  abstract = {We describe two applications that illustrate the idea of computational wear in the domain of document processing. By graphically depicting the history of author and reader interactions with documents, these applications offer otherwise unavailable information to guide work. We discuss how their design accords with a theory of professional work and an informational physics perspective on interface design.},
  isbn = {978-0-89791-513-7},
  keywords = {graphical user interfaces,informational physics,interface mechanisms,professional work,reflective practitioner},
  series = {{{CHI}} '92}
}

@inproceedings{hinckley2010,
  title = {Pen + Touch = New Tools},
  booktitle = {Proceedings of the 23nd {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}} - {{UIST}} '10},
  author = {Hinckley, Ken and Yatani, Koji and Pahud, Michel and Coddington, Nicole and Rodenhouse, Jenny and Wilson, Andy and Benko, Hrvoje and Buxton, Bill},
  year = {2010},
  pages = {27},
  publisher = {{ACM Press}},
  address = {{New York, NY}},
  doi = {10.1145/1866029.1866036},
  abstract = {We describe techniques for direct pen+touch input. We observe people's manual behaviors with physical paper and notebooks. These serve as the foundation for a prototype Microsoft Surface application, centered on note-taking and scrapbooking of materials. Based on our explorations we advocate a division of labor between pen and touch: the pen writes, touch manipulates, and the combination of pen + touch yields new tools. This articulates how our system interprets unimodal pen, unimodal touch, and multimodal pen+touch inputs, respectively. For example, the user can hold a photo and drag off with the pen to create and place a copy; hold a photo and cross it in a freeform path with the pen to slice it in two; or hold selected photos and tap one with the pen to staple them all together. Touch thus unifies object selection with mode switching of the pen, while the muscular tension of holding touch serves as the ``glue'' that phrases together all the inputs into a unitary multimodal gesture. This helps the UI designer to avoid encumbrances such as physical buttons, persistent modes, or widgets that detract from the user's focus on the workspace.},
  isbn = {978-1-4503-0271-5},
  language = {en}
}

@book{hippel2005,
  title = {Democratizing Innovation},
  author = {von Hippel, Eric},
  year = {2005},
  publisher = {{MIT Press}},
  address = {{Cambridge, Mass}},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/hippel2005.md;/Users/geoffreylitt/Zotero/storage/DS58IVSF/Hippel - 2005 - Democratizing innovation.pdf},
  isbn = {978-0-262-00274-5},
  keywords = {Democracy,Diffusion of innovations,Economic aspects,Technological innovations},
  language = {en},
  lccn = {HC79.T4 H558 2005}
}

@inproceedings{hoffswell2018a,
  title = {Augmenting {{Code}} with {{In Situ Visualizations}} to {{Aid Program Understanding}}},
  booktitle = {Proceedings of the 2018 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Hoffswell, Jane and Satyanarayan, Arvind and Heer, Jeffrey},
  year = {2018},
  month = apr,
  pages = {1--12},
  publisher = {{Association for Computing Machinery}},
  address = {{Montreal QC, Canada}},
  doi = {10.1145/3173574.3174106},
  abstract = {Programmers must draw explicit connections between their code and runtime state to properly assess the correctness of their programs. However, debugging tools often decouple the program state from the source code and require explicitly invoked views to bridge the rift between program editing and program understanding. To unobtrusively reveal runtime behavior during both normal execution and debugging, we contribute techniques for visualizing program variables directly within the source code. We describe a design space and placement criteria for embedded visualizations. We evaluate our in situ visualizations in an editor for the Vega visualization grammar. Compared to a baseline development environment, novice Vega users improve their overall task grade by about 2 points when using the in situ visualizations and exhibit significant positive effects on their self-reported speed and accuracy.},
  file = {/Users/geoffreylitt/Zotero/storage/YHWWBVN2/Hoffswell et al. - 2018 - Augmenting Code with In Situ Visualizations to Aid.pdf},
  isbn = {978-1-4503-5620-6},
  keywords = {code augmentation,debugging,program behavior,program understanding,visualization},
  series = {{{CHI}} '18}
}

@article{hofmann2011,
  title = {Symmetric Lenses},
  author = {Hofmann, Martin and Pierce, Benjamin and Wagner, Daniel},
  year = {2011},
  month = jan,
  volume = {46},
  pages = {371--384},
  issn = {0362-1340},
  doi = {10.1145/1925844.1926428},
  abstract = {Lenses--bidirectional transformations between pairs of connected structures--have been extensively studied and are beginning to find their way into industrial practice. However, some aspects of their foundations remain poorly understood. In particular, most previous work has focused on the special case of asymmetric lenses, where one of the structures is taken as primary and the other is thought of as a projection, or view. A few studies have considered symmetric variants, where each structure contains information not present in the other, but these all lack the basic operation of composition. Moreover, while many domain-specific languages based on lenses have been designed, lenses have not been thoroughly explored from an algebraic perspective. We offer two contributions to the theory of lenses. First, we present a new symmetric formulation, based on complements, an old idea from the database literature. This formulation generalizes the familiar structure of asymmetric lenses, and it admits a good notion of composition. Second, we explore the algebraic structure of the space of symmetric lenses. We present generalizations of a number of known constructions on asymmetric lenses and settle some longstanding questions about their properties---in particular, we prove the existence of (symmetric monoidal) tensor products and sums and the non-existence of full categorical products or sums in the category of symmetric lenses. We then show how the methods of universal algebra can be applied to build iterator lenses for structured data such as lists and trees, yielding lenses for operations like mapping, filtering, and concatenation from first principles. Finally, we investigate an even more general technique for constructing mapping combinators, based on the theory of containers.},
  file = {/Users/geoffreylitt/Zotero/storage/FQNKPT6L/Hofmann et al. - 2011 - Symmetric lenses.pdf},
  journal = {ACM SIGPLAN Notices},
  keywords = {algebra,category theory,lens,view-update},
  number = {1}
}

@inproceedings{hofmann2012,
  title = {Edit Lenses},
  booktitle = {Proceedings of the 39th Annual {{ACM SIGPLAN}}-{{SIGACT}} Symposium on {{Principles}} of Programming Languages - {{POPL}} '12},
  author = {Hofmann, Martin and Pierce, Benjamin and Wagner, Daniel},
  year = {2012},
  pages = {495},
  publisher = {{ACM Press}},
  address = {{Philadelphia, PA, USA}},
  doi = {10.1145/2103656.2103715},
  abstract = {A lens is a bidirectional transformation between a pair of connected data structures, capable of translating an edit on one structure into an appropriate edit on the other. Many varieties of lenses have been studied, but none, to date, has offered a satisfactory treatment of how edits are represented. Many foundational accounts [5, 7] only consider edits of the form ``overwrite the whole structure,'' leading to poor behavior in many situations by failing to track the associations between corresponding parts of the structures when elements are inserted and deleted in ordered lists, for example. Other theories of lenses do maintain these associations, either by annotating the structures themselves with change information [6, 15] or using auxiliary data structures [2, 4], but every extant theory assumes that the entire original source structure is part of the information passed to the lens. We offer a general theory of edit lenses, which work with descriptions of changes to structures, rather than with the structures themselves. We identify a simple notion of ``editable structure''\textemdash a set of states plus a monoid of edits with a partial monoid action on the states\textemdash and construct a semantic space of lenses between such structures, with natural laws governing their behavior. We show how a range of constructions from earlier papers on ``statebased'' lenses can be carried out in this space, including composition, products, sums, list operations, etc. Further, we show how to construct edit lenses for arbitrary containers in the sense of Abbott, Altenkirch, and Ghani [1]. Finally, we show that edit lenses refine a wellknown formulation of state-based lenses [7], in the sense that every state-based lens gives rise to an edit lens over structures with a simple overwrite-only edit language, and conversely every edit lens on such structures gives rise to a state-based lens.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/Edit Lenses (hofmann2012).md;/Users/geoffreylitt/Zotero/storage/LWVRA7FP/LWVRA7FP.pdf},
  isbn = {978-1-4503-1083-3},
  language = {en}
}

@inproceedings{hogue2005,
  title = {Thresher: Automating the Unwrapping of Semantic Content from the {{World Wide Web}}},
  shorttitle = {Thresher},
  booktitle = {Proceedings of the 14th International Conference on {{World Wide Web}}  - {{WWW}} '05},
  author = {Hogue, Andrew and Karger, David},
  year = {2005},
  pages = {86},
  publisher = {{ACM Press}},
  address = {{Chiba, Japan}},
  doi = {10.1145/1060745.1060762},
  abstract = {We describe Thresher, a system that lets non-technical users teach their browsers how to extract semantic web content from HTML documents on the World Wide Web. Users specify examples of semantic content by highlighting them in a web browser and describing their meaning. We then use the tree edit distance between the DOM subtrees of these examples to create a general pattern, or wrapper, for the content, and allow the user to bind RDF classes and predicates to the nodes of these wrappers. By overlaying matches to these patterns on standard documents inside the Haystack semantic web browser, we enable a rich semantic interaction with existing web pages, ``unwrapping'' semantic data buried in the pages' HTML. By allowing end-users to create, modify, and utilize their own patterns, we hope to speed adoption and use of the Semantic Web and its applications.},
  file = {/Users/geoffreylitt/Zotero/storage/SGZ4PK28/Hogue and Karger - 2005 - Thresher automating the unwrapping of semantic co.pdf},
  isbn = {978-1-59593-046-0},
  language = {en}
}

@book{holbert2020,
  title = {Designing {{Constructionist Futures}}: {{The Art}}, {{Theory}}, and {{Practice}} of {{Learning Designs}}},
  shorttitle = {Designing {{Constructionist Futures}}},
  editor = {Holbert, Nathan and Berland, Matthew and Kafai, Yasmin B.},
  year = {2020},
  month = oct,
  publisher = {{The MIT Press}},
  address = {{Cambridge, Massachusetts}},
  abstract = {A diverse group of scholars redefine constructionism\textemdash introduced by Seymour Papert in 1980\textemdash in light of new technologies and theories.Constructionism, first introduced by Seymour Papert in 1980, is a framework for learning to understand something by making an artifact for and with other people. A core goal of constructionists is to respect learners as creators, to enable them to engage in making meaning for themselves through construction, and to do this by democratizing access to the world's most creative and powerful tools. In this volume, an international and diverse group of scholars examine, reconstruct, and evolve the constructionist paradigm in light of new technologies and theories. Taken together, their contributions show that constructionism has advanced in educational research and practice\textemdash and also that, in turn, researchers and practitioners can learn from constructionism how to foster learning in ways that respect learners' creativity and communities.The contributors examine how constructionist design can function within contexts ranging from school and home to virtual spaces; explore ways to support learners who have been under-resourced, overlooked, or oppressed; discuss learning by collaboration; and consider the implications of learning as a creative process of construction, exploring ways to support creative enterprises within the constraints of formal classrooms. Finally, leading visionaries imagine where constructionism, design, and research will go nextContributorsKonstantin Aal, Dor Abrahamson, Edith K. Ackermann, Michael Ahmadi, Emma Anderson, Edward Baafi, Stephanie Benson, Laura Benton, Matthew Berland, Marina Umaschi Bers, Paulo Blikstein, Bryan McKinley Jones Brayboy, Karen Brennan, Leah Buechley, Angela Calabrese Barton, Teresa Casort, David Cavallo, Kiera Chase, Alison Clark-Wilson, Sequoia L. Dance, Joshua A. Danish, Sayamindu Dasgupta, Michael Eisenberg, Noel Enyedy, Deborah A. Fields, Andrea Forte, Gayithri Jayathirtha, Brian Gravel, Sara M. Grimes, Idit Harel, Erica R. Halverson, Nathan Holbert, Celia Hoyles, Raquel Jimenez, Yasmin B. Kafai, Ivan Kalas, Anna Keune, Susan Klimczak, Eric Klopfer, Maximilian Kr\"uger, Chronis Kynigos, Tim Kubik, Breanne K. Litts, Benjamin Mako Hill, Amon Millner, Andr\'es Monroy-Hern\'andez, Richard Noss, Seymour Papert, Kylie Peppler, Judy Perry, Mitchel Resnick, Rebecca Reynolds, Ricarose Roque, Piers Saunders, Kristin A. Searle, Kimberly M. Sheridan, Arnan Sipitakiat, R. Benjamin Shapiro, Gary S. Stager, Gunnar Stevens, Vanessa Svihla, Edna Tan, Orkan Telhan, Naomi Thompson, Nalin Tutiyaphuengprasert, Anne Weibert, Michelle Hoda Wilkerson, Volker Wulf, Uri Wilensky, Jianwei Zhang},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/Designing Constructionist Futures (holbert2020).md},
  isbn = {978-0-262-53984-5},
  language = {English}
}

@inproceedings{hollan1992a,
  title = {Beyond Being There},
  booktitle = {Proceedings of the {{SIGCHI}} Conference on {{Human}} Factors in Computing Systems  - {{CHI}} '92},
  author = {Hollan, Jim and Stornetta, Scott},
  year = {1992},
  pages = {119--125},
  publisher = {{ACM Press}},
  address = {{Monterey, California, United States}},
  doi = {10.1145/142750.142769},
  abstract = {A belief in the efficacy of imitating face-to-face communication is an unquestioned presupposition of most current work on supporting communications in electronic media. In this paper we highlight problems with this presupposition and present an alternative proposal for grounding and motivating research. and development that frames the issue in terms of needs, media, and mechanisms. To help elaborate the proposal we sketch a series of example projects and respond to potential criticisms.},
  file = {/Users/geoffreylitt/Zotero/storage/HP85ZCFX/Hollan and Stornetta - 1992 - Beyond being there.pdf},
  isbn = {978-0-89791-513-7},
  language = {en}
}

@article{holten2006,
  title = {Hierarchical {{Edge Bundles}}: {{Visualization}} of {{Adjacency Relations}} in {{Hierarchical Data}}},
  shorttitle = {Hierarchical {{Edge Bundles}}},
  author = {Holten, D.},
  year = {2006},
  month = sep,
  volume = {12},
  pages = {741--748},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2006.147},
  abstract = {A compound graph is a frequently encountered type of data set. Relations are given between items, and a hierarchy is defined on the items as well. We present a new method for visualizing such compound graphs. Our approach is based on visually bundling the adjacency edges, i.e., non-hierarchical edges, together. We realize this as follows. We assume that the hierarchy is shown via a standard tree visualization method. Next, we bend each adjacency edge, modeled as a B-spline curve, toward the polyline defined by the path via the inclusion edges from one node to another. This hierarchical bundling reduces visual clutter and also visualizes implicit adjacency edges between parent nodes that are the result of explicit adjacency edges between their respective child nodes. Furthermore, hierarchical edge bundling is a generic method which can be used in conjunction with existing tree visualization techniques. We illustrate our technique by providing example visualizations and discuss the results based on an informal evaluation provided by potential users of such visualizations.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  language = {en},
  number = {5}
}

@inproceedings{horvitz1998,
  title = {The {{Lumi\`ere Project}}: {{Bayesian User Modeling}} for {{Inferring}} the {{Goals}} and {{Needs}} of {{Software Users}}},
  shorttitle = {The {{Lumi\`eRe Project}}},
  booktitle = {Proceedings of the {{Fourteenth Conference}} on {{Uncertainty}} in {{Artificial Intelligence}}},
  author = {Horvitz, Eric and Breese, Jack and Heckerman, David and Hovel, David and Rommelse, Koos},
  year = {1998},
  pages = {256--265},
  publisher = {{Morgan Kaufmann Publishers Inc.}},
  address = {{San Francisco, CA, USA}},
  abstract = {The Lumi\`ere Project centers on harnessing probability and utility to provide assistance to computer software users. We review work on Bayesian user models that can be employed to infer a user's needs by considering a user's background, actions, and queries. Several problems were tackled in Lumi\`ere research, including (1) the construction of Bayesian models for reasoning about the time-varying goals of computer users from their observed actions and queries, (2) gaining access to a stream of events from software applications, (3) developing a language for transforming system events into observational variables represented in Bayesian user models, (4) developing persistent profiles to capture changes in a user's expertise, and (5) the development of an overall architecture for an intelligent user interface. Lumi\`ere prototypes served as the basis for the Ofice Assistant in the Microsoft Office '97 suite of productivity applications.},
  isbn = {978-1-55860-555-8},
  series = {{{UAI}}'98}
}

@inproceedings{horvitz1999,
  title = {Principles of {{Mixed}}-{{Initiative User Interfaces}}},
  booktitle = {Proceedings of the {{SIGCHI}} Conference on {{Human}} Factors in Computing Systems the {{CHI}} Is the Limit - {{CHI}} '99},
  author = {Horvitz, Eric},
  year = {1999},
  pages = {159--166},
  publisher = {{ACM Press}},
  address = {{Pittsburgh, Pennsylvania, United States}},
  doi = {10.1145/302979.303030},
  abstract = {Recent debate has centered on the relative promise of focusing user-interface research on developing new metaphors and tools that enhance users' abilities to directly manipulate objects versus directing effort toward developing interface agents that provide automation. In this paper, we review principles that show promise for allowing engineers to enhance human\textemdash computer interaction through an elegant coupling of automated services with direct manipulation. Key ideas will be highlighted in terms of the LookOut system for scheduling and meeting management.},
  isbn = {978-0-201-48559-2},
  language = {en}
}

@article{horvitz2003,
  title = {Models of {{Attention}} in {{Computing}} and {{Communication}}: {{From Principles}} to {{Applications}}},
  shorttitle = {Models of {{Attention}} in {{Computing}} and {{Communication}}},
  author = {Horvitz, Eric and Kadie, Carl and Paek, Tim and Hovel, David},
  year = {2003},
  month = mar,
  volume = {46},
  pages = {52},
  issn = {00010782},
  doi = {10.1145/636772.636798},
  journal = {Communications of the ACM},
  language = {en},
  number = {3}
}

@incollection{houde1997,
  title = {What Do {{Prototypes Prototype}}?},
  booktitle = {Handbook of {{Human}}-{{Computer Interaction}}},
  author = {Houde, Stephanie and Hill, Charles},
  editor = {Helander, Martin G. and Landauer, Thomas K. and Prabhu, Prasad V.},
  year = {1997},
  edition = {2nd edition},
  pages = {367--382},
  publisher = {{Elsevier}},
  address = {{Amsterdam, Netherlands}},
  language = {en}
}

@article{hullman2011,
  title = {Visualization {{Rhetoric}}: {{Framing Effects}} in {{Narrative Visualization}}},
  shorttitle = {Visualization {{Rhetoric}}},
  author = {Hullman, J. and Diakopoulos, N.},
  year = {2011},
  month = dec,
  volume = {17},
  pages = {2231--2240},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2011.255},
  abstract = {Narrative visualizations combine conventions of communicative and exploratory information visualization to convey an intended story. We demonstrate visualization rhetoric as an analytical framework for understanding how design techniques that prioritize particular interpretations in visualizations that ``tell a story'' can significantly affect end-user interpretation. We draw a parallel between narrative visualization interpretation and evidence from framing studies in political messaging, decision-making, and literary studies. Devices for understanding the rhetorical nature of narrative information visualizations are presented, informed by the rigorous application of concepts from critical theory, semiotics, journalism, and political theory. We draw attention to how design tactics represent additions or omissions of information at various levels\textemdash the data, visual representation, textual annotations, and interactivity\textemdash and how visualizations denote and connote phenomena with reference to unstated viewing conventions and codes. Classes of rhetorical techniques identified via a systematic analysis of recent narrative visualizations are presented, and characterized according to their rhetorical contribution to the visualization. We describe how designers and researchers can benefit from the potentially positive aspects of visualization rhetoric in designing engaging, layered narrative visualizations and how our framework can shed light on how a visualization design prioritizes specific interpretations. We identify areas where future inquiry into visualization rhetoric can improve understanding of visualization interpretation.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  language = {en},
  number = {12}
}

@article{hullman2019,
  title = {In {{Pursuit}} of {{Error}}: {{A Survey}} of {{Uncertainty Visualization Evaluation}}},
  shorttitle = {In {{Pursuit}} of {{Error}}},
  author = {Hullman, Jessica and Qiao, Xiaoli and Correll, Michael and Kale, Alex and Kay, Matthew},
  year = {2019},
  month = jan,
  volume = {25},
  pages = {903--913},
  issn = {1077-2626, 1941-0506, 2160-9306},
  doi = {10.1109/TVCG.2018.2864889},
  abstract = {Understanding and accounting for uncertainty is critical to effectively reasoning about visualized data. However, evaluating the impact of an uncertainty visualization is complex due to the difficulties that people have interpreting uncertainty and the challenge of defining correct behavior with uncertainty information. Currently, evaluators of uncertainty visualization must rely on general purpose visualization evaluation frameworks which can be ill-equipped to provide guidance with the unique difficulties of assessing judgments under uncertainty. To help evaluators navigate these complexities, we present a taxonomy for characterizing decisions made in designing an evaluation of an uncertainty visualization. Our taxonomy differentiates six levels of decisions that comprise an uncertainty visualization evaluation: the behavioral targets of the study, expected effects from an uncertainty visualization, evaluation goals, measures, elicitation techniques, and analysis approaches. Applying our taxonomy to 86 user studies of uncertainty visualizations, we find that existing evaluation practice, particularly in visualization research, focuses on Performance and Satisfaction-based measures that assume more predictable and statistically-driven judgment behavior than is suggested by research on human judgment and decision making. We reflect on common themes in evaluation practice concerning the interpretation and semantics of uncertainty, the use of confidence reporting, and a bias toward evaluating performance as accuracy rather than decision quality. We conclude with a concrete set of recommendations for evaluators designed to reduce the mismatch between the conceptualization of uncertainty in visualization versus other fields.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  language = {en},
  number = {1}
}

@article{hundhausen2002,
  title = {A {{Meta}}-{{Study}} of {{Algorithm Visualization Effectiveness}}},
  author = {Hundhausen, Christopher D. and Douglas, Sarah A. and Stasko, John T.},
  year = {2002},
  month = jun,
  volume = {13},
  pages = {259--290},
  issn = {1045926X},
  doi = {10.1006/jvlc.2002.0237},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/hundhausen2002-zotero.md;/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/hundhausen2002.md;/Users/geoffreylitt/Zotero/storage/QZGUQS3W/Hundhausen et al. - 2002 - A Meta-Study of Algorithm Visualization Effectiven.pdf},
  journal = {Journal of Visual Languages \& Computing},
  language = {en},
  number = {3}
}

@article{hutchins1985,
  title = {Direct {{Manipulation Interfaces}}},
  author = {Hutchins, Edwin L and Hollan, James D and Norman, Donald A},
  year = {1985},
  pages = {28},
  abstract = {Direct manipulation has been lauded as a good form of interface design, and some interfaces that have this property have been well received by users. In this article we seek a cognitive account of both the advantages and disadvantages of direct manipulation interfaces. We identify two underlying phenomena that give rise to the feeling of directness. O n e deals with the information processing distance between the user's intentions and the facilities provided by the machine. Reduction of this distance makes the interface feel direct by reducing the effort required of the user to accomplish goals. The second phenomenon concerns the relation between the input and output vocabularies of the interface language. In particular, direct manipulation requires that the system provide representations of objects that behave as if they are the objects themselves. This provides the feeling of directness of manipulation.},
  file = {/Users/geoffreylitt/Zotero/storage/NACHFDN3/Hutchins et al. - Direct Manipulation Interfaces.pdf},
  language = {en}
}

@inproceedings{hutchinson2003,
  title = {Technology {{Probes}}: {{Inspiring Design}} for and with {{Families}}},
  shorttitle = {Technology {{Probes}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Hutchinson, Hilary and Mackay, Wendy and Westerlund, Bo and Bederson, Benjamin B. and Druin, Allison and Plaisant, Catherine and {Beaudouin-Lafon}, Michel and Conversy, St{\'e}phane and Evans, Helen and Hansen, Heiko and Roussel, Nicolas and Eiderb{\"a}ck, Bj{\"o}rn},
  year = {2003},
  pages = {17--24},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/642611.642616},
  abstract = {We describe a new method for use in the process of co-designing technologies with users called technology probes. Technology probes are simple, flexible, adaptable technologies with three interdisciplinary goals: the social science goal of understanding the needs and desires of users in a real-world setting, the engineering goal of field-testing the technology, and the design goal of inspiring users and researchers to think about new technologies. We present the results of designing and deploying two technology probes, the messageProbe and the videoProbe, with diverse families in France, Sweden, and the U.S. We conclude with our plans for creating new technologies for and with families based on our experiences.},
  isbn = {978-1-58113-630-2},
  keywords = {computer mediated communication,ethnography,home,participatory design and cooperative design},
  series = {{{CHI}} '03}
}

@article{huynh,
  title = {Piggy {{Bank}}: {{Experience}} the {{Semantic Web Inside Your Web Browser}}},
  author = {Huynh, David and Mazzocchi, Stefano and Karger, David},
  pages = {15},
  abstract = {The Semantic Web Initiative envisions a Web wherein information is offered free of presentation, allowing more effective exchange and mixing across web sites and across web pages. But without substantial Semantic Web content, few tools will be written to consume it; without many such tools, there is little appeal to publish Semantic Web content.},
  file = {/Users/geoffreylitt/Zotero/storage/KN75YT2E/Huynh et al. - Piggy Bank Experience the Semantic Web Inside You.pdf},
  language = {en}
}

@inproceedings{huynh2005,
  title = {Piggy {{Bank}}: {{Experience}} the {{Semantic Web Inside Your Web Browser}}},
  shorttitle = {Piggy {{Bank}}},
  booktitle = {The {{Semantic Web}} \textendash{} {{ISWC}} 2005},
  author = {Huynh, David and Mazzocchi, Stefano and Karger, David},
  editor = {Gil, Yolanda and Motta, Enrico and Benjamins, V. Richard and Musen, Mark A.},
  year = {2005},
  pages = {413--430},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/11574620_31},
  abstract = {The Semantic Web Initiative envisions a Web wherein information is offered free of presentation, allowing more effective exchange and mixing across web sites and across web pages. But without substantial Semantic Web content, few tools will be written to consume it; without many such tools, there is little appeal to publish Semantic Web content.To break this chicken-and-egg problem, thus enabling more flexible informa-tion access, we have created a web browser extension called Piggy Bankthat lets users make use of Semantic Web content within Web content as users browse the Web. Wherever Semantic Web content is not available, Piggy Bank can invoke screenscrapers to re-structure information within web pages into Semantic Web format. Through the use of Semantic Web technologies, Piggy Bank provides direct, immediate benefits to users in their use of the existing Web. Thus, the ex-istence of even just a few Semantic Web-enabled sites or a few scrapers already benefits users. Piggy Bank thereby offers an easy, incremental upgrade path to users without requiring a wholesale adoption of the Semantic Web's vision.To further improve this Semantic Web experience, we have created Semantic Bank, a web server application that lets Piggy Bank users share the Semantic Web information they have collected, enabling collaborative efforts to build so-phisticated Semantic Web information repositories through simple, everyday's use of Piggy Bank.},
  file = {/Users/geoffreylitt/Zotero/storage/T84CAZ7L/Huynh et al. - 2005 - Piggy Bank Experience the Semantic Web Inside You.pdf},
  isbn = {978-3-540-32082-1},
  keywords = {Common Data Model,Information Item,Resource Description Framework,Resource Description Framework Data,Temporary Database},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{huynh2006,
  title = {Enabling Web Browsers to Augment Web Sites' Filtering and Sorting Functionalities},
  booktitle = {Proceedings of the 19th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '06},
  author = {Huynh, David F. and Miller, Robert C. and Karger, David R.},
  year = {2006},
  pages = {125},
  publisher = {{ACM Press}},
  address = {{Montreux, Switzerland}},
  doi = {10.1145/1166253.1166274},
  abstract = {Existing augmentations of web pages are mostly small cosmetic changes (e.g., removing ads) and minor addition of third-party content (e.g., product prices from competing sites). None leverages the structured data presented in web pages. This paper describes Sifter, a web browser extension that can augment a well-structured web site with advanced filtering and sorting functionality. These added features work inside the site's own pages, preserving the site's presentational style and the user's context. Sifter contains an algorithm that scrapes structured data out of well-structured web pages while usually requiring no user intervention. We tested Sifter on real web sites and real users and found that people could use Sifter to perform sophisticated queries and high-level analyses on sizable data collections on the Web. We propose that web sites can be similarly augmented with other sophisticated data-centric functionality, giving users new benefits over the existing Web.},
  file = {/Users/geoffreylitt/Zotero/storage/8WA9RXE3/Huynh et al. - 2006 - Enabling web browsers to augment web sites' filter.pdf},
  isbn = {978-1-59593-313-3},
  language = {en}
}

@inproceedings{huynh2007,
  title = {Exhibit: Lightweight Structured Data Publishing},
  shorttitle = {Exhibit},
  booktitle = {Proceedings of the 16th International Conference on {{World Wide Web}}  - {{WWW}} '07},
  author = {Huynh, David F. and Karger, David R. and Miller, Robert C.},
  year = {2007},
  pages = {737},
  publisher = {{ACM Press}},
  address = {{Banff, Alberta, Canada}},
  doi = {10.1145/1242572.1242672},
  abstract = {The early Web was hailed for giving individuals the same publishing power as large content providers. But over time, large content providers learned to exploit the structure in their data, leveraging databases and server side technologies to provide rich browsing and visualization. Individual authors fall behind once more: neither old-fashioned static pages nor domain-specific publishing frameworks supporting limited customization can match custom database-backed web applications.},
  file = {/Users/geoffreylitt/Zotero/storage/KDFB58RI/Huynh et al. - 2007 - Exhibit lightweight structured data publishing.pdf},
  isbn = {978-1-59593-654-7},
  language = {en}
}

@article{huynh2008,
  title = {Potluck: {{Data}} Mash-up Tool for Casual Users},
  shorttitle = {Potluck},
  author = {Huynh, David F. and Miller, Robert C. and Karger, David R.},
  year = {2008},
  month = nov,
  volume = {6},
  pages = {274--282},
  issn = {15708268},
  doi = {10.1016/j.websem.2008.09.005},
  abstract = {As more and more reusable structured data appears on the Web, casual users will want to take into their own hands the task of mashing up data rather than wait for mash-up sites to be built that address exactly their individually unique needs. In this paper, we present Potluck, a Web user interface that let's casual users\textemdash those without programming skills and data modeling expertise\textemdash mash up data themselves.},
  file = {/Users/geoffreylitt/Zotero/storage/XL8L5IPD/Huynh et al. - 2008 - Potluck Data mash-up tool for casual users.pdf},
  journal = {Journal of Web Semantics},
  language = {en},
  number = {4}
}

@article{hypercard2019,
  title = {{{HyperCard}}},
  author = {Hypercard},
  year = {2019},
  month = dec,
  abstract = {HyperCard is a software application and  development kit for Apple Macintosh and Apple IIGS computers. It is among the first successful hypermedia systems predating the World Wide Web. HyperCard combines a flat-file database with a graphical, flexible, user-modifiable interface. HyperCard includes a built-in programming language called HyperTalk for manipulating data and the user interface. This combination of features \textendash{} a database with simple form layout, flexible support for graphics, and ease of programming \textendash{} suits HyperCard for many different projects such as rapid application development of applications and databases, interactive applications with no database requirements, command and control systems, and many examples in the demoscene. HyperCard was originally released in 1987 for \$49.95 and was included for free with all new Macs sold then. It was withdrawn from sale in March 2004, having received its final update in 1998 upon the return of Steve Jobs to Apple. HyperCard runs in the Classic Environment, but was not ported to Mac OS X.},
  annotation = {Page Version ID: 931376685},
  copyright = {Creative Commons Attribution-ShareAlike License},
  file = {/Users/geoffreylitt/Zotero/storage/XZV548R8/index.html},
  journal = {Wikipedia},
  language = {en}
}

@article{irani2015,
  title = {Hackathons and the {{Making}} of {{Entrepreneurial Citizenship}}},
  author = {Irani, Lilly},
  year = {2015},
  month = sep,
  volume = {40},
  pages = {799--824},
  issn = {0162-2439, 1552-8251},
  doi = {10.1177/0162243915578486},
  abstract = {Today the halls of Technology, Entertainment, and Design (TED) and Davos reverberate with optimism that hacking, brainstorming, and crowdsourcing can transform citizenship, development, and education alike. This article examines these claims ethnographically and historically with an eye toward the kinds of social orders such practices produce. This article focuses on a hackathon, one emblematic site of social practice where techniques from information technology (IT) production become ways of remaking culture. Hackathons sometimes produce technologies, and they always, however, produce subjects. This article argues that the hackathon rehearses an entrepreneurial citizenship celebrated in transnational cultures that orient toward Silicon Valley for models of social change. Such optimistic, highvelocity practice aligns, in India, with middle-class politics that favor quick and forceful action with socially similar collaborators over the contestations of mass democracy or the slow construction of coalition across difference.},
  file = {/Users/geoffreylitt/Zotero/storage/ENTN3BAA/Irani - 2015 - Hackathons and the Making of Entrepreneurial Citiz.pdf},
  journal = {Science, Technology, \& Human Values},
  language = {en},
  number = {5}
}

@article{iverson,
  title = {Notation as a {{Tool}} of {{Thought}}},
  author = {Iverson, Kenneth E},
  pages = {52},
  file = {/Users/geoffreylitt/Zotero/storage/HLHGK5X3/Iverson - Notation as a Tool of Thought.pdf},
  language = {en}
}

@article{jackson2002,
  title = {Alloy: A Lightweight Object Modelling Notation},
  shorttitle = {Alloy},
  author = {Jackson, Daniel},
  year = {2002},
  month = apr,
  volume = {11},
  pages = {256--290},
  issn = {1049331X},
  doi = {10.1145/505145.505149},
  file = {/Users/geoffreylitt/Zotero/storage/D2PEJZE5/Jackson - 2002 - Alloy a lightweight object modelling notation.pdf},
  journal = {ACM Transactions on Software Engineering and Methodology},
  language = {en},
  number = {2}
}

@inproceedings{jackson2015,
  title = {Towards a Theory of Conceptual Design for Software},
  booktitle = {2015 {{ACM International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}} ({{Onward}}!) - {{Onward}}! 2015},
  author = {Jackson, Daniel},
  year = {2015},
  pages = {282--296},
  publisher = {{ACM Press}},
  address = {{Pittsburgh, PA, USA}},
  doi = {10.1145/2814228.2814248},
  abstract = {Concepts are the building blocks of software systems. They are not just subjective mental constructs, but are objective features of a system's design: increments of functionality that were consciously introduced by a designer to serve particular purposes.},
  file = {/Users/geoffreylitt/Zotero/storage/AZ59TKGL/Jackson - 2015 - Towards a theory of conceptual design for software.pdf},
  isbn = {978-1-4503-3688-8},
  language = {en}
}

@article{james,
  title = {Digging for {{Fold}}: {{Synthesis}}-{{Aided API Discovery}} for {{Haskell}}},
  author = {James, Michael B and Guo, Zheng and Wang, Ziteng and Doshi, Shivani and Peleg, Hila and Jhala, Ranjit and Polikarpova, Nadia},
  volume = {1},
  pages = {28},
  file = {/Users/geoffreylitt/Zotero/storage/DL9IIBBP/James et al. - Digging for Fold Synthesis-Aided API Discovery fo.pdf},
  language = {en}
}

@inproceedings{jensen2018,
  title = {Remediating a {{Design Tool}}: {{Implications}} of {{Digitizing Sticky Notes}}},
  shorttitle = {Remediating a {{Design Tool}}},
  booktitle = {Proceedings of the 2018 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Jensen, Mads M{\o}ller and R{\"a}dle, Roman and Klokmose, Clemens N. and Bodker, Susanne},
  year = {2018},
  month = apr,
  pages = {1--12},
  publisher = {{Association for Computing Machinery}},
  address = {{Montreal QC, Canada}},
  doi = {10.1145/3173574.3173798},
  abstract = {Sticky notes are ubiquitous in design processes because of their tangibility and ease of use. Yet, they have well-known limitations in professional design processes, as documentation and distribution are cumbersome at best. This paper compares the use of sticky notes in ideation with a remediated digital sticky notes setup. The paper contributes with a nuanced understanding of what happens when remediating a physical design tool into digital space, by emphasizing focus shifts and breakdowns caused by the technology, but also benefits and promises inherent in the digital media. Despite users' preference for creating physical notes, handling digital notes on boards was easier and the potential of proper documentation make the digital setup a possible alternative. While the analogy in our remediation supported a transfer of learned handling, the users' experiences across technological setups impact their use and understanding, yielding new concerns regarding cross-device transfer and collaboration.},
  file = {/Users/geoffreylitt/Zotero/storage/Y7AD6GWN/Jensen et al. - 2018 - Remediating a Design Tool Implications of Digitiz.pdf},
  isbn = {978-1-4503-5620-6},
  keywords = {comparative analysis,cross-device interaction,design tools,remediation,sticky notes},
  series = {{{CHI}} '18}
}

@article{jones,
  title = {Tackling the {{Awkward Squad}}: Monadic Input/Output, Concurrency, Exceptions, and Foreign-Language Calls in {{Haskell}}},
  author = {Jones, Simon PEYTON},
  pages = {46},
  abstract = {Functional programming may be beautiful, but to write real applications we must grapple with awkward real-world issues: input/output, robustness, concurrency, and interfacing to programs written in other languages.},
  file = {/Users/geoffreylitt/Zotero/storage/HQWP2WDS/Jones - Tackling the Awkward Squad monadic inputoutput, .pdf},
  language = {en}
}

@incollection{jones2010,
  title = {Mashed Layers and Muddled Models},
  booktitle = {No {{Code Required}}},
  author = {Jones, M. Cameron and Churchill, Elizabeth F. and Nelson, Les},
  year = {2010},
  pages = {423--438},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00022-5},
  abstract = {Programming for the Web is a daunting task, especially when attempting to mash up multiple services and data sources. Many technologies advocated in this book approach this problem by attempting to hide the messiness of the Web from the developer. However, these efforts can complicate the process of debugging as data are passed through multiple transformations and sources of errors are obscured beneath additional layers of abstraction and processing. In this chapter we discuss the issues of debugging Web applications and Web mashups, and we explore how users of the Yahoo! Pipes programming environment turn to an online community for help-seeking and help-giving. We discuss the social and collaborative aspects of debugging in Web programming and argue that the complexity and heterogeneity of the Web requires a diversity of knowledge and experience beyond the grasp of any individual, and any effort to encourage or enhance the end user programming experience for the Web must embrace facilities for social and collaborative engagement.},
  file = {/Users/geoffreylitt/Zotero/storage/NSEUTURI/Jones et al. - 2010 - Mashed layers and muddled models.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@inproceedings{jun2019,
  title = {Tea: {{A High}}-Level {{Language}} and {{Runtime System}} for {{Automating Statistical Analysis}}},
  shorttitle = {Tea},
  booktitle = {Proceedings of the 32nd {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  author = {Jun, Eunice and Daum, Maureen and Roesch, Jared and Chasins, Sarah and Berger, Emery and Just, Rene and Reinecke, Katharina},
  year = {2019},
  month = oct,
  pages = {591--603},
  publisher = {{ACM}},
  address = {{New Orleans LA USA}},
  doi = {10.1145/3332165.3347940},
  abstract = {Though statistical analyses are centered on research questions and hypotheses, current statistical analysis tools are not. Users must first translate their hypotheses into specific statistical tests and then perform API calls with functions and parameters. To do so accurately requires that users have statistical expertise. To lower this barrier to valid, replicable statistical analysis, we introduce Tea, a high-level declarative language and runtime system. In Tea, users express their study design, any parametric assumptions, and their hypotheses. Tea compiles these high-level specifications into a constraint satisfaction problem that determines the set of valid statistical tests and then executes them to test the hypothesis. We evaluate Tea using a suite of statistical analyses drawn from popular tutorials. We show that Tea generally matches the choices of experts while automatically switching to non-parametric tests when parametric assumptions are not met. We simulate the effect of mistakes made by non-expert users and show that Tea automatically avoids both false negatives and false positives that could be produced by the application of incorrect statistical tests.},
  file = {/Users/geoffreylitt/Zotero/storage/CB94BGTT/Jun et al. - 2019 - Tea A High-level Language and Runtime System for .pdf},
  isbn = {978-1-4503-6816-2},
  language = {en}
}

@article{kahneman2004,
  title = {A {{Survey Method}} for {{Characterizing Daily Life Experience}}: {{The Day Reconstruction Method}}},
  shorttitle = {A {{Survey Method}} for {{Characterizing Daily Life Experience}}},
  author = {Kahneman, Daniel and Krueger, Alan B. and Schkade, David A. and Schwarz, Norbert and Stone, Arthur A.},
  year = {2004},
  month = dec,
  volume = {306},
  pages = {1776--1780},
  issn = {0036-8075, 1095-9203},
  doi = {10.1126/science.1103572},
  abstract = {The Day Reconstruction Method (DRM) assesses how people spend their time and how they experience the various activities and settings of their lives, combining features of time-budget measurement and experience sampling. Participants systematically reconstruct their activities and experiences of the preceding day with procedures designed to reduce recall biases. The DRM's utility is shown by documenting close correspondences between the DRM reports of 909 employed women and established results from experience sampling. An analysis of the hedonic treadmill shows the DRM's potential for well-being research.},
  journal = {Science},
  language = {en},
  number = {5702}
}

@article{kandel2012,
  title = {Enterprise {{Data Analysis}} and {{Visualization}}: {{An Interview Study}}},
  shorttitle = {Enterprise {{Data Analysis}} and {{Visualization}}},
  author = {Kandel, Sean and Paepcke, Andreas and Hellerstein, Joseph M. and Heer, Jeffrey},
  year = {2012},
  month = dec,
  volume = {18},
  pages = {2917--2926},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2012.219},
  abstract = {Organizations rely on data analysts to model customer engagement, streamline operations, improve production, inform business decisions, and combat fraud. Though numerous analysis and visualization tools have been built to improve the scale and efficiency at which analysts can work, there has been little research on how analysis takes place within the social and organizational context of companies. To better understand the enterprise analysts' ecosystem, we conducted semi-structured interviews with 35 data analysts from 25 organizations across a variety of sectors, including healthcare, retail, marketing and finance. Based on our interview data, we characterize the process of industrial data analysis and document how organizational features of an enterprise impact it. We describe recurring pain points, outstanding challenges, and barriers to adoption for visual analytic tools. Finally, we discuss design implications and opportunities for visual analysis research.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  language = {en},
  number = {12}
}

@inproceedings{kang2017,
  title = {Omnicode: {{A Novice}}-{{Oriented Live Programming Environment}} with {{Always}}-{{On Run}}-{{Time Value Visualizations}}},
  shorttitle = {Omnicode},
  booktitle = {Proceedings of the 30th {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  author = {Kang, Hyeonsu and Guo, Philip J.},
  year = {2017},
  month = oct,
  pages = {737--745},
  publisher = {{ACM}},
  address = {{Qu\'ebec City QC Canada}},
  doi = {10.1145/3126594.3126632},
  abstract = {Visualizations of run-time program state help novices form proper mental models and debug their code. We push this technique to the extreme by posing the following question: What if a live programming environment for an imperative language always displays the entire history of all run-time values for all program variables all the time? To explore this question, we built a prototype live IDE called Omnicode (``Omniscient Code'') that continually runs the user's Python code and uses a scatterplot matrix to visualize the entire history of all of its numerical values, along with meaningful numbers derived from other data types. To filter the visualizations and hone in on specific points of interest, the user can brush and link over the scatterplots or select portions of code. They can also zoom in to view detailed stack and heap visualizations at each execution step. An exploratory study on 10 novice programmers discovered that they found Omnicode to be useful for debugging, forming mental models, explaining their code to others, and discovering moments of serendipity that would not have been likely within an ordinary IDE.},
  file = {/Users/geoffreylitt/Zotero/storage/PDKJMA9H/Kang and Guo - 2017 - Omnicode A Novice-Oriented Live Programming Envir.pdf},
  isbn = {978-1-4503-4981-9},
  keywords = {program visualization},
  language = {en}
}

@phdthesis{kasibatla2018,
  title = {Seymour: {{A Live Programming Environment}} for the {{Classroom}}},
  shorttitle = {Seymour},
  author = {Kasibatla, Saketh Ram},
  year = {2018},
  abstract = {A programming environment that visualizes a program's execution can help users better understand their programs. However, building such an environment for programmers at large is difficult, as it is not clear how to effectively visualize large, complex programs. We would like to make progress on this problem by first focusing on a subproblem: creating a better programming experience for learning and teaching programming. To explore this approach, we built Seymour, a prototype live programming environment that visualizes all events in a program's execution. Seymour features two complementary visualizations\textemdash one that shows a detailed view of a method call, and another that depicts the whole execution at a high level. These two visualizations come together to create a compelling user experience that we plan to test and improve with student feedback},
  file = {/Users/geoffreylitt/Zotero/storage/C4HAJB3I/Kasibatla - 2018 - Seymour A Live Programming Environment for the Cl.pdf;/Users/geoffreylitt/Zotero/storage/IX5Z2NLB/8gx5x6kj.html},
  language = {en},
  school = {UCLA}
}

@inproceedings{kay1972,
  title = {A {{Personal Computer}} for {{Children}} of {{All Ages}}},
  booktitle = {Proceedings of the {{ACM Annual Conference}} - {{Volume}} 1},
  author = {Kay, Alan C.},
  year = {1972},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/800193.1971922},
  abstract = {This note speculates about the emergence of personal, portable information manipulators and their effects when used by both children and adults. Although it should be read as science fiction, current trends in miniaturization and price reduction almost guarantee that many of the notions discussed will actually happen in the near future.},
  series = {{{ACM}} '72}
}

@article{kay1977,
  title = {Personal {{Dynamic Media}}},
  author = {Kay, A. and Goldberg, A.},
  year = {1977},
  month = mar,
  volume = {10},
  pages = {31--41},
  issn = {1558-0814},
  doi = {10.1109/C-M.1977.217672},
  abstract = {The Learning Research Group at Xerox Palo Alto Research Center is concerned with all aspects of the communication and manipulation of knowledge. We design, build, and use dynamic media which can be used by human beings of all ages. Several years ago, we crystallized our dreams into a design idea for a personal dynamic medium the size of a notebook (the Dynabook) which could be owned by everyone and could have the power to handle virtually all of its owner's information-related needs. Towards this goal we have designed and built a communications system: the Smalltalk language, implemented on small computers we refer to as "interim Dynabooks." We are exploring the use of this system as a programming and problem solving tool; as an interactive memory for the storage and manipulation of data; as a text editor; and as a medium for expression through drawing, painting, animating pictures, and composing and generating music. (Figure 1 is a view of this interim Dynabook.)},
  file = {/Users/geoffreylitt/Zotero/storage/Q3SGCHYI/Kay and Goldberg - 1977 - Personal Dynamic Media.pdf;/Users/geoffreylitt/Zotero/storage/8Q36BUGB/1646405.html},
  journal = {Computer},
  keywords = {Animation,Computational modeling,Crystallization,Embedded computing,Information retrieval,Manipulator dynamics,Problem-solving},
  number = {3}
}

@unpublished{kay1984,
  title = {Opening the {{Hood}} of a {{Word Processor}}},
  author = {Kay, Alan},
  year = {1984},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/kay1984-zotero.md;/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/kay1984.md;/Users/geoffreylitt/Zotero/storage/R5FDT5ZD/Opening the Hood of a Word Processor.pdf}
}

@misc{kay1997,
  title = {The Computer Revolution Hasn't Happened Yet},
  author = {Kay, Alan},
  year = {1997},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/The Computer Revolution Hasnt Happened Yet (kay1997).md;/Users/geoffreylitt/Zotero/storage/ULFEXECA/watch.html}
}

@article{kell,
  title = {The {{Mythical Matched Modules}}},
  author = {Kell, Stephen},
  pages = {8},
  abstract = {Conventional tools yield expensive and inflexible software. By requiring that software be structured as plug-compatible modules, tools preclude out-of-order development; by treating interoperation of languages as rare, adoption of innovations is inhibited. I propose that a solution must radically separate the concern of integration in software: firstly by using novel tools specialised towards integration (the ``integration domain''), and secondly by prohibiting use of preexisting interfaces (``interface hiding'') outside that domain.},
  file = {/Users/geoffreylitt/Zotero/storage/QPN955A7/Kell - The Mythical Matched Modules.pdf},
  keywords = {toread},
  language = {en}
}

@inproceedings{kell2010,
  title = {Component Adaptation and Assembly Using Interface Relations},
  booktitle = {Proceedings of the {{ACM}} International Conference on {{Object}} Oriented Programming Systems Languages and Applications},
  author = {Kell, Stephen},
  year = {2010},
  month = oct,
  pages = {322--340},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1869459.1869487},
  abstract = {Software's expense owes partly to frequent reimplementation of similar functionality and partly to maintenance of patches, ports or components targeting evolving interfaces. More modular non-invasive approaches are unpopular because they entail laborious wrapper code. We propose Cake, a rule-based language describing compositions using interface relations. To evaluate it, we compare several existing wrappers with reimplemented Cake versions, finding the latter to be simpler and better modularised.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/kell2010.md;/Users/geoffreylitt/Zotero/storage/AYWXKTA4/Kell - 2010 - Component adaptation and assembly using interface .pdf},
  isbn = {978-1-4503-0203-6},
  keywords = {adaptation,assembly,cake,components,composition,interoperability,interoperation},
  series = {{{OOPSLA}} '10}
}

@inproceedings{kell2013,
  title = {The Operating System: Should There Be One?},
  shorttitle = {The Operating System},
  booktitle = {Proceedings of the {{Seventh Workshop}} on {{Programming Languages}} and {{Operating Systems}} - {{PLOS}} '13},
  author = {Kell, Stephen},
  year = {2013},
  pages = {1--7},
  publisher = {{ACM Press}},
  address = {{Farmington, Pennsylvania}},
  doi = {10.1145/2525528.2525534},
  abstract = {Operating systems and programming languages are often informally evaluated on their conduciveness towards composition. We revisit Dan Ingalls' Smalltalk-inspired position that ``an operating system is a collection of things that don't fit inside a language; there shouldn't be one'', discussing what it means, why it appears not to have materialised, and how we might work towards the same effect in the postmodern reality of today's systems. We argue that the trajectory of the ``file'' abstraction through Unix and Plan 9 culminates in a Smalltalk-style object, with other filesystem calls as a primitive metasystem. Meanwhile, the key features of Smalltalk have many analogues in the fragmented world of Unix programming (including techniques at the library, file and socket level). Based on the themes of unifying OS- and language-level mechanisms, and increasing the expressiveness of the meta-system, we identify some evolutionary approaches to a postmodern realisation of Ingalls' vision, arguing that an operating system is still necessary after all.},
  file = {/Users/geoffreylitt/Zotero/storage/7BA5FUE2/Kell - 2013 - The operating system should there be one.pdf},
  isbn = {978-1-4503-2460-1},
  keywords = {toread},
  language = {en}
}

@inproceedings{kery2017,
  title = {Exploring Exploratory Programming},
  booktitle = {2017 {{IEEE Symposium}} on {{Visual Languages}} and {{Human}}-{{Centric Computing}} ({{VL}}/{{HCC}})},
  author = {Kery, M. Beth and Myers, B. A.},
  year = {2017},
  month = oct,
  pages = {25--29},
  doi = {10.1109/VLHCC.2017.8103446},
  abstract = {In open-ended tasks where a program's behavior cannot be specified in advance, exploratory programming is a key practice in which programmers actively experiment with different possibilities using code. Exploratory programming is highly relevant today to a variety of professional and end-user programmer domains, including prototyping, learning through play, digital art, and data science. However, prior research has largely lacked clarity on what exploratory programming is, and what behaviors are characteristic of this practice. Drawing on this data and prior literature, we provide an organized description of what exploratory programming has meant historically and a framework of four dimensions for studying exploratory programming tasks: (1) applications, (2) required code quality, (3) ease or difficulty of exploration, and (4) the exploratory process. This provides a basis for better analyzing tool support for exploratory programming.},
  keywords = {code quality,Creativity Support,Debugging,end-user programming,End-user programming,exploratory programming,Exploratory Programming,Games,programming,Programming profession,prototyping,software prototyping,source code (software),Tools,Visualization}
}

@article{keshav2007,
  title = {How to Read a Paper},
  author = {Keshav, S.},
  year = {2007},
  month = jul,
  volume = {37},
  pages = {83--84},
  issn = {0146-4833},
  doi = {10.1145/1273445.1273458},
  abstract = {Researchers spend a great deal of time reading research papers. However, this skill is rarely taught, leading to much wasted effort. This article outlines a practical and efficient three-pass method for reading research papers. I also describe how to use this method to do a literature survey.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/keshav2007.md;/Users/geoffreylitt/Zotero/storage/V2FJVAYK/Keshav - 2007 - How to read a paper.pdf},
  journal = {ACM SIGCOMM Computer Communication Review},
  keywords = {hints,paper,reading},
  number = {3}
}

@inproceedings{khwaja1993,
  title = {Syntax-Directed Editing Environments: Issues and Features},
  shorttitle = {Syntax-Directed Editing Environments},
  booktitle = {Proceedings of the 1993 {{ACM}}/{{SIGAPP}} Symposium on {{Applied}} Computing: States of the Art and Practice},
  author = {Khwaja, Amir Ali and Urban, Joseph E.},
  year = {1993},
  month = mar,
  pages = {230--237},
  publisher = {{Association for Computing Machinery}},
  address = {{Indianapolis, Indiana, USA}},
  doi = {10.1145/162754.162882},
  file = {/Users/geoffreylitt/Zotero/storage/T3AZ3ERI/Khwaja and Urban - 1993 - Syntax-directed editing environments issues and f.pdf},
  isbn = {978-0-89791-567-0},
  keywords = {structured editors,support environments,syntax-directed editors,toread,usability},
  series = {{{SAC}} '93}
}

@article{kim2018,
  title = {Assessing {{Effects}} of {{Task}} and {{Data Distribution}} on the {{Effectiveness}} of {{Visual Encodings}}},
  author = {Kim, Younghoon and Heer, Jeffrey},
  year = {2018},
  month = jun,
  volume = {37},
  pages = {157--167},
  issn = {01677055},
  doi = {10.1111/cgf.13409},
  abstract = {In addition to the choice of visual encodings, the effectiveness of a data visualization may vary with the analytical task being performed and the distribution of data values. To better assess these effects and create refined rankings of visual encodings, we conduct an experiment measuring subject performance across task types (e.g., comparing individual versus aggregate values) and data distributions (e.g., with varied cardinalities and entropies). We compare performance across 12 encoding specifications of trivariate data involving 1 categorical and 2 quantitative fields, including the use of x, y, color, size, and spatial subdivision (i.e., faceting). Our results extend existing models of encoding effectiveness and suggest improved approaches for automated design. For example, we find that colored scatterplots (with positionally-coded quantities and color-coded categories) perform well for comparing individual points, but perform poorly for summary tasks as the number of categories increases.},
  journal = {Computer Graphics Forum},
  language = {en},
  number = {3}
}

@article{kirsh1994,
  title = {On {{Distinguishing Epistemic}} from {{Pragmatic Action}}},
  author = {Kirsh, David and Maglio, Paul},
  year = {1994},
  volume = {18},
  pages = {513--549},
  issn = {1551-6709},
  doi = {10.1207/s15516709cog1804_1},
  abstract = {We present data and argument to show that in Tetris\textemdash a real-time, interactive video game\textemdash certain cognitive and perceptual problems are more quickly, easily, and reliably solved by performing actions in the world than by performing computational actions in the head alone. We have found that some of the translations and rotations made by players of this video game are best understood as actions that use the world to improve cognition. These actions are not used to implement a plan, or to implement a reaction; they are used to change the world in order to simplify the problem-solving task. Thus, we distinguish pragmatic actions\textemdash actions performed to bring one physically closer to a goal\textemdash from epistemic actions\textemdash actions performed to uncover informatioan that is hidden or hard to compute mentally. To illustrate the need for epistemic actions, we first develop a standard information-processing model of Tetris cognition and show that it cannot explain performance data from human players of the game\textemdash even when we relax the assumption of fully sequential processing. Standard models disregard many actions taken by players because they appear unmotivated or superfluous. However, we show that such actions are actually far from superfluous; they play a valuable role in improving human performance. We argue that traditional accounts are limited because they regard action as having a single function: to change the world. By recognizing a second function of action\textemdash an epistemic function\textemdash we can explain many of the actions that a traditional model cannot. Although our argument is supported by numerous examples specifically from Tetris, we outline how the new category of epistemic action can be incorporated into theories of action more generally.},
  journal = {Cognitive Science},
  language = {en},
  number = {4}
}

@inproceedings{kittur2008,
  title = {Harnessing the {{Wisdom}} of {{Crowds}} in {{Wikipedia}}: {{Quality Through Coordination}}},
  shorttitle = {Harnessing the {{Wisdom}} of {{Crowds}} in {{Wikipedia}}},
  booktitle = {Proceedings of the 2008 {{ACM Conference}} on {{Computer Supported Cooperative Work}}},
  author = {Kittur, Aniket and Kraut, Robert E.},
  year = {2008},
  pages = {37--46},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1460563.1460572},
  abstract = {Wikipedia's success is often attributed to the large numbers of contributors who improve the accuracy, completeness and clarity of articles while reducing bias. However, because of the coordination needed to write an article collaboratively, adding contributors is costly. We examined how the number of editors in Wikipedia and the coordination methods they use affect article quality. We distinguish between explicit coordination, in which editors plan the article through communication, and implicit coordination, in which a subset of editors structure the work by doing the majority of it. Adding more editors to an article improved article quality only when they used appropriate coordination techniques and was harmful when they did not. Implicit coordination through concentrating the work was more helpful when many editors contributed, but explicit coordination through communication was not. Both types of coordination improved quality more when an article was in a formative stage. These results demonstrate the critical importance of coordination in effectively harnessing the "wisdom of the crowd" in online production environments.},
  isbn = {978-1-60558-007-4},
  keywords = {collaboration,collective intelligence,coordination,distributed cognition,social computing,wiki,wikipedia},
  series = {{{CSCW}} '08}
}

@inproceedings{klemmer2006,
  title = {How Bodies Matter: Five Themes for Interaction Design},
  shorttitle = {How Bodies Matter},
  booktitle = {Proceedings of the 6th {{ACM}} Conference on {{Designing Interactive}} Systems  - {{DIS}} '06},
  author = {Klemmer, Scott R. and Hartmann, Bj{\"o}rn and Takayama, Leila},
  year = {2006},
  pages = {140},
  publisher = {{ACM Press}},
  address = {{University Park, PA, USA}},
  doi = {10.1145/1142405.1142429},
  abstract = {Our physical bodies play a central role in shaping human experience in the world, understanding of the world, and interactions in the world. This paper draws on theories of embodiment\textemdash from psychology, sociology, and philosophy \textemdash{} synthesizing five themes we believe are particularly salient for interaction design: thinking through doing, performance, visibility, risk, and thick practice. We introduce aspects of human embodied engagement in the world with the goal of inspiring new interaction design approaches and evaluations that better integrate the physical and computational worlds.},
  isbn = {978-1-59593-367-6},
  language = {en}
}

@article{klemmer2011,
  title = {Skintroducing the Future},
  author = {Klemmer, Scott},
  year = {2011},
  month = aug,
  volume = {54},
  pages = {110},
  issn = {00010782},
  doi = {10.1145/1978542.1978563},
  journal = {Communications of the ACM},
  language = {en},
  number = {8}
}

@article{kleppmann2017,
  title = {A {{Conflict}}-{{Free Replicated JSON Datatype}}},
  author = {Kleppmann, Martin and Beresford, Alastair R.},
  year = {2017},
  month = oct,
  volume = {28},
  pages = {2733--2746},
  issn = {1045-9219},
  doi = {10.1109/TPDS.2017.2697382},
  abstract = {Many applications model their data in a general-purpose storage format such as JSON. This data structure is modified by the application as a result of user input. Such modifications are well understood if performed sequentially on a single copy of the data, but if the data is replicated and modified concurrently on multiple devices, it is unclear what the semantics should be. In this paper we present an algorithm and formal semantics for a JSON data structure that automatically resolves concurrent modifications such that no updates are lost, and such that all replicas converge towards the same state (a conflict-free replicated datatype or CRDT). It supports arbitrarily nested list and map types, which can be modified by insertion, deletion and assignment. The algorithm performs all merging client-side and does not depend on ordering guarantees from the network, making it suitable for deployment on mobile devices with poor network connectivity, in peer-to-peer networks, and in messaging systems with end-to-end encryption.},
  archivePrefix = {arXiv},
  eprint = {1608.03960},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/VED65L6S/Kleppmann and Beresford - 2017 - A Conflict-Free Replicated JSON Datatype.pdf},
  journal = {IEEE Transactions on Parallel and Distributed Systems},
  keywords = {Computer Science - Databases,Computer Science - Distributed; Parallel; and Cluster Computing,toread},
  language = {en},
  number = {10}
}

@article{kleppmann2018,
  title = {{{OpSets}}: {{Sequential Specifications}} for {{Replicated Datatypes}} ({{Extended Version}})},
  shorttitle = {{{OpSets}}},
  author = {Kleppmann, Martin and Gomes, Victor B. F. and Mulligan, Dominic P. and Beresford, Alastair R.},
  year = {2018},
  month = may,
  abstract = {We introduce OpSets, an executable framework for specifying and reasoning about the semantics of replicated datatypes that provide eventual consistency in a distributed system, and for mechanically verifying algorithms that implement these datatypes. Our approach is simple but expressive, allowing us to succinctly specify a variety of abstract datatypes, including maps, sets, lists, text, graphs, trees, and registers. Our datatypes are also composable, enabling the construction of complex data structures. To demonstrate the utility of OpSets for analysing replication algorithms, we highlight an important correctness property for collaborative text editing that has traditionally been overlooked; algorithms that do not satisfy this property can exhibit awkward interleaving of text. We use OpSets to specify this correctness property and prove that although one existing replication algorithm satisfies this property, several other published algorithms do not. We also show how OpSets can be used to develop new replicated datatypes: we provide a simple specification of an atomic move operation for trees, an operation that had previously been thought to be impossible to implement without locking. We use the Isabelle/HOL proof assistant to formalise the OpSets approach and produce mechanised proofs of correctness of the main claims in this paper, thereby eliminating the ambiguity of previous informal approaches, and ruling out reasoning errors that could occur in handwritten proofs.},
  archivePrefix = {arXiv},
  eprint = {1805.04263},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/X67R4RYN/Kleppmann et al. - 2018 - OpSets Sequential Specifications for Replicated D.pdf},
  journal = {arXiv:1805.04263 [cs]},
  keywords = {Computer Science - Distributed; Parallel; and Cluster Computing,crdt,toread},
  language = {en},
  primaryClass = {cs}
}

@misc{kleppmann2018a,
  title = {Automerge: {{Real}}-Time Data Sync between Edge Devices},
  author = {Kleppmann, Martin and Beresford, Alastair},
  year = {2018}
}

@inproceedings{kleppmann2019,
  title = {Local-First Software: You Own Your Data, in Spite of the Cloud},
  shorttitle = {Local-First Software},
  booktitle = {Proceedings of the 2019 {{ACM SIGPLAN International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}}  - {{Onward}}! 2019},
  author = {Kleppmann, Martin and Wiggins, Adam and {van Hardenberg}, Peter and McGranaghan, Mark},
  year = {2019},
  pages = {154--178},
  publisher = {{ACM Press}},
  address = {{Athens, Greece}},
  doi = {10.1145/3359591.3359737},
  abstract = {Cloud apps like Google Docs and Trello are popular because they enable real-time collaboration with colleagues, and they make it easy for us to access our work from all of our devices. However, by centralizing data storage on servers, cloud apps also take away ownership and agency from users. If a service shuts down, the software stops functioning, and data created with that software is lost.},
  file = {/Users/geoffreylitt/Zotero/storage/DQ4P84XK/Kleppmann et al. - 2019 - Local-first software you own your data, in spite .pdf},
  isbn = {978-1-4503-6995-4},
  language = {en}
}

@inproceedings{klokmose2009,
  title = {{{VIGO}}: Instrumental Interaction in Multi-Surface Environments},
  shorttitle = {{{VIGO}}},
  booktitle = {Proceedings of the 27th International Conference on {{Human}} Factors in Computing Systems - {{CHI}} 09},
  author = {Klokmose, Clemens Nylandsted and {Beaudouin-Lafon}, Michel},
  year = {2009},
  pages = {869},
  publisher = {{ACM Press}},
  address = {{Boston, MA, USA}},
  doi = {10.1145/1518701.1518833},
  abstract = {This paper addresses interaction in multi-surface environments and question whether the current application-centric approaches to user interfaces is adequate in this context and present an alternative approach based on instrumental interaction. The paper presents the VIGO (Views, Instruments, Governors and Objects) architecture and describes a prototype implementation. It then illustrates how to apply VIGO to support distributed interaction. Finally it demonstrates how a classical Ubicomp interaction technique, Pick-and-Drop, can be easily implemented using VIGO.},
  file = {/Users/geoffreylitt/Zotero/storage/T9Q5JJVK/Klokmose and Beaudouin-Lafon - 2009 - VIGO instrumental interaction in multi-surface en.pdf},
  isbn = {978-1-60558-246-7},
  language = {en}
}

@inproceedings{klokmose2015,
  title = {Webstrates: {{Shareable Dynamic Media}}},
  shorttitle = {Webstrates},
  booktitle = {Proceedings of the 28th {{Annual ACM Symposium}} on {{User Interface Software}} \& {{Technology}} - {{UIST}} '15},
  author = {Klokmose, Clemens N. and Eagan, James R. and Baader, Siemen and Mackay, Wendy and {Beaudouin-Lafon}, Michel},
  year = {2015},
  pages = {280--290},
  publisher = {{ACM Press}},
  address = {{Daegu, Kyungpook, Republic of Korea}},
  doi = {10.1145/2807442.2807446},
  abstract = {We revisit Alan Kay's early vision of dynamic media that blurs the distinction between documents and applications. We introduce shareable dynamic media that are malleable by users, who may appropriate them in idiosyncratic ways; shareable among users, who collaborate on multiple aspects of the media; and distributable across diverse devices and platforms. We present Webstrates, an environment for exploring shareable dynamic media. Webstrates augment web technology with real-time sharing. They turn web pages into substrates, i.e. software entities that act as applications or documents depending upon use. We illustrate Webstrates with two implemented case studies: users collaboratively author an article with functionally and visually different editors that they can personalize and extend at run-time; and they orchestrate its presentation and audience participation with multiple devices. We demonstrate the simplicity and generative power of Webstrates with three additional prototypes and evaluate it from a systems perspective.},
  file = {/Users/geoffreylitt/Zotero/storage/PZI6XAMQ/PZI6XAMQ.pdf},
  isbn = {978-1-4503-3779-3},
  language = {en}
}

@article{ko,
  title = {Improving the {{Design}} of {{Visual Programming Language Experiments Using Cognitive Walkthroughs}}},
  author = {Ko, A J},
  pages = {28},
  file = {/Users/geoffreylitt/Zotero/storage/SV7YPI5M/Ko - Improving the Design of Visual Programming Languag.pdf},
  keywords = {study-design},
  language = {en}
}

@inproceedings{ko2003,
  title = {Development and Evaluation of a Model of Programming Errors},
  booktitle = {{{IEEE Symposium}} on {{Human Centric Computing Languages}} and {{Environments}}, 2003. {{Proceedings}}. 2003},
  author = {Ko, A.J. and Myers, B.A.},
  year = {2003},
  pages = {7--14},
  publisher = {{IEEE}},
  address = {{Auckland, New Zealand}},
  doi = {10.1109/HCC.2003.1260196},
  abstract = {Models of programming and debugging suggest many causes of errors, and many classifications of error types exist. Yet, there has been no attempt to link causes of errors to these classifications, nor is there a common vocabulary for reasoning about such causal links. This makes it difficult to compare the abilities of programming styles, languages, and environments to prevent errors. To address this issue, this paper presents a model of programming errors based on past studies of errors. The model was evaluated with two observational of Alice, an event-based programming system, revealing that most errors were due to attentional and strategic problems in implementing algorithms, language constructs, and uses of libraries. In general, the model can support theoretical, design, and educational programming research.},
  file = {/Users/geoffreylitt/Zotero/storage/5HJG9UN8/Ko and Myers - 2003 - Development and evaluation of a model of programmi.pdf},
  isbn = {978-0-7803-8225-1},
  keywords = {toread},
  language = {en}
}

@inproceedings{ko2004,
  title = {Designing the Whyline: A Debugging Interface for Asking Questions about Program Behavior},
  shorttitle = {Designing the Whyline},
  booktitle = {Proceedings of the 2004 Conference on {{Human}} Factors in Computing Systems  - {{CHI}} '04},
  author = {Ko, Andrew J. and Myers, Brad A.},
  year = {2004},
  pages = {151--158},
  publisher = {{ACM Press}},
  address = {{Vienna, Austria}},
  doi = {10.1145/985692.985712},
  abstract = {Debugging is still among the most common and costly of programming activities. One reason is that current debugging tools do not directly support the inquisitive nature of the activity. Interrogative Debugging is a new debugging paradigm in which programmers can ask why did and even why didn't questions directly about their program's runtime failures. The Whyline is a prototype Interrogative Debugging interface for the Alice programming environment that visualizes answers in terms of runtime events directly relevant to a programmer's question. Comparisons of identical debugging scenarios from user tests with and without the Whyline showed that the Whyline reduced debugging time by nearly a factor of 8, and helped programmers complete 40\% more tasks.},
  file = {/Users/geoffreylitt/Zotero/storage/4PRZXVG7/Ko and Myers - 2004 - Designing the whyline a debugging interface for a.pdf},
  isbn = {978-1-58113-702-6},
  keywords = {program visualization},
  language = {en}
}

@inproceedings{ko2005,
  title = {Citrus: A Language and Toolkit for Simplifying the Creation of Structured Editors for Code and Data},
  shorttitle = {Citrus},
  booktitle = {Proceedings of the 18th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology  - {{UIST}} '05},
  author = {Ko, Andrew J. and Myers, Brad A.},
  year = {2005},
  pages = {3},
  publisher = {{ACM Press}},
  address = {{Seattle, WA, USA}},
  doi = {10.1145/1095034.1095037},
  abstract = {Direct-manipulation editors for structured data are increasingly common. While such editors can greatly simplify the creation of structured data, there are few tools to simplify the creation of the editors themselves. This paper presents Citrus, a new programming language and user interface toolkit designed for this purpose. Citrus offers language-level support for constraints, restrictions and change notifications on primitive and aggregate data, mechanisms for automatically creating, removing, and reusing views as data changes, a library of widgets, layouts and behaviors for defining interactive views, and two comprehensive interactive editors as an interface to the language and toolkit itself. Together, these features support the creation of editors for a large class of data and code.},
  file = {/Users/geoffreylitt/Zotero/storage/I4UPPLIT/Ko and Myers - 2005 - Citrus a language and toolkit for simplifying the.pdf},
  isbn = {978-1-59593-271-6},
  keywords = {toread},
  language = {en}
}

@inproceedings{ko2009,
  title = {Finding Causes of Program Output with the {{Java Whyline}}},
  booktitle = {Proceedings of the 27th International Conference on {{Human}} Factors in Computing Systems - {{CHI}} 09},
  author = {Ko, Andrew J. and Myers, Brad A.},
  year = {2009},
  pages = {1569},
  publisher = {{ACM Press}},
  address = {{Boston, MA, USA}},
  doi = {10.1145/1518701.1518942},
  abstract = {Debugging and diagnostic tools are some of the most important software development tools, but most expect developers choose the right code to inspect. Unfortunately, this rarely occurs. A new tool called the Whyline is described which avoids such speculation by allowing developers to select questions about a program's output. The tool then helps developers work backwards from output to its causes. The prototype, which supports Java programs, was evaluated in an experiment in which participants investigated two real bug reports from an open source project using either the Whyline or a breakpoint debugger. Whyline users were successful about three times as often and about twice as fast compared to the control group, and were extremely positive about the tool's ability to simplify diagnostic tasks in software development work.},
  file = {/Users/geoffreylitt/Zotero/storage/24UVP47G/Ko and Myers - 2009 - Finding causes of program output with the Java Why.pdf},
  isbn = {978-1-60558-246-7},
  language = {en}
}

@article{ko2011,
  title = {The State of the Art in End-User Software Engineering},
  author = {Ko, Andrew J. and Myers, Brad and Rosson, Mary Beth and Rothermel, Gregg and Shaw, Mary and Wiedenbeck, Susan and Abraham, Robin and Beckwith, Laura and Blackwell, Alan and Burnett, Margaret and Erwig, Martin and Scaffidi, Chris and Lawrance, Joseph and Lieberman, Henry},
  year = {2011},
  month = apr,
  volume = {43},
  pages = {1--44},
  issn = {03600300},
  doi = {10.1145/1922649.1922658},
  file = {/Users/geoffreylitt/Zotero/storage/HZ2VW3UK/Ko et al. - 2011 - The state of the art in end-user software engineer.pdf},
  journal = {ACM Computing Surveys},
  language = {en},
  number = {3}
}

@article{ko2015,
  title = {A Practical Guide to Controlled Experiments of Software Engineering Tools with Human Participants},
  author = {Ko, Andrew J. and LaToza, Thomas D. and Burnett, Margaret M.},
  year = {2015},
  month = feb,
  volume = {20},
  pages = {110--141},
  issn = {1382-3256, 1573-7616},
  doi = {10.1007/s10664-013-9279-3},
  abstract = {Empirical studies, often in the form of controlled experiments, have been widely adopted in software engineering research as a way to evaluate the merits of new software engineering tools. However, controlled experiments involving human participants actually using new tools are still rare, and when they are conducted, some have serious validity concerns. Recent research has also shown that many software engineering researchers view this form of tool evaluation as too risky and too difficult to conduct, as they might ultimately lead to inconclusive or negative results. In this paper, we aim both to help researchers minimize the risks of this form of tool evaluation, and to increase their quality, by offering practical methodological guidance on designing and running controlled experiments with developers. Our guidance fills gaps in the empirical literature by explaining, from a practical perspective, options in the recruitment and selection of human participants, informed consent, experimental procedures, demographic measurements, group assignment, training, the selecting and design of tasks, the measurement of common outcome variables such as success and time on task, and study debriefing. Throughout, we situate this guidance in the results of a new systematic review of the tool evaluations that were published in over 1,700 software engineering papers published from 2001 to 2011.},
  file = {/Users/geoffreylitt/Zotero/storage/WHTIYII6/Ko et al. - 2015 - A practical guide to controlled experiments of sof.pdf},
  journal = {Empirical Software Engineering},
  keywords = {study-design,toread},
  language = {en},
  number = {1}
}

@incollection{ko2019,
  title = {A {{Study Design Process}}},
  booktitle = {The {{Cambridge Handbook}} of {{Computing Education Research}}},
  author = {Ko, Andrew J. and Fincher, Sally A.},
  editor = {Fincher, Sally A. and Robins, Anthony V.},
  year = {2019},
  month = feb,
  edition = {First},
  pages = {81--101},
  publisher = {{Cambridge University Press}},
  doi = {10.1017/9781108654555.005},
  file = {/Users/geoffreylitt/Zotero/storage/77ETH3AG/Ko and Fincher - 2019 - A Study Design Process.pdf},
  isbn = {978-1-108-65455-5 978-1-108-49673-5 978-1-108-72189-9},
  keywords = {study-design,toread},
  language = {en}
}

@book{koestler1964,
  title = {The {{Act}} of {{Creation}}},
  author = {Koestler, Arthur},
  year = {1964},
  publisher = {{Arkana}},
  abstract = {Astudy of the processes of discovery, invention, imagination and creativity in humor, science, and the arts. It lays out Koestler's attempt to develop an elaborate general theory of human creativity. From describing and comparing many different examples of invention and discovery, Koestler concludes that they all share a common pattern which he terms "bisociation"--A blending of elements drawn from of two previously unrelated matrices of thought into a new matrix of meaning by way of a process involving comparison, abstraction and categorization, analogies and metaphors. He regards many different mental phenomena based on comparison (such as analogies, metaphors, parables, allegories, jokes, identification, role-playing, acting, personification, anthropomorphism etc.), as special cases of "bisociation".},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/The Act of Creation (koestler1964).md},
  googlebooks = {tJC5pDXFY8oC},
  isbn = {978-0-14-019191-2},
  keywords = {Philosophy / General},
  language = {en}
}

@article{koppel2018,
  title = {Capturing the Future by Replaying the Past (Functional Pearl)},
  author = {Koppel, James and Scherer, Gabriel and {Solar-Lezama}, Armando},
  year = {2018},
  month = jul,
  volume = {2},
  pages = {1--29},
  issn = {2475-1421, 2475-1421},
  doi = {10.1145/3236771},
  file = {/Users/geoffreylitt/Zotero/storage/JSF3WTJ8/Koppel et al. - 2018 - Capturing the future by replaying the past (functi.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  number = {ICFP}
}

@inproceedings{koppel2020,
  title = {Demystifying {{Dependence}}},
  booktitle = {Proceedings of the 2020 {{ACM SIGPLAN International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}}},
  author = {Koppel, James and Jackson, Daniel},
  year = {2020},
  month = nov,
  pages = {48--64},
  publisher = {{ACM}},
  address = {{Virtual USA}},
  doi = {10.1145/3426428.3426916},
  abstract = {Programmers are told ``depend on interfaces, not implementations." But, given a program, is it possible even to assess objectively whether such advice has been followed? Programmers frequently talk in ways like this about dependence, but the very term, like many used in software engineering, has hitherto eluded precise definition. In this work, we resolve a variety of confusions about dependence, and present a formal definition unifying multiple varieties of software dependence, grounded in Halpern and Pearl's theory of actual causation. This definition is parameterized by the formal system characterizing the property of interest, and by constraints on ``reasonable changes" to the program. By picking different choices of formal system, one can specialize the definition to characterize several notions of dependence, including build, correctness, and performance dependences. Overall, our work provides a path to making conversations about software dependence fully objective, and might serve as a basis for future work that automatically checks forms of dependence that were previously too abstract or high-level to be candidates for tools.},
  file = {/Users/geoffreylitt/Zotero/storage/KRQG6LKK/demystifying_dependence_published.pdf},
  isbn = {978-1-4503-8178-9},
  language = {en}
}

@book{kors2020,
  title = {The Curious Case of the Transdiegetic Cow, or a Mission to Foster Other-Oriented Empathy through Virtual Reality},
  author = {Kors, Martijn JL and {van der Spek}, Erik D and Bopp, Julia Ayumi and Millenaar, Karel and {van Teutem}, Rutger L and Ferri, Gabriele and Schouten, Ben AM M},
  year = {2020},
  publisher = {{Association for Computing Machinery}},
  abstract = {Socially aware persuasive games that use immersive technologies often appeal to empathy, prompting users to feel and understand the struggles of another. However, the often sought-after standing in another's shoes' experience, in which users virtually inhabit another in distress, may complicate other-oriented empathy. Following a Research through Design approach, we designed for other-oriented empathy - focusing on a partaker-perspective and diegetic reflection - which resulted in Permanent; a virtual reality game designed to foster empathy towards evacuees from the 2011 Fukushima Daiichi nuclear disaster. We deployed Permanent 'in the wild' and carried out a qualitative study with 78 participants in the Netherlands and Japan to capture user experiences. Content Analysis of the data showed a predominance of other-oriented empathy across countries, and in our Thematic Analysis, we identified the themes of 'Spatial, Other, and Self -Awareness', 'Personal Accounts', 'Ambivalence', and 'Transdiegetic Items', resulting in design insights for fostering other-oriented empathy through virtual reality.},
  annotation = {OCLC: 8622110641},
  file = {/Users/geoffreylitt/Zotero/storage/PTMLVVCM/Kors et al. - 2020 - The curious case of the transdiegetic cow, or a mi.pdf},
  isbn = {978-1-4503-6708-0},
  language = {en}
}

@incollection{kraut2012,
  title = {Evidence-Based {{Social Design}}: {{Introduction}}},
  booktitle = {Evidence-{{Based Social Design}}: {{Mining}} the {{Social Sciences}} to {{Build Online Communities}}},
  author = {Kraut, Robert E. and Resnick, Paul},
  year = {2012},
  publisher = {{MIT Press}},
  address = {{Cambridge, MA}},
  isbn = {978-0-262-29831-5},
  language = {en}
}

@inproceedings{kumar2012,
  title = {Data-Driven {{Web Design}}},
  booktitle = {Proceedings of the 29 Th {{International Conference}} on {{Machine Learning}}},
  author = {Kumar, Ranjitha and Talton, Jerry O. and Ahmad, Salman and Klemmer, Scott R.},
  year = {2012},
  pages = {2},
  address = {{Edinburgh, Scotland}},
  abstract = {This short paper summarizes challenges and opportunities of applying machine learning methods to Web design problems, and describes how structured prediction, deep learning, and probabilistic program induction can enable useful interactions for designers. We intend for these techniques to foster new work in data-driven Web design.},
  language = {en}
}

@article{lampson,
  title = {Hints and {{Principles}} for {{Computer System Design}}},
  author = {Lampson, Butler},
  pages = {106},
  abstract = {This new long version of my 1983 paper suggests the goals you might have for your system\textemdash Simple, Timely, Efficient, Adaptable, Dependable, Yummy (STEADY)\textemdash and techniques for achieving them\textemdash Approximate, Incremental, Divide \& Conquer (AID). It also gives some principles for system design that are more than just hints, and many examples of how to apply the ideas.},
  file = {/Users/geoffreylitt/Zotero/storage/8MC7GGAR/Lampson - Hints and Principles for Computer System Design.pdf},
  language = {en}
}

@inproceedings{larsen-ledet2020,
  title = {Collaborative {{Writing Across Multiple Artifact Ecologies}}},
  booktitle = {Proceedings of the 2020 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {{Larsen-Ledet}, Ida and Korsgaard, Henrik and B{\o}dker, Susanne},
  year = {2020},
  month = apr,
  pages = {1--14},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3313831.3376422},
  abstract = {Research focusing on how collaborative writing takes place across multiple applications and devices and over longer projects is sparse. We respond to this gap by presenting the results of a qualitative study of longer-term academic writing projects, showing how co-writers employ multiple tools when working on a common text. We identify three patterns of multi-application collaboration as well as four common types of motivations for transitions between applications. We also extend existing taxonomies of collaborative writing by proposing a categorization of the functions served by the text as object and backbone of the collaboration. Together, these contributions offer a framing for understanding transitions within and across artifact ecologies in work around a common object. Our findings highlight ways in which features like concurrent editing may in fact challenge the collaborative writing process, and we point to opportunities for alternative application models.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/larsen-ledet2020.md;/Users/geoffreylitt/Zotero/storage/ZCHVVSGR/ZCHVVSGR.pdf},
  isbn = {978-1-4503-6708-0},
  keywords = {academic writing,aligned artifact ecology,artifact ecology,collaboration,collaborative academic writing,collaborative writing,computer-supported cooperative work,cscw,github,google docs,latex,overleaf,personal artifact ecology,potential artifact ecology,sharelatex,text function},
  series = {{{CHI}} '20}
}

@misc{leach,
  title = {{{APIs}} as Infrastructure: Future-Proofing {{Stripe}} with Versioning},
  shorttitle = {{{APIs}} as Infrastructure},
  author = {Leach, Brandur},
  abstract = {Online payment processing for internet businesses. Stripe is a suite of payment APIs that powers commerce for businesses of all sizes.},
  file = {/Users/geoffreylitt/Zotero/storage/RM9FHKKE/api-versioning.html},
  howpublished = {https://stripe.com/blog/api-versioning},
  language = {en}
}

@article{lerner,
  title = {Projection {{Boxes}}: {{On}}-the-Fly {{Reconfigurable Visualization}} for {{Live Programming}}},
  author = {Lerner, Sorin},
  pages = {7},
  abstract = {Live programming is a regime in which the programming environment provides continual feedback, most often in the form of runtime values. In this paper, we present Projection Boxes, a novel visualization technique for displaying runtime values of programs. The key idea behind projection boxes is to start with a full semantics of the program, and then use projections to pick a subset of the semantics to display. By varying the projection used, projection boxes can encode both previously known visualization techniques, and also new ones. As such, projection boxes provide an expressive and configurable framework for displaying runtime information. Through a user study we demonstrate that (1) users find projection boxes and their configurability useful (2) users are not distracted by the always-on visualization (3) a key driving force behind the need for a configurable visualization for live programming lies with the wide variation in programmer preferences.},
  file = {/Users/geoffreylitt/Zotero/storage/N3IBF8AI/Lerner - Projection Boxes On-the-fly Reconfigurable Visual.pdf},
  keywords = {program visualization},
  language = {en}
}

@inproceedings{lerner2020,
  title = {Projection {{Boxes}}: {{On}}-the-Fly {{Reconfigurable Visualization}} for {{Live Programming}}},
  shorttitle = {Projection {{Boxes}}},
  booktitle = {Proceedings of the 2020 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Lerner, Sorin},
  year = {2020},
  publisher = {{Association for Computing Machinery}},
  doi = {10.1145/3313831.3376494},
  abstract = {Live programming is a regime in which the programming environment provides continual feedback, most often in the form of runtime values. In this paper, we present Projection Boxes, a novel visualization technique for displaying runtime values of programs. The key idea behind projection boxes is to start with a full semantics of the program, and then use projections to pick a subset of the semantics to display. By varying the projection used, projection boxes can encode both previously known visualization techniques, and also new ones. As such, projection boxes provide an expressive and configurable framework for displaying runtime information. Through a user study we demonstrate that (1) users find projection boxes and their configurability useful (2) users are not distracted by the always-on visualization (3) a key driving force behind the need for a configurable visualization for live programming lies with the wide variation in programmer preferences.}
}

@inproceedings{lerner2020a,
  title = {Focused {{Live Programming}} with {{Loop Seeds}}},
  booktitle = {Proceedings of the 33rd {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  author = {Lerner, Sorin},
  year = {2020},
  month = oct,
  pages = {607--613},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3379337.3415834},
  abstract = {Live programming is a paradigm in which the programmer can visualize the runtime values of the program each time the program changes. The promise of live programming depends on using test cases to run the program and thereby provide these runtime values. In this paper we show that in some situations test cases are insufficient in a fundamental way, in that there are no test inputs that can drive certain incomplete loops to produce useful data, a problem we call the loop-datavoid problem. The problem stems from the fact that useful data inside the loop might only be produced after the loop has been fully written. To solve this problem, we propose a paradigm called Focused Live Programming with Loop Seeds, in which the programmer provides hypothetical values to start a loop iteration, and then the programming environment focuses the live visualization on this hypothetical loop iteration. We introduce the loop-datavoid problem, present our proposed solution, explain it in detail, and then present the results of a user study.},
  file = {/Users/geoffreylitt/Zotero/storage/X36D2XUJ/Lerner - 2020 - Focused Live Programming with Loop Seeds.pdf},
  isbn = {978-1-4503-7514-6},
  keywords = {debugging,live programming,program testing},
  series = {{{UIST}} '20}
}

@inproceedings{lerner2020b,
  title = {Projection {{Boxes}}: {{On}}-the-Fly {{Reconfigurable Visualization}} for {{Live Programming}}},
  shorttitle = {Projection {{Boxes}}},
  booktitle = {Proceedings of the 2020 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Lerner, Sorin},
  year = {2020},
  month = apr,
  pages = {1--7},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3313831.3376494},
  abstract = {Live programming is a regime in which the programming environment provides continual feedback, most often in the form of runtime values. In this paper, we present Projection Boxes, a novel visualization technique for displaying runtime values of programs. The key idea behind projection boxes is to start with a full semantics of the program, and then use projections to pick a subset of the semantics to display. By varying the projection used, projection boxes can encode both previously known visualization techniques, and also new ones. As such, projection boxes provide an expressive and configurable framework for displaying runtime information. Through a user study we demonstrate that (1) users find projection boxes and their configurability useful (2) users are not distracted by the always-on visualization (3) a key driving force behind the need for a configurable visualization for live programming lies with the wide variation in programmer preferences.},
  file = {/Users/geoffreylitt/Zotero/storage/Z4HQ9C5U/Lerner - 2020 - Projection Boxes On-the-fly Reconfigurable Visual.pdf},
  isbn = {978-1-4503-6708-0},
  keywords = {debugging,live programming,program visualization,programming environment},
  series = {{{CHI}} '20}
}

@inproceedings{leshed2008,
  title = {{{CoScripter}}: {{Automating}} \& {{Sharing How}}-to {{Knowledge}} in the {{Enterprise}}},
  shorttitle = {{{CoScripter}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Leshed, Gilly and Haber, Eben M. and Matthews, Tara and Lau, Tessa},
  year = {2008},
  pages = {1719--1728},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1357054.1357323},
  abstract = {Modern enterprises are replete with numerous online processes. Many must be performed frequently and are tedious, while others are done less frequently yet are complex or hard to remember. We present interviews with knowledge workers that reveal a need for mechanisms to automate the execution of and to share knowledge about these processes. In response, we have developed the CoScripter system (formerly Koala [11]), a collaborative scripting environment for recording, automating, and sharing web-based processes. We have deployed CoScripter within a large corporation for more than 10 months. Through usage log analysis and interviews with users, we show that CoScripter has addressed many user automation and sharing needs, to the extent that more than 50 employees have voluntarily incorporated it into their work practice. We also present ways people have used CoScripter and general issues for tools that support automation and sharing of how-to knowledge.},
  file = {/Users/geoffreylitt/Zotero/storage/RHE55DIG/Leshed et al. - 2008 - CoScripter Automating & Sharing How-to Knowledge .pdf},
  isbn = {978-1-60558-011-1},
  keywords = {automation,knowledge sharing,procedural knowledge,programming-by-demonstration,scripting,user study,wiki},
  series = {{{CHI}} '08}
}

@misc{levien2017,
  title = {Towards a Unified Theory of {{Operational Transformation}} and {{CRDT}}},
  author = {Levien, Raph},
  year = {2017},
  month = mar,
  abstract = {Update (2 Mar 2017): there is now working code for the ideas in this post, with additional optimizations.},
  file = {/Users/geoffreylitt/Zotero/storage/SF53D9JT/towards-a-unified-theory-of-operational-transformation-and-crdt-70485876f72f.html},
  howpublished = {https://medium.com/@raphlinus/towards-a-unified-theory-of-operational-transformation-and-crdt-70485876f72f},
  journal = {Medium},
  keywords = {crdt},
  language = {en}
}

@article{lew2019,
  title = {Trace Types and Denotational Semantics for Sound Programmable Inference in Probabilistic Languages},
  author = {Lew, Alexander K. and {Cusumano-Towner}, Marco F. and Sherman, Benjamin and Carbin, Michael and Mansinghka, Vikash K.},
  year = {2019},
  month = dec,
  volume = {4},
  pages = {1--32},
  issn = {24751421},
  doi = {10.1145/3371087},
  abstract = {ALEXANDER K. LEW, Massachusetts Institute of Technology, USA MARCO F. CUSUMANO-TOWNER, Massachusetts Institute of Technology, USA BENJAMIN SHERMAN, Massachusetts Institute of Technology, USA MICHAEL CARBIN, Massachusetts Institute of Technology, USA VIKASH K. MANSINGHKA, Massachusetts Institute of Technology, USA Modern probabilistic programming languages aim to formalize and automate key aspects of probabilistic modeling and inference. Many languages provide constructs for programmable inference that enable developers 19 to improve inference speed and accuracy by tailoring an algorithm for use with a particular model or dataset. Unfortunately, it is easy to use these constructs to write unsound programs that appear to run correctly but produce incorrect results. To address this problem, we present a denotational semantics for programmable inference in higher-order probabilistic programming languages, along with a type system that ensures that well-typed inference programs are sound by construction. A central insight is that the type of a probabilistic expression can track the space of its possible execution traces, not just the type of value that it returns, as these traces are often the objects that inference algorithms manipulate. We use our semantics and type system to establish soundness properties of custom inference programs that use constructs for variational, sequential Monte Carlo, importance sampling, and Markov chain Monte Carlo inference. CCS Concepts: {$\cdot$} Mathematics of computing \textrightarrow{} Probabilistic inference problems; Variational methods; Metropolis-Hastings algorithm; Sequential Monte Carlo methods; {$\cdot$} Theory of computation \textrightarrow{} Semantics and reasoning; Denotational semantics; {$\cdot$} Software and its engineering \textrightarrow{} Formal language definitions.},
  file = {/Users/geoffreylitt/Zotero/storage/RTHTYZ7Y/Lew et al. - 2019 - Trace types and denotational semantics for sound p.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  keywords = {toread},
  language = {en},
  number = {POPL}
}

@article{licklider1960,
  title = {Man-{{Computer Symbiosis}}},
  author = {Licklider, J.C.R.},
  year = {1960},
  month = mar,
  pages = {4--11},
  abstract = {Man-computer symbiosis is an expected development in cooperative interaction between men and electronic computers. It will involve very close coupling between the human and the electronic members of the partnership. The main aims are 1) to let computers facilitate formulative thinking as they now facilitate the solution of formulated problems, and 2) to enable men and computers to cooperate in making decisions and controlling complex situations without inflexible dependence on predetermined programs. In the anticipated symbiotic partnership, men will set the goals, formulate the hypotheses, determine the criteria, and perform the evaluations. Computing machines will do the routinizable work that must be done to prepare the way for insights and decisions in technical and scientific thinking. Preliminary analyses indicate that the symbiotic partnership will perform intellectual operations much more effectively than man alone can perform them. Prerequisites for the achievement of the effective, cooperative association include developments in computer time sharing, in memory components, in memory organization, in programming languages, and in input and output equipment.},
  journal = {IEEE Transactions on Human Factors in Electronics},
  language = {en}
}

@inproceedings{lieber2014,
  title = {Addressing Misconceptions about Code with Always-on Programming Visualizations},
  booktitle = {Proceedings of the 32nd Annual {{ACM}} Conference on {{Human}} Factors in Computing Systems - {{CHI}} '14},
  author = {Lieber, Tom and Brandt, Joel R. and Miller, Rob C.},
  year = {2014},
  pages = {2481--2490},
  publisher = {{ACM Press}},
  address = {{Toronto, Ontario, Canada}},
  doi = {10.1145/2556288.2557409},
  abstract = {We present Theseus, an IDE extension that visualizes run\- time behavior within a JavaScript code editor. By displaying real-time information about how code actually behaves dur\- ing execution, Theseus proactively addresses misconceptions by drawing attention to similarities and differences between the programmer's idea of what code does and what it actu\- ally does. To understand how programmers would respond to this kind of an always-on visualization, we ran a lab study with graduate students, and interviewed 9 professional pro\- grammers who were asked to use Theseus in their day-to-day work. We found that users quickly adopted strategies that are unique to always-on, real-time visualizations, and used the additional information to guide their navigation through their code.},
  file = {/Users/geoffreylitt/Zotero/storage/44LDG267/Lieber et al. - 2014 - Addressing misconceptions about code with always-o.pdf},
  isbn = {978-1-4503-2473-1},
  language = {en}
}

@misc{lieberman,
  title = {The {{Tyranny}} of {{Evaluation}}},
  author = {Lieberman, Henry},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/The Tyranny of Evaluation (lieberman).md;/Users/geoffreylitt/Zotero/storage/MQDKYBEY/Tyranny-Evaluation.html},
  howpublished = {https://web.media.mit.edu/\textasciitilde lieber/Misc/Tyranny-Evaluation.html}
}

@inproceedings{lieberman1995,
  title = {Bridging the Gulf between Code and Behavior in Programming},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Lieberman, Henry and Fry, Christopher},
  year = {1995},
  month = may,
  pages = {480--486},
  publisher = {{ACM Press/Addison-Wesley Publishing Co.}},
  address = {{Denver, Colorado, USA}},
  doi = {10.1145/223904.223969},
  file = {/Users/geoffreylitt/Zotero/storage/JWRH7SCN/Lieberman and Fry - 1995 - Bridging the gulf between code and behavior in pro.pdf},
  isbn = {978-0-201-84705-5},
  keywords = {program visualization},
  series = {{{CHI}} '95}
}

@incollection{lieberman2010,
  title = {Knowing What You're Talking About},
  booktitle = {No {{Code Required}}},
  author = {Lieberman, Henry and Ahmad, Moin},
  year = {2010},
  pages = {331--343},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00017-1},
  abstract = {Enabling end users to express programs in natural language would result in a dramatic increase in accessibility. Previous efforts in natural language programming have been hampered by the apparent ambiguity of natural language. We believe a large part of the solution to this problem is knowing what you're talking about \textendash{} introducing enough semantics about the subject matter of the programs to provide sufficient context for understanding.},
  file = {/Users/geoffreylitt/Zotero/storage/F5ZBRPZU/Lieberman and Ahmad - 2010 - Knowing what you're talking about.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@misc{liebermana,
  title = {{{ZStep}} 95: {{A Reversible}}, {{Animated Stepper}}},
  author = {Lieberman, Henry},
  file = {/Users/geoffreylitt/Zotero/storage/SXF5XH2N/ZStep-SoftViz.html},
  howpublished = {http://web.media.mit.edu/\textasciitilde lieber/Lieberary/ZStep/ZStep-SoftViz/ZStep-SoftViz.html},
  keywords = {program visualization}
}

@article{linden2003,
  title = {Amazon.Com {{Recommendations}}: {{Item}}-to-{{Item Collaborative Filtering}}},
  shorttitle = {Amazon.Com {{Recommendations}}},
  author = {Linden, Greg and Smith, Brent and York, Jeremy},
  year = {2003},
  month = jan,
  volume = {7},
  pages = {76--80},
  issn = {1089-7801},
  doi = {10.1109/MIC.2003.1167344},
  journal = {IEEE Internet Computing},
  language = {en},
  number = {1}
}

@inproceedings{litt2018,
  title = {Margin {{Notes}}: {{Automatic}} Code Documentation with Recorded Examples from Runtime},
  booktitle = {{{LIVE}} 2018 {{Workshop}} at {{SPLASH}}},
  author = {Litt, Geoffrey},
  year = {2018},
  abstract = {Programmers working on large codebases frequently need to understand APIs for existing code. Manual documentation is helpful, but takes time to maintain and often doesn't include enough examples. Margin Notes automatically generates code documentation by recording example data from function calls as a program executes and displaying those examples in an interactive UI next to the code. This allows programmers to quickly view many examples from past executions as they read the code, helping them efficiently gain insight into the behavior of the program.}
}

@inproceedings{litt2020,
  title = {Wildcard: {{Spreadsheet}}-{{Driven Customization}} of {{Web Applications}}},
  booktitle = {Companion {{Proceedings}} of the 4th {{International Conference}} on the {{Art}}, {{Science}}, and {{Engineering}} of {{Programming}}},
  author = {Litt, Geoffrey and Jackson, Daniel},
  year = {2020},
  pages = {10},
  publisher = {{Association for Computing Machinery}},
  address = {{Porto, Portugal.}},
  doi = {10.1145/3397537.3397541},
  abstract = {Many Web applications do not meet the precise needs of their users. Browser extensions offer a way to customize web applications, but most people do not have the programming skills to implement their own extensions.},
  file = {/Users/geoffreylitt/Zotero/storage/SWZK2S4B/Litt and Jackson - 2020 - Wildcard Spreadsheet-Driven Customization of Web .pdf},
  language = {en}
}

@inproceedings{litt2020b,
  title = {End-User {{Software Customization}} by {{Direct Manipulation}} of {{Tabular Data}}},
  booktitle = {Proceedings of the 2020 {{ACM SIGPLAN International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}}},
  author = {Litt, Geoffrey and Jackson, Daniel and Millis, Tyler and Quaye, Jessica},
  year = {2020},
  month = nov,
  pages = {18--33},
  publisher = {{ACM}},
  address = {{Virtual USA}},
  doi = {10.1145/3426428.3426914},
  abstract = {Customizing software should be as easy as using it. Unfortunately, most customization methods require users to abruptly shift from using a graphical interface to writing scripts in a programming language.},
  file = {/Users/geoffreylitt/Zotero/storage/ZP6CLN89/Litt et al. - 2020 - End-user software customization by direct manipula.pdf},
  isbn = {978-1-4503-8178-9},
  language = {en}
}

@incollection{little2010,
  title = {Sloppy Programming},
  booktitle = {No {{Code Required}}},
  author = {Little, Greg and Miller, Robert C. and Chou, Victoria H. and Bernstein, Michael and Lau, Tessa and Cypher, Allen},
  year = {2010},
  pages = {289--307},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00015-8},
  abstract = {Modern applications provide interfaces for scripting, but many users do not know how to write script commands. However, many users are familiar with the idea of entering keywords into a Web search engine. Hence, if a user is familiar with the vocabulary of an application domain, we anticipate that they could write a set of keywords expressing a command in that domain. For instance, in the Web browsing domain, a user might enter ``click search button''. We call loosely grammatical commands of this sort ``sloppy commands.'' We discuss several prototypes that implement sloppy programming, translating sloppy commands directly into executable code. We also discuss the algorithms used in these prototypes, expose their limitations, and propose directions for future work.},
  file = {/Users/geoffreylitt/Zotero/storage/GBFFTC6G/Little et al. - 2010 - Sloppy programming.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@incollection{little2010a,
  title = {Sloppy Programming},
  booktitle = {No {{Code Required}}},
  author = {Little, Greg and Miller, Robert C. and Chou, Victoria H. and Bernstein, Michael and Lau, Tessa and Cypher, Allen},
  year = {2010},
  pages = {289--307},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00015-8},
  abstract = {Modern applications provide interfaces for scripting, but many users do not know how to write script commands. However, many users are familiar with the idea of entering keywords into a Web search engine. Hence, if a user is familiar with the vocabulary of an application domain, we anticipate that they could write a set of keywords expressing a command in that domain. For instance, in the Web browsing domain, a user might enter ``click search button''. We call loosely grammatical commands of this sort ``sloppy commands.'' We discuss several prototypes that implement sloppy programming, translating sloppy commands directly into executable code. We also discuss the algorithms used in these prototypes, expose their limitations, and propose directions for future work.},
  file = {/Users/geoffreylitt/Zotero/storage/KHYJZVJD/Little et al. - 2010 - Sloppy programming.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@inproceedings{liu2009,
  title = {A {{Spreadsheet Algebra}} for a {{Direct Data Manipulation Query Interface}}},
  booktitle = {2009 {{IEEE}} 25th {{International Conference}} on {{Data Engineering}}},
  author = {Liu, Bin and Jagadish, H. V.},
  year = {2009},
  month = mar,
  pages = {417--428},
  issn = {2375-026X},
  doi = {10.1109/ICDE.2009.34},
  abstract = {A spreadsheet-like "direct manipulation" interface is more intuitive for many non-technical database users compared to traditional alternatives, such as visual query builders. The construction of such a direct manipulation interface may appear straightforward, but there are some significant challenges. First, individual direct manipulation operations cannot be too complex, so expressive power has to be achieved through composing (long) sequences of small operations. Second, all intermediate results are visible to the user, so grouping and ordering are material after every small step. Third, users often find the need to modify previously specified queries. Since manipulations are specified one step at a time, there is no actual queryexpression to modify. Suitable means must be provided to address this need. Fourth, the order in which manipulations are performed by the user should not affect the results obtained, to avoid user confusion. We address the aforementioned challenges by designing a new spreadsheet algebra that: i) operates on recursively grouped multi-sets, ii) contains a selectively designed set of operators capable of expressing at least all single-block SQL queries and can be intuitively implemented in a spreadsheet, iii) enables query modification by the notion of modifiable query state, and iv) requires no ordering in unary data manipulation operators since they are all designed to commute. We built a prototype implementation of the spreadsheet algebra and show, through user studies with non-technical subjects, that the resultant query interface is easier to use than a standard commercial visual query builder.},
  file = {/Users/geoffreylitt/Zotero/storage/M3AFJ2UA/Liu and Jagadish - 2009 - A Spreadsheet Algebra for a Direct Data Manipulati.pdf;/Users/geoffreylitt/Zotero/storage/576BWR2D/4812422.html},
  keywords = {Algebra,Data analysis,Data engineering,database usability,direct data manipulation query interface,Humans,Presses,Prototypes,query processing,Relational databases,single-block SQL queries,spreadsheet,spreadsheet algebra,spreadsheet programs,Spreadsheet programs,SQL,USA Councils,user interface,Visual databases,visual query builders}
}

@inproceedings{liu2018,
  title = {Somewhere {{Over}} the {{Rainbow}}: {{An Empirical Assessment}} of {{Quantitative Colormaps}}},
  shorttitle = {Somewhere {{Over}} the {{Rainbow}}},
  booktitle = {Proceedings of the 2018 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}  - {{CHI}} '18},
  author = {Liu, Yang and Heer, Jeffrey},
  year = {2018},
  pages = {1--12},
  publisher = {{ACM Press}},
  address = {{Montreal, Canada}},
  doi = {10.1145/3173574.3174172},
  abstract = {An essential goal of quantitative color encoding is the accurate mapping of perceptual dimensions of color to the logical structure of data. Prior research identifies weaknesses of ``rainbow'' colormaps and advocates for ramping in luminance, while recent work contributes multi-hue colormaps generated using perceptually-uniform color models. We contribute a comparative analysis of different colormap types, with a focus on comparing single- and multi-hue schemes. We present a suite of experiments in which subjects perform relative distance judgments among color triplets drawn systematically from each of four single-hue and five multi-hue colormaps. We characterize speed and accuracy across each colormap, and identify conditions that degrade performance. We also find that a combination of perceptual color space and color naming measures more accurately predict user performance than either alone, though the overall accuracy is poor. Based on these results, we distill recommendations on how to design more effective color encodings for scalar data.},
  isbn = {978-1-4503-5620-6},
  language = {en}
}

@article{lubin2020,
  title = {Program {{Sketching}} with {{Live Bidirectional Evaluation}}},
  author = {Lubin, Justin and Collins, Nick and Omar, Cyrus and Chugh, Ravi},
  year = {2020},
  month = aug,
  volume = {4},
  pages = {1--29},
  issn = {2475-1421, 2475-1421},
  doi = {10.1145/3408991},
  abstract = {We present a system called Smyth for program sketching in a typed functional language whereby the concrete evaluation of ordinary assertions gives rise to input-output examples, which are then used to guide the search to complete the holes. The key innovation, called live bidirectional evaluation, propagates examples ``backward'' through partially evaluated sketches. Live bidirectional evaluation enables Smyth to (a) synthesize recursive functions without trace-complete sets of examples and (b) specify and solve interdependent synthesis goals. Eliminating the trace-completeness requirement resolves a significant limitation faced by prior synthesis techniques when given partial specifications in the form of input-output examples. To assess the practical implications of our techniques, we ran several experiments on benchmarks used to evaluate Myth, a state-of-the-art example-based synthesis tool. First, given expert examples (and no partial implementations), we find that Smyth requires on average 66\% of the number of expert examples required by Myth. Second, we find that Smyth is robust to randomly-generated examples, synthesizing many tasks with relatively few more random examples than those provided by an expert. Third, we create a suite of small sketching tasks by systematically employing a simple sketching strategy to the Myth benchmarks; we find that user-provided sketches in Smyth often further reduce the total specification burden (i.e. the combination of partial implementations and examples). Lastly, we find that Leon and Synqid, two state-of-the-art logic-based synthesis tools, fail to complete several tasks on which Smyth succeeds. CCS Concepts: \textbullet{} Software and its engineering \textrightarrow{} General programming languages; Programming by example; Search-based software engineering; Automatic programming; \textbullet{} Theory of computation \textrightarrow{} Type theory.},
  archivePrefix = {arXiv},
  eprint = {1911.00583},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/7PMH4DED/Lubin et al. - 2020 - Program Sketching with Live Bidirectional Evaluati.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  keywords = {Computer Science - Programming Languages,program synthesis,toread},
  language = {en},
  number = {ICFP}
}

@incollection{lunzer2010,
  title = {Subjunctive Interfaces for the {{Web}}},
  booktitle = {No {{Code Required}}},
  author = {Lunzer, Aran and Hornb{\ae}k, Kasper},
  year = {2010},
  pages = {267--285},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00014-6},
  abstract = {The data resources and applications accessible through today's Web offer tremendous opportunities for exploration: ask a slightly different question, receive a correspondingly different answer. However, typical browser-based mechanisms for accessing the Web only enable users to pose one such question at a time, placing a heavy operational and cognitive burden on any user who wants to explore and compare alternatives. A subjunctive-interface approach may reduce this burden. Subjunctive interfaces support the setting up, viewing, and adjustment of multiple scenarios in parallel, allowing side-by-side instead of temporally separated viewing, and more efficient iteration through alternatives. We have implemented a spreadsheet-inspired environment where end users can program and use their own Web-access applications that include such multiscenario support. In this chapter we describe three modes of use of this environment \textendash{} parallel retrieval, coordinated manipulation, and tentative composition \textendash{} and explain how these may help to alleviate typical challenges in Web-based tasks. At the same time, we acknowledge that the increased scope for exploration made possible through this environment can itself present a form of cognitive burden to users, and we outline our plans for evaluating the impact of this effect.},
  file = {/Users/geoffreylitt/Zotero/storage/64PD9CGV/Lunzer and Hornbæk - 2010 - Subjunctive interfaces for the Web.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@inproceedings{mackay1991,
  title = {Triggers and Barriers to Customizing Software},
  booktitle = {Proceedings of the {{SIGCHI}} Conference on {{Human}} Factors in Computing Systems {{Reaching}} through Technology - {{CHI}} '91},
  author = {Mackay, Wendy E.},
  year = {1991},
  pages = {153--160},
  publisher = {{ACM Press}},
  address = {{New Orleans, Louisiana, United States}},
  doi = {10.1145/108844.108867},
  abstract = {One of the properties of a user interface is that it both guides and constrains the patterns of interaction between the user and the software application. Application software is increasingly designed to be ``customizable'' by the end user, providing specific mechanisms by which users may specify individual preferences about the software and how they will interact with it over multiple sessions. Users may thus encode and preserve their preferred patterns of use. These customizations, together with choices about which applications to use, make up the unique ``softswue environment'' for each individual.},
  file = {/Users/geoffreylitt/Zotero/storage/CEKJFXHF/Mackay - 1991 - Triggers and barriers to customizing software.pdf},
  isbn = {978-0-89791-383-6},
  language = {en}
}

@article{mackaywendy,
  title = {Patterns of Sharing Customizable Software},
  author = {{Mackay, Wendy}},
  file = {/Users/geoffreylitt/Zotero/storage/IWR3FBNK/99332.99356.pdf}
}

@article{mackenzie1992,
  title = {Fitt's {{Law}} as {{Research}} and {{Design Tool}} in {{Human}}-{{Computer Interaction}}},
  author = {Mackenzie, I. Scott},
  year = {1992},
  volume = {7},
  pages = {91--139},
  journal = {Human-Computer Interaction}
}

@article{mackinlay1986,
  title = {Automating the Design of Graphical Presentations of Relational Information},
  author = {Mackinlay, Jock},
  year = {1986},
  month = apr,
  volume = {5},
  pages = {110--141},
  issn = {07300301},
  doi = {10.1145/22949.22950},
  journal = {ACM Transactions on Graphics},
  language = {en},
  number = {2}
}

@inproceedings{maclean1990,
  title = {User-Tailorable Systems: Pressing the Issues with Buttons},
  shorttitle = {User-Tailorable Systems},
  booktitle = {Proceedings of the {{SIGCHI}} Conference on {{Human}} Factors in Computing Systems {{Empowering}} People - {{CHI}} '90},
  author = {MacLean, Allan and Carter, Kathleen and L{\"o}vstrand, Lennart and Moran, Thomas},
  year = {1990},
  pages = {175--182},
  publisher = {{ACM Press}},
  address = {{Seattle, Washington, United States}},
  doi = {10.1145/97243.97271},
  abstract = {It is impossible to design systems which are appropriate for all users and ail situations. We believe that a useful technique is to have end users tailor their systems to match their personal work practices. This requires not only systems which can be tailored, but a culture within which users feel in control of the system and in which tailoring is the norm. In a two-pronged research project we have worked closely with a group of users to develop a system to support tailoring and to help the users evolve a ``tailoring culture''. This has resulted in a flexible system based around the use of distributed on-screen Buttons to support a range of tailoring techniques.},
  file = {/Users/geoffreylitt/Zotero/storage/PT5BEQ7D/MacLean et al. - 1990 - User-tailorable systems pressing the issues with .pdf},
  isbn = {978-0-201-50932-8},
  language = {en}
}

@article{madsen,
  title = {A {{Semantics}} for the {{Essence}} of {{React David R}}. {{Cheriton School}} of {{Computer Science Technical Report CS}}-2020-03},
  author = {Madsen, Magnus and Lhot{\'a}k, Ondrej and Tip, Frank},
  pages = {37},
  abstract = {Traditionally, web applications have been written as HTML pages with embedded JavaScript code that implements dynamic and interactive features by manipulating the Document Object Model (DOM) through a low-level browser API. However, this unprincipled approach leads to code that is brittle, difficult to understand, non-modular, and does not facilitate incremental update of user-interfaces in response to state changes.},
  file = {/Users/geoffreylitt/Zotero/storage/HWA5IHMR/Madsen et al. - A Semantics for the Essence of React David R. Cher.pdf},
  language = {en}
}

@inproceedings{marquardt2011,
  title = {The {{Proximity Toolkit}}: {{Prototyping Proxemic Interactions}} in {{Ubiquitous Computing Ecologies}}},
  shorttitle = {The {{Proximity Toolkit}}},
  booktitle = {Proceedings of the 24th {{Annual Acm Symposium}} on {{User Interface Software}} and {{Technology}} - {{UIST}} '11},
  author = {Marquardt, Nicolai and {Diaz-Marino}, Robert and Boring, Sebastian and Greenberg, Saul},
  year = {2011},
  pages = {315},
  publisher = {{ACM Press}},
  address = {{Santa Barbara, California, USA}},
  doi = {10.1145/2047196.2047238},
  abstract = {People naturally understand and use proxemic relationships (e.g., their distance and orientation towards others) in everyday situations. However, only few ubiquitous computing (ubicomp) systems interpret such proxemic relationships to mediate interaction (proxemic interaction). A technical problem is that developers find it challenging and tedious to access proxemic information from sensors. Our Proximity Toolkit solves this problem. It simplifies the exploration of interaction techniques by supplying fine-grained proxemic information between people, portable devices, large interactive surfaces, and other non-digital objects in a room-sized environment. The toolkit offers three key features. 1) It facilitates rapid prototyping of proxemic-aware systems by supplying developers with the orientation, distance, motion, identity, and location information between entities. 2) It includes various tools, such as a visual monitoring tool, that allows developers to visually observe, record and explore proxemic relationships in 3D space. (3) Its flexible architecture separates sensing hardware from the proxemic data model derived from these sensors, which means that a variety of sensing technologies can be substituted or combined to derive proxemic information. We illustrate the versatility of the toolkit with proxemic-aware systems built by students.},
  isbn = {978-1-4503-0716-1},
  language = {en}
}

@article{maxwell,
  title = {{{TRACING THE DYNABOOK}}: {{A STUDY OF TECHNOCULTURAL TRANSFORMATIONS}}},
  author = {Maxwell, John W},
  pages = {311},
  file = {/Users/geoffreylitt/Zotero/storage/XSW23EEV/Maxwell - TRACING THE DYNABOOK A STUDY OF TECHNOCULTURAL TR.pdf},
  keywords = {toread},
  language = {en}
}

@inproceedings{mayer2015,
  title = {User {{Interaction Models}} for {{Disambiguation}} in {{Programming}} by {{Example}}},
  booktitle = {Proceedings of the 28th {{Annual ACM Symposium}} on {{User Interface Software}} \& {{Technology}} - {{UIST}} '15},
  author = {Mayer, Mika{\"e}l and Soares, Gustavo and Grechkin, Maxim and Le, Vu and Marron, Mark and Polozov, Oleksandr and Singh, Rishabh and Zorn, Benjamin and Gulwani, Sumit},
  year = {2015},
  pages = {291--301},
  publisher = {{ACM Press}},
  address = {{Daegu, Kyungpook, Republic of Korea}},
  doi = {10.1145/2807442.2807459},
  abstract = {Programming by Examples (PBE) has the potential to revo\- lutionize end-user programming by enabling end users, most of whom are non-programmers, to create small scripts for au\- tomating repetitive tasks. However, examples, though often easy to provide, are an ambiguous specification of the user's intent. Because of that, a key impedance in adoption of PBE systems is the lack of user confidence in the correctness of the program that was synthesized by the system. We present two novel user interaction models that communicate action\- able information to the user to help resolve ambiguity in the examples. One of these models allows the user to effectively navigate between the huge set of programs that are consis\- tent with the examples provided by the user. The other model uses active learning to ask directed example-based questions to the user on the test input data over which the user intends to run the synthesized program. Our user studies show that each of these models significantly reduces the number of errors in the performed task without any difference in completion time. Moreover, both models are perceived as useful, and the proactive active-learning based model has a slightly higher preference regarding the users' confidence in the result.},
  file = {/Users/geoffreylitt/Zotero/storage/GWGSLACW/Mayer et al. - 2015 - User Interaction Models for Disambiguation in Prog.pdf},
  isbn = {978-1-4503-3779-3},
  language = {en}
}

@misc{maz2017,
  title = {A {{Priesthood}} of {{Programmers}}},
  author = {Maz, Alice},
  year = {2017},
  month = dec,
  abstract = {As the Church was to Christendom, and the press was to the public, programmers are to 21st-century society.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/maz2017.md;/Users/geoffreylitt/Zotero/storage/TVMCURX9/a-priesthood-of-programmers.html},
  journal = {Jacobite},
  language = {en-US}
}

@inproceedings{mccarthy1970,
  title = {The {{Home Information Terminal}}\textemdash a 1970 {{View}}},
  booktitle = {Proceedings of the {{First Annual Conference}} on {{Man}} and {{Computer}}},
  author = {McCarthy, John},
  year = {1970},
  month = jun,
  pages = {48--57},
  publisher = {{Karger}},
  address = {{Bordeaux, France}},
  abstract = {This article was published in Man and Computer. Proc. int. Conf., Bordeaux 1970, pp. 48-57 (Karger, Basel 1972). It is interesting to compare its 1970 proposals with the current situation, 30 years later. I have decorated it with footnotes commenting on the 1970 situation and making comparisons. Some of the improvements advocated in the paper are still yet to come. I claim quite a few prophet points for it.},
  language = {en}
}

@article{mcclure1968,
  title = {{{NATO SOFTWARE ENGINEERING CONFERENCE}} 1968},
  author = {McClure, Robert M},
  year = {1968},
  pages = {136},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/mcclure1968.md;/Users/geoffreylitt/Zotero/storage/HWMFLE67/McClure - 1968 - NATO SOFTWARE ENGINEERING CONFERENCE 1968.pdf},
  language = {en}
}

@inproceedings{mccutchen2016,
  title = {Object Spreadsheets: A New Computational Model for End-User Development of Data-Centric Web Applications},
  shorttitle = {Object Spreadsheets},
  booktitle = {Proceedings of the 2016 {{ACM International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}} - {{Onward}}! 2016},
  author = {McCutchen, Matt and Itzhaky, Shachar and Jackson, Daniel},
  year = {2016},
  pages = {112--127},
  publisher = {{ACM Press}},
  address = {{Amsterdam, Netherlands}},
  doi = {10.1145/2986012.2986018},
  abstract = {Spreadsheets offer many advantages as the computational and data-storage engine for applications that are authored by end users. Paradoxically, however, their main failing in this regard is their computational model. Despite being used in almost all cases to represent data that is essentially relational (with some hierarchical structuring), the spreadsheet model treats the two-dimensional grid as largely unstructured, with formulas linking cells in an ad hoc way.},
  file = {/Users/geoffreylitt/Zotero/storage/8KXJ224J/McCutchen et al. - 2016 - Object spreadsheets a new computational model for.pdf},
  isbn = {978-1-4503-4076-2},
  language = {en}
}

@incollection{mcgrath1995,
  title = {Methodology {{Matters}}: {{Doing Research}} in the {{Behavioral}} and {{Social Sciences}}},
  shorttitle = {Methodology {{Matters}}},
  booktitle = {Readings in {{Human}}-{{Computer Interaction}}: {{Toward}} the {{Year}} 2000},
  author = {McGrath, Joseph E.},
  editor = {Baecker, Ronald M. and Grudin, Jonathan and Buxton, Bill and Greenberg, Saul},
  year = {1995},
  edition = {2nd edition},
  pages = {152--169},
  publisher = {{Morgan Kaufmann}},
  address = {{San Francisco, CA}},
  isbn = {978-0-08-051574-8},
  language = {en}
}

@article{mcguire1997,
  title = {Creative {{Hypothesis Generating}} in {{Psychology}}: {{Some Useful Heuristics}}},
  shorttitle = {Creative {{Hypothesis Generating}} in {{Psychology}}},
  author = {McGuire, William J.},
  year = {1997},
  volume = {48},
  pages = {1--30},
  doi = {10.1146/annurev.psych.48.1.1},
  abstract = {To correct a common imbalance in methodology courses, focusing almost entirely on hypothesis-testing issues to the neglect of hypothesis-generating issues which are at least as important, 49 creative heuristics are described, divided into 5 categories and 14 subcategories. Each of these heuristics has often been used to generate hypotheses in psychological research, and each is teachable to students. The 49 heuristics range from common sense perceptiveness of the oddity of natural occurrences to use of sophisticated quantitative data analyses in ways that provoke new insights.},
  journal = {Annual Review of Psychology},
  number = {1}
}

@article{meertens,
  title = {Designing {{Constraint Maintainers}} for {{User Interaction}}},
  author = {Meertens, Lambert},
  pages = {79},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/meertens.md;/Users/geoffreylitt/Zotero/storage/X6ZK5MSG/Meertens - Designing Constraint Maintainers for User Interact.pdf},
  language = {en}
}

@inproceedings{meyer2006,
  title = {Mondrian: An Agile Information Visualization Framework},
  shorttitle = {Mondrian},
  booktitle = {Proceedings of the 2006 {{ACM}} Symposium on {{Software}} Visualization  - {{SoftVis}} '06},
  author = {Meyer, Michael and G{\^i}rba, Tudor and Lungu, Mircea},
  year = {2006},
  pages = {135},
  publisher = {{ACM Press}},
  address = {{Brighton, United Kingdom}},
  doi = {10.1145/1148493.1148513},
  abstract = {Data visualization is the process of representing data as pictures to support reasoning about the underlying data. For the interpretation to be as easy as possible, we need to be as close as possible to the original data. As most visualization tools have an internal metamodel, which is different from the one for the presented data, they usually need to duplicate the original data to conform to their metamodel. This leads to an increase in the resources needed, increase which is not always justified. In this work we argue for the need of having an engine that is as close as possible to the data and we present our solution of moving the visualization tool to the data, instead of moving the data to the visualization tool. Our solution also emphasizes the necessity of reusing basic blocks to express complex visualizations and allowing the programmer to script the visualization using his preferred tools, rather than a third party format. As a validation of the expressiveness of our framework, we show how we express several already published visualizations and describe the pros and cons of the approach.},
  file = {/Users/geoffreylitt/Zotero/storage/SPYK98W2/Meyer et al. - 2006 - Mondrian an agile information visualization frame.pdf},
  isbn = {978-1-59593-464-2},
  language = {en}
}

@article{meyerovich,
  title = {Flapjax: {{A Programming Language}} for {{Ajax Applications}}},
  author = {Meyerovich, Leo A and Cooper, Gregory H and Guha, Arjun and Greenberg, Michael and Krishnamurthi, Shriram and Baskin, Jacob},
  pages = {20},
  abstract = {This paper presents Flapjax, a language designed for contemporary Web applications. These applications communicate with servers and have rich, interactive interfaces. Flapjax provides two key features that simplify writing these applications. First, it provides event streams, a uniform abstraction for communication within a program as well as with external Web services. Second, the language itself is reactive: it automatically tracks data dependencies and propagates updates along those dataflows. This allows developers to write reactive interfaces in a declarative and compositional style.},
  file = {/Users/geoffreylitt/Zotero/storage/2QPAJ8VF/Meyerovich et al. - Flapjax A Programming Language for Ajax Applicati.pdf},
  language = {en}
}

@incollection{miller2010,
  title = {Chapter 3 - {{Rewriting}} the {{Web}} with {{Chickenfoot}}},
  booktitle = {No {{Code Required}}},
  author = {Miller, Robert C. and Bolin, Michael and Chilton, Lydia B. and Little, Greg and Webber, Matthew and Yu, Chen-Hsiang},
  editor = {Cypher, Allen and Dontcheva, Mira and Lau, Tessa and Nichols, Jeffrey},
  year = {2010},
  month = jan,
  pages = {39--63},
  publisher = {{Morgan Kaufmann}},
  address = {{Boston}},
  doi = {10.1016/B978-0-12-381541-5.00003-1},
  abstract = {Unlike desktop applications, Web applications are much more exposed and open to modification. This chapter describes Chickenfoot, a programming system embedded in the Firefox Web browser, which enables end users to automate, customize, and integrate Web applications without examining their source code. One way Chickenfoot addresses this goal is a technique for identifying page components by keyword pattern matching. Web automation includes navigating pages, filling in forms, and clicking on links. For example, many conferences now use a Web site to receive papers, distribute them to reviewers, and collect the reviews. A reviewer assigned 10 papers must download each paper, print it, and (later) upload a review for it. Tedious repetition is a good argument for automation. While integrating multiple Web sites, the simplest kind of integration is just adding links from one site to another, but much richer integration is possible. Techniques are developed through studying how users name Web page components and present a heuristic keyword-matching algorithm that identifies the desired component from the user's name. It describes a range of applications that have been created using Chickenfoot and reflects on its advantages and limitations.},
  file = {/Users/geoffreylitt/Zotero/storage/9AFI2GGP/Potluck_Data_Mash-Up_Tool_for_Casual_Users.pdf;/Users/geoffreylitt/Zotero/storage/ZZS3B7D7/Miller et al. - 2010 - Chapter 3 - Rewriting the Web with Chickenfoot.pdf;/Users/geoffreylitt/Zotero/storage/I95VQQIL/B9780123815415000031.html},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@incollection{miller2010a,
  title = {Rewriting the {{Web}} with {{Chickenfoot}}},
  booktitle = {No {{Code Required}}},
  author = {Miller, Robert C. and Bolin, Michael and Chilton, Lydia B. and Little, Greg and Webber, Matthew and Yu, Chen-Hsiang},
  year = {2010},
  pages = {39--63},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00003-1},
  abstract = {On the desktop, an application can expect to control its user interface down to the last pixel, but on the World Wide Web, a content provider has no control over how the client will view the page, once delivered to the browser. This creates an opportunity for end users who want to automate and customize their Web experiences, but the growing complexity of Web pages and standards prevents most users from realizing this opportunity. This chapter describes Chickenfoot, a programming system embedded in the Firefox Web browser, which enables end users to automate, customize, and integrate Web applications without examining their source code. One way Chickenfoot addresses this goal is a technique for identifying page components by keyword pattern matching. We motivate this technique by studying how users name Web page components, and present a heuristic keyword matching algorithm that identifies the desired component from the user's name. We describe a range of applications that have been created using Chickenfoot and reflect on its advantages and limitations.},
  file = {/Users/geoffreylitt/Zotero/storage/L74PCDWX/Miller et al. - 2010 - Rewriting the Web with Chickenfoot.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@misc{miller2018,
  title = {Organising Knowledge with Multi-Level Content:},
  author = {Miller, Francis},
  year = {2018},
  month = jun,
  abstract = {The purpose of this paper is to introduce the concepts of knowledge maps, hierarchical knowledge organisation and multi-level content, and explain the potential they bring to making knowledge easier to understand, remember and communicate.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/miller2018.md;/Users/geoffreylitt/Zotero/storage/89ZSL2SP/organising_knowledge_paper.pdf}
}

@article{miltner2018,
  title = {Synthesizing Bijective Lenses},
  author = {Miltner, Anders and Fisher, Kathleen and Pierce, Benjamin C. and Walker, David and Zdancewic, Steve},
  year = {2018},
  month = jan,
  volume = {2},
  pages = {1--30},
  issn = {2475-1421, 2475-1421},
  doi = {10.1145/3158089},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/miltner2018-zotero.md;/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/miltner2018.md;/Users/geoffreylitt/Zotero/storage/3WJCDYMD/Miltner et al. - 2018 - Synthesizing bijective lenses.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  keywords = {lenses,program synthesis},
  language = {en},
  number = {POPL}
}

@article{miltner2019,
  title = {Synthesizing {{Symmetric Lenses}}},
  author = {Miltner, Anders and Maina, Solomon and Fisher, Kathleen and Pierce, Benjamin C. and Walker, David and Zdancewic, Steve},
  year = {2019},
  month = jun,
  abstract = {Lenses are programs that can be run both "front to back" and "back to front," allowing updates to either their source or their target data to be transferred in both directions. Lenses have been extensively studied, extended, and applied. Recent work has demonstrated how techniques from type-directed program synthesis can be used to efficiently synthesize a simple class of lenses---bijective lenses over string data---given a pair of types (regular expressions) and examples. We extend this synthesis algorithm to a broader class of lenses, called simple symmetric lenses, including all bijective lenses, all of the popular category of "asymmetric" lenses, and a subset of the "symmetric lenses" proposed by Hofmann et al. Intuitively, simple symmetric lenses allow some information to be present on one side but not the other and vice versa. They are of independent theoretical interest, being the largest class of symmetric lenses that do not use persistent internal state. Synthesizing simple symmetric lenses is more challenging than synthesizing bijective lenses: Since some of the information on each side can be "disconnected" from the other side, there will typically be many lenses that agree with a given example. To guide the search process, we use stochastic regular expressions and information theory to estimate the amount of information propagated by a candidate lens, preferring lenses that propagate more information, as well as user annotations marking parts of the source and target formats as either irrelevant or essential. We describe an implementation of simple symmetric lenses and our synthesis procedure as extensions to the Boomerang language. We evaluate its performance on 48 benchmark examples drawn from Flash Fill, Augeas, and the bidirectional programming literature. Our implementation can synthesize each of these lenses in under 30 seconds.},
  archivePrefix = {arXiv},
  eprint = {1810.11527},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/YTKM475E/Miltner et al. - 2019 - Synthesizing Symmetric Lenses.pdf;/Users/geoffreylitt/Zotero/storage/HZ4XQG7H/1810.html},
  journal = {arXiv:1810.11527 [cs]},
  keywords = {Computer Science - Programming Languages},
  primaryClass = {cs}
}

@techreport{morrison2000,
  title = {Determinants of {{User Innovation}} and {{Innovation Sharing}} in a {{Local Market}}},
  author = {Morrison, Pamela D. and Roberts, John and {von Hippel}, Eric A.},
  year = {2000},
  month = dec,
  address = {{Rochester, NY}},
  institution = {{Social Science Research Network}},
  abstract = {It is known that end users of products and services sometimes innovate, and that innovations developed by users sometimes become the basis for important new-commercial products and services. It has also been argued and to some extent shown that such innovations will be found concentrated in a ``lead user'' segment of the user community. However, neither the characteristics of innovating users nor the scope of the community that they ``lead'' has been explored in depth.In this paper, we explore the characteristics of innovation, innovators, and innovation sharing by library users of OPAC information search systems in Australia. This market has capable users, but it is nonetheless clearly a ``follower'' with respect to worldwide technological advance. We find that 26\% of users in this local market nonetheless do modify their OPACs in both major and minor ways, and that OPAC manufacturers judge many of these user modifications to be of commercial interest. We find that we can distinguish modifying from non-modifying users on the basis of a number of factors, including their ``leading-edge status'' and their in-house technical capabilities. We find that many innovating users freely share their innovations with others, and find that we can distinguish users that share information about their modifications from users that do not. We conclude by considering some implications of our findings for idea generation practices in marketing.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/Determinants of User Innovation (morrison2000).md;/Users/geoffreylitt/Zotero/storage/NPSQ2G8X/SSRN-id3638410.pdf;/Users/geoffreylitt/Zotero/storage/Y8UYLQ6T/papers.html},
  keywords = {Idea Generation,Lead Users,New Product Development},
  language = {en},
  number = {ID 3638410},
  type = {{{SSRN Scholarly Paper}}}
}

@article{moy2020,
  title = {Corpse {{Reviver}}: {{Sound}} and {{Efficient Gradual Typing}} via {{Contract Verification}}},
  shorttitle = {Corpse {{Reviver}}},
  author = {Moy, Cameron and Nguyen, Ph{\'u}c C. and {Tobin-Hochstadt}, Sam and Van Horn, David},
  year = {2020},
  month = oct,
  abstract = {Gradually-typed programming languages permit the incremental addition of static types to untyped programs. To remain sound, languages insert run-time checks at the boundaries between typed and untyped code. Unfortunately, performance studies have shown that the overhead of these checks can be disastrously high, calling into question the viability of sound gradual typing. In this paper, we show that by building on existing work on soft contract verification, we can reduce or eliminate this overhead. Our key insight is that while untyped code cannot be trusted by a gradual type system, there is no need to consider only the worst case when optimizing a gradually-typed program. Instead, we statically analyze the untyped portions of a gradually-typed program to prove that almost all of the dynamic checks implied by gradual type boundaries cannot fail, and can be eliminated at compile time. Our analysis is modular, and can be applied to any portion of a program. We evaluate this approach on a dozen existing gradually-typed programs previously shown to have prohibitive performance overhead---with a median overhead of \$3.5\textbackslash times\$ and up to \$73.6\textbackslash times\$ in the worst case---and eliminate all overhead in most cases, suffering only \$1.6\textbackslash times\$ overhead in the worst case.},
  archivePrefix = {arXiv},
  eprint = {2007.12630},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/moy2020 Corpse Reviver.md;/Users/geoffreylitt/Zotero/storage/BKQPMMKC/Moy et al. - 2020 - Corpse Reviver Sound and Efficient Gradual Typing.pdf;/Users/geoffreylitt/Zotero/storage/XGDM492J/2007.html},
  journal = {arXiv:2007.12630 [cs]},
  keywords = {Computer Science - Programming Languages},
  primaryClass = {cs}
}

@incollection{muller2002,
  title = {Participatory Design: The Third Space in {{HCI}}},
  shorttitle = {Participatory Design},
  booktitle = {The Human-Computer Interaction Handbook: Fundamentals, Evolving Technologies and Emerging Applications},
  author = {Muller, Michael J.},
  year = {2002},
  month = jan,
  pages = {1051--1068},
  publisher = {{L. Erlbaum Associates Inc.}},
  address = {{USA}},
  isbn = {978-0-8058-3838-1}
}

@article{munzner2009,
  title = {A {{Nested Model}} for {{Visualization Design}} and {{Validation}}},
  author = {Munzner, Tamara},
  year = {2009},
  month = nov,
  volume = {15},
  pages = {921--928},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2009.111},
  abstract = {We present a nested model for the visualization design process withfour layers: characterize the problem domain, abstract into operationson data types, design visual encoding and interaction techniques, andcreate algorithms to execute techniques efficiently. The output from alevel above is input to the level below, bringing attention to thedesign challenge that an upstream error inevitably cascades to alldownstream levels. This model provides prescriptive guidance fordetermining appropriate evaluation approaches by identifying threatsto validity unique to each level. We call attention to specific stepsin the design and evaluation process that are often given shortshrift. We also provide three recommendations motivated by this model:authors should distinguish between these levels when claimingcontributions at more than one of them, authors should explicitlystate upstream assumptions at levels above the focus of a paper, andvisualization venues should accept more papers on domaincharacterization.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  keywords = {design,evaluation.,frameworks,Models},
  number = {6}
}

@article{myers1983,
  title = {{{INCENSE}}: {{A}} System for Displaying Data Structures},
  shorttitle = {{{INCENSE}}},
  author = {Myers, Brad A.},
  year = {1983},
  month = jul,
  volume = {17},
  pages = {115--125},
  issn = {0097-8930},
  doi = {10.1145/964967.801140},
  abstract = {Many modern computer languages allow the programmer to define and use a variety of data types. Few programming systems, however, allow the programmer similar flexibility when displaying the data structures for debugging, monitoring and documenting programs. Incense is a working prototype system that allows the programmer to interactively investigate data structures in actual programs. The desired displays can be specified by the programmer or a default can be used. The default displays provided by Incense present the standard form for literals of the basic types, the actual names for scalar types, stacked boxes for records and arrays, and curved lines with arrowheads for pointers. In addition to displaying data structures, Incense also allows the user to select, move, erase and redimension the resulting displays. These interactions are provided in a uniform, natural manner using a pointing device (mouse) and keyboard.},
  file = {/Users/geoffreylitt/Zotero/storage/GQIVMKPW/Myers - 1983 - INCENSE A system for displaying data structures.pdf},
  journal = {ACM SIGGRAPH Computer Graphics},
  number = {3}
}

@article{myers1990,
  title = {Taxonomies of Visual Programming and Program Visualization},
  author = {Myers, Brad A.},
  year = {1990},
  month = mar,
  volume = {1},
  pages = {97--123},
  issn = {1045926X},
  doi = {10.1016/S1045-926X(05)80036-9},
  abstract = {There has been a great interest recently in systems that use graphics to aid in the programming, debugging, and understanding of computer systems. The terms ``Visual Programming'' and ``Program Visualization'' have been applied to these systems. This paper attempts to provide more meaning to these terms by giving precise definitions, and then surveys a number of systems that can be classified as providing Visual Programming or Program Visualization. These systems are organized by classifying them into three different taxonomies.},
  file = {/Users/geoffreylitt/Zotero/storage/RRUVMERM/Myers - 1990 - Taxonomies of visual programming and program visua.pdf},
  journal = {Journal of Visual Languages \& Computing},
  keywords = {program visualization},
  language = {en},
  number = {1}
}

@article{myers2000,
  title = {Past, {{Present}}, and {{Future}} of {{User Interface Software Tools}}},
  author = {Myers, Brad and Hudson, Scott and Pausch, Randy},
  year = {2000},
  month = mar,
  volume = {7},
  pages = {3--28},
  doi = {10.1145/344949.344959},
  abstract = {A user interface software tool helps developers design and implement the user interface. Research on past tools has had enormous impact on today's developers---virtually all applications today were built using some form of user interface tool. In this paper, we consider cases of both success and failure in past user interface tools. From these cases we extract a set of themes which can serve as lessons for future work. Using these themes, past tools can be characterized by what aspects of the user interface they addressed, their threshold and ceiling, what path of least resistance they offer, how predictable they are to use, and whether they addressed a target that became irrelevant. We believe the lessons of these past themes are particularly important now, because increasingly rapid technological changes are likely to significantly change user interfaces. We are at the dawn of an era where user interfaces are about to break out of the "desktop" box where they have been stuck for the ...},
  file = {/Users/geoffreylitt/Zotero/storage/UL2WV4QQ/Myers et al. - 2000 - Past, Present, and Future of User Interface Softwa.pdf},
  journal = {ACM Trans. Comput.-Hum. Interact.}
}

@article{myers2000a,
  title = {Past, {{Present}} and {{Future}} of {{User Interface Software Tools}}},
  author = {Myers, Brad and Hudson, Scott E and Pausch, Randy},
  year = {2000},
  month = mar,
  pages = {3--28},
  journal = {ACM Transactions on Computer-Human Interaction},
  language = {en}
}

@inproceedings{nardi1990,
  title = {An {{Ethnographic Study}} of {{Distributed Problem Solving}} in {{Spreadsheet Development}}},
  author = {Nardi, Bonnie A. and Miller, James R.},
  year = {1990},
  pages = {197--208},
  publisher = {{ACM Press}},
  abstract = {In contrast to the common view of spreadsheets as ``single-user '' programs, we have found that spreadsheets offer surprisingly strong support for cooperative development of a wide variety of applications. Ethnographic interviews with spreadsheet users showed that nearly all of the spreadsheets used in the work environments studied were the result of collaborative work by people with different levels of programming and domain expertise. Cooperation among spreadsheet users was spontaneous and casual; users activated existing informal social networks to initiate collaboration.},
  file = {/Users/geoffreylitt/Zotero/storage/B9EBINUV/Nardi and Miller - 1990 - An Ethnographic Study of Distributed Problem Solvi.pdf;/Users/geoffreylitt/Zotero/storage/9ERKIFRJ/summary.html}
}

@article{nardi1991,
  title = {Twinkling Lights and Nested Loops: Distributed Problem Solving and Spreadsheet Development},
  shorttitle = {Twinkling Lights and Nested Loops},
  author = {Nardi, Bonnie A. and Miller, James R.},
  year = {1991},
  month = feb,
  volume = {34},
  pages = {161--184},
  issn = {00207373},
  doi = {10.1016/0020-7373(91)90040-E},
  file = {/Users/geoffreylitt/Zotero/storage/ZN8KPRHB/Nardi and Miller - 1991 - Twinkling lights and nested loops distributed pro.pdf},
  journal = {International Journal of Man-Machine Studies},
  language = {en},
  number = {2}
}

@book{nardi1993,
  title = {A {{Small Matter}} of {{Programming}}: {{Perspectives}} on {{End User Computing}}},
  shorttitle = {A {{Small Matter}} of {{Programming}}},
  author = {Nardi, Bonnie A.},
  year = {1993},
  month = jul,
  publisher = {{The MIT Press}},
  abstract = {A Small Matter of Programming asks why it has been so difficult for end users to command programming power and explores the problems of end user-driven application development that must be solved to afford end users greater computational power. Drawing on empirical research on existing end user systems,  A Small Matter of Programming analyzes cognitive, social, and technical issues of end user programming. In particular, it examines the importance of task-specific programming languages, visual application frameworks, and collaborative work practices for end user computing, with the goal of helping designers and programmers understand and better satisfy the needs of end users who want the capability to create, customize, and extend their applications software. The ideas in the book are based on the author's research on two successful end user programming systems - spreadsheets and CAD systems - as well as other empirical research. Nardi concentrates on broad issues in end user programming, especially end users' strengths and problems, introducing tools and techniques as they are related to higher-level user issues. Bonnie A. Nardi is a Member of the Technical Staff at Hewlett Packard Laboratories.},
  language = {English}
}

@inproceedings{nelson2018,
  title = {On {{Use}} of {{Theory}} in {{Computing Education Research}}},
  booktitle = {Proceedings of the 2018 {{ACM Conference}} on {{International Computing Education Research}}},
  author = {Nelson, Greg L. and Ko, Andrew J.},
  year = {2018},
  month = aug,
  pages = {31--39},
  publisher = {{ACM}},
  address = {{Espoo Finland}},
  doi = {10.1145/3230977.3230992},
  abstract = {A primary goal of computing education research is to discover designs that produce better learning of computing. In this pursuit, we have increasingly drawn upon theories from learning science and education research, recognizing the potential benefits of optimizing our search for better designs by leveraging the predictions of general theories of learning. In this paper, we contribute an argument that theory can also inhibit our community's search for better designs. We present three inhibitions: 1) our desire to both advance explanatory theory and advance design splits our attention, which prevents us from excelling at both; 2) our emphasis on applying and refining general theories of learning is done at the expense of domain-specific theories of computer science knowledge, and 3) our use of theory as a critical lens in peer review prevents the publication of designs that may accelerate design progress. We present several recommendations for how to improve our use of theory, viewing it as just one of many sources of design insight in pursuit of improving learning of computing.},
  file = {/Users/geoffreylitt/Zotero/storage/WXVXGL4F/Nelson and Ko - 2018 - On Use of Theory in Computing Education Research.pdf},
  isbn = {978-1-4503-5628-2},
  keywords = {study-design,toread},
  language = {en}
}

@misc{nielsen2014,
  title = {Reinventing {{Explanation}}},
  author = {Nielsen, Michael},
  year = {2014},
  month = jan,
  howpublished = {http://michaelnielsen.org/reinventing\_explanation/},
  journal = {Michael Nielsen}
}

@inproceedings{norman1983,
  title = {Design {{Principles}} for {{Human}}-Computer {{Interfaces}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Norman, Donald A.},
  year = {1983},
  pages = {1--10},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/800045.801571},
  abstract = {If the field of Human Factors in Computer Systems is to be a success it must develop design principles that are useful, principles that apply across a wide range of technologies. In the first part of this paper I discuss some the properties that useful principles should have. While I am at it, I warn of the dangers of the tar pits and the sirens of technology. We cannot avoid these dangers entirely, for were we to do so, we would fail to cope with the real problems and hazards of the field. The second part of the paper is intended to illustrate the first part through the example of tradeoff analysis. Any single design technique is apt to have its virtues along one dimension compensated by deficiencies along another. Tradeoff analysis provides a quantitative method of assessing tradeoff relations for two attributes xi and xj by first determining the User Satisfaction function for each, U(x), then showing how U(xi) trades off against U(xj). In general, the User Satisfaction for a system is given by the weighted sum of the User Satisfaction values for the attributes. The analysis is used to examine two different tradeoffs of information versus time and editor workspace versus menu size. Tradeoffs involving command languages versus menu-based systems, choices of names, and handheld computers versus workstations are examined briefly.},
  isbn = {978-0-89791-121-4},
  series = {{{CHI}} '83}
}

@incollection{norman1993,
  title = {The {{Power}} of {{Representation}}},
  booktitle = {Things {{That Make Us Smart}}: {{Defending Human Attributes}} in the {{Age}} of the {{Machine}}},
  author = {Norman, Donald},
  year = {1993},
  pages = {46--76},
  publisher = {{Basic Books}},
  address = {{New York, NY}},
  language = {en}
}

@book{norman2013,
  title = {The {{Design}} of {{Everyday Things}}},
  author = {Norman, Donald A.},
  year = {2013},
  edition = {Revised and expanded edition},
  publisher = {{Basic Books}},
  address = {{New York, NY}},
  abstract = {"Even the smartest among us can feel inept as we fail to figure out which light switch or oven burner to turn on, or whether to push, pull, or slide a door. The fault, argues this ingenious-even liberating-book, lies not in ourselves, but in product design that ignores the needs of users and the principles of cognitive psychology. The problems range from ambiguous and hidden controls to arbitrary relationships between controls and functions, coupled with a lack of feedback or other assistance and unreasonable demands on memorization. The Design of Everyday Things shows that good, usable design is possible. The rules are simple: make things visible, exploit natural relationships that couple function and control, and make intelligent use of constraints. The goal: guide the user effortlessly to the right action on the right control at the right time. In this entertaining and insightful analysis, cognitive scientist Don Norman hails excellence of design as the most important key to regaining the competitive edge in influencing consumer behavior. Now fully expanded and updated, with a new introduction by the author, The Design of Everyday Things is a powerful primer on how-and why-some products satisfy customers while others only frustrate them. "--},
  isbn = {978-0-465-05065-9},
  keywords = {BUSINESS \& ECONOMICS / Industries / Retailing,DESIGN / Product,Human engineering,Industrial design,Psychological aspects,PSYCHOLOGY / Applied Psychology},
  language = {en},
  lccn = {TS171.4 .N67 2013}
}

@inproceedings{nouwens2018,
  title = {The {{Application}} and {{Its Consequences}} for {{Non}}-{{Standard Knowledge Work}}},
  booktitle = {Proceedings of the 2018 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}  - {{CHI}} '18},
  author = {Nouwens, Midas and Klokmose, Clemens Nylandsted},
  year = {2018},
  pages = {1--12},
  publisher = {{ACM Press}},
  address = {{Montreal QC, Canada}},
  doi = {10.1145/3173574.3173973},
  abstract = {Application-centric computing dominates human-computer interactions, yet the concept of an application is ambiguous and the impact of its ubiquity underexplored. We unpack ``the application'' through the lens of non-standard knowledge work: freelance, self-employed, and fixed-term contract workers who create knowledge in collaboration with a wide variety of stakeholders on a per-project basis. Based on interviews with fourteen participants we describe how: i) their economic value is intertwined with data and skills related to specific applications; ii) their access to this value is systematically jeopardised in collaboration due to the different application practices, preferences, and proficiencies of other stakeholders; and iii) they mitigate the costs of this compromise through cross-application collaboration strategies. We trace these experiences to common characteristics of applications, such as update processes, interface symmetries, application-document relationships, and operating system and hardware dependencies. By empirically and analytically focusing on ``the application'', we reveal the implications of the current application-centric computing paradigm and discuss how variations within this model create qualitatively different human-computer interactions.},
  file = {/Users/geoffreylitt/Zotero/storage/42QGUX6N/Nouwens and Klokmose - 2018 - The Application and Its Consequences for Non-Stand.pdf},
  isbn = {978-1-4503-5620-6},
  language = {en}
}

@inproceedings{nouwens2020,
  title = {Between {{Scripts}} and {{Applications}}: {{Computational Media}} for the {{Frontier}} of {{Nanoscience}}},
  shorttitle = {Between {{Scripts}} and {{Applications}}},
  booktitle = {Proceedings of the 2020 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Nouwens, Midas and Borowski, Marcel and Fog, Bjarke and Klokmose, Clemens Nylandsted},
  year = {2020},
  month = apr,
  pages = {1--13},
  publisher = {{ACM}},
  address = {{Honolulu HI USA}},
  doi = {10.1145/3313831.3376287},
  abstract = {The popularity of computational notebooks heralds a return of software as computational media rather than turn-key applications. We believe this software model has potential beyond supporting just the computationally literate. We studied a biomolecular nano-design lab that works on a current frontier of science \textemdash{} RNA origami \textemdash{} whose researchers depend on computational tools to do their work, yet are not trained as programmers. Using a participatory design process, we developed a computational labbook to concretise what computational media could look like, using the principles of computability, malleability, shareability, and distributability suggested by previous work. We used this prototype to co-reflect with the nanoscientists about how it could transform their practice. We report on the computational culture specific to this research area; the scientists' struggles managing their computational environments; and their subsequent disempowerment yet dependence. Lastly, we discuss the generative potential and limitations of the four design principles for the future of computational media.},
  file = {/Users/geoffreylitt/Zotero/storage/9FLBLNMG/Nouwens et al. - 2020 - Between Scripts and Applications Computational Me.pdf},
  isbn = {978-1-4503-6708-0},
  language = {en}
}

@misc{oct272020,
  title = {What's the {{Role}} of {{Developer Experience}} in {{Programming Languages Research}}?},
  author = {on Oct 27, Jean Yang and {2020}},
  year = {2020},
  month = oct,
  abstract = {Programming languages papers often talk about usability advantages, but the evaluation sections of these papers tend to focus on performance or semantic guarantees. What if we applied methods from \ldots},
  file = {/Users/geoffreylitt/Zotero/storage/8D3E47TW/whats-the-role-of-developer-experience-in-programming-languages-research.html},
  journal = {SIGPLAN Blog},
  language = {en-US}
}

@article{ohearn2019,
  title = {Incorrectness Logic},
  author = {O'Hearn, Peter W.},
  year = {2019},
  month = dec,
  volume = {4},
  pages = {1--32},
  issn = {24751421},
  doi = {10.1145/3371078},
  abstract = {PETER W. O'HEARN, Facebook and University College London, UK 10 Program correctness and incorrectness are two sides of the same coin. As a programmer, even if you would like to have correctness, you might find yourself spending most of your time reasoning about incorrectness. This includes informal reasoning that people do while looking at or thinking about their code, as well as that supported by automated testing and static analysis tools. This paper describes a simple logic for program incorrectness which is, in a sense, the other side of the coin to Hoare's logic of correctness. CCS Concepts: {$\cdot$} Theory of computation \textrightarrow{} Programming logic.},
  file = {/Users/geoffreylitt/Zotero/storage/TDY592AI/O'Hearn - 2019 - Incorrectness logic.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  keywords = {toread},
  language = {en},
  number = {POPL}
}

@article{ohearn2020,
  title = {Incorrectness Logic},
  author = {O'Hearn, Peter W.},
  year = {2020},
  month = jan,
  volume = {4},
  pages = {1--32},
  issn = {2475-1421, 2475-1421},
  doi = {10.1145/3371078},
  abstract = {PETER W. O'HEARN, Facebook and University College London, UK 10 Program correctness and incorrectness are two sides of the same coin. As a programmer, even if you would like to have correctness, you might find yourself spending most of your time reasoning about incorrectness. This includes informal reasoning that people do while looking at or thinking about their code, as well as that supported by automated testing and static analysis tools. This paper describes a simple logic for program incorrectness which is, in a sense, the other side of the coin to Hoare's logic of correctness. CCS Concepts: {$\cdot$} Theory of computation \textrightarrow{} Programming logic.},
  file = {/Users/geoffreylitt/Zotero/storage/XZIGK2KL/O'Hearn - 2020 - Incorrectness logic.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  number = {POPL}
}

@article{olsen1999,
  title = {Interacting in Chaos},
  author = {Olsen, Dan R.},
  year = {1999},
  month = sep,
  volume = {6},
  pages = {42--54},
  issn = {1072-5520},
  doi = {10.1145/312683.312720},
  file = {/Users/geoffreylitt/Zotero/storage/9W8X5IDG/Olsen - 1999 - Interacting in chaos.pdf},
  journal = {Interactions},
  number = {5}
}

@article{olsen1999a,
  title = {Interacting in Chaos},
  author = {Olsen, Dan R.},
  year = {1999},
  month = sep,
  volume = {6},
  pages = {42--54},
  issn = {1072-5520},
  doi = {10.1145/312683.312720},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/olsen1999a-zotero.md;/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/olsen1999a.md;/Users/geoffreylitt/Zotero/storage/YY5PARU4/Olsen - 1999 - Interacting in chaos.pdf},
  journal = {Interactions},
  number = {5}
}

@inproceedings{olsen2007,
  title = {Evaluating User Interface Systems Research},
  booktitle = {Proceedings of the 20th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology  - {{UIST}} '07},
  author = {Olsen, Dan R.},
  year = {2007},
  pages = {251},
  publisher = {{ACM Press}},
  address = {{Newport, Rhode Island, USA}},
  doi = {10.1145/1294211.1294256},
  abstract = {The development of user interface systems has languished with the stability of desktop computing. Future systems, however, that are off-the-desktop, nomadic or physical in nature will involve new devices and new software systems for creating interactive applications. Simple usability testing is not adequate for evaluating complex systems. The problems with evaluating systems work are explored and a set of criteria for evaluating new UI systems work is presented.},
  file = {/Users/geoffreylitt/Zotero/storage/MK38X6IX/Olsen - 2007 - Evaluating user interface systems research.pdf},
  language = {en}
}

@article{olson2000,
  title = {Distance {{Matters}}},
  author = {Olson, Gary M. and Olson, Judith S.},
  year = {2000},
  month = sep,
  volume = {15},
  pages = {139--178},
  issn = {0737-0024, 1532-7051},
  doi = {10.1207/S15327051HCI1523_4},
  abstract = {Giant strides in information technology at the turn of the century may have unleashed unreachable goals. With the invention of groupware, people expect to communicate easily with each other and accomplish difficult work even though they are remotely located or rarely overlap in time. Major corporations launch global teams, expecting that technology will make ``virtual collocation'' possible. Federal research money encourages global science through the establishment of ``collaboratories.'' We review over 10 years of field and laboratory investigations of collocated and noncollocated synchronous group collaborations. In particular, we compare collocated work with remote work as it is possible today and comment on the promise of remote work tomorrow. We focus on the sociotechnical conditions required for effective distance work and bring together the results with four key concepts: common ground, coupling of work, collaboration readiness, and collaboration technology readiness. Groups with high common ground and loosely coupled work, with readiness both for collaboration and collaboration technology, have a chance at succeeding with remote work. Deviations from each of these create strain on the relationships among teammates and require changes in the work or processes of collaboration to succeed. Often they do not succeed because distance still matters.},
  journal = {Human\textendash Computer Interaction},
  language = {en},
  number = {2-3}
}

@book{olson2014,
  title = {Ways of Knowing in {{HCI}}},
  editor = {Olson, Judith S. and Kellogg, Wendy},
  year = {2014},
  publisher = {{Springer}},
  address = {{New York}},
  file = {/Users/geoffreylitt/Zotero/storage/I4DM8SWF/Olson and Kellogg - 2014 - Ways of knowing in HCI.pdf},
  isbn = {978-1-4939-0377-1},
  keywords = {Human-computer interaction},
  language = {en},
  lccn = {QA76.9.H85 W39 2014}
}

@inproceedings{oney2012,
  title = {{{ConstraintJS}}: Programming Interactive Behaviors for the Web by Integrating Constraints and States},
  shorttitle = {{{ConstraintJS}}},
  booktitle = {Proceedings of the 25th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '12},
  author = {Oney, Stephen and Myers, Brad and Brandt, Joel},
  year = {2012},
  pages = {229},
  publisher = {{ACM Press}},
  address = {{Cambridge, Massachusetts, USA}},
  doi = {10.1145/2380116.2380146},
  abstract = {Interactive behaviors in GUIs are often described in terms of states, transitions, and constraints, where the constraints only hold in certain states. These constraints maintain relationships among objects, control the graphical layout, and link the user interface to an underlying data model. However, no existing Web implementation technology provides direct support for all of these, so the code for maintaining constraints and tracking state may end up spread across multiple languages and libraries. In this paper we describe ConstraintJS, a system that integrates constraints and finite-state machines (FSMs) with Web languages. A key role for the FSMs is to enable and disable constraints based on the interface's current mode, making it possible to write constraints that sometimes hold. We illustrate that constraints combined with FSMs can be a clearer way of defining many interactive behaviors with a series of examples.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/oney2012.md;/Users/geoffreylitt/Zotero/storage/PK79C399/Oney et al. - 2012 - ConstraintJS programming interactive behaviors fo.pdf},
  isbn = {978-1-4503-1580-7},
  language = {en}
}

@inproceedings{oney2014,
  title = {{{InterState}}: A Language and Environment for Expressing Interface Behavior},
  shorttitle = {{{InterState}}},
  booktitle = {Proceedings of the 27th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '14},
  author = {Oney, Stephen and Myers, Brad and Brandt, Joel},
  year = {2014},
  pages = {263--272},
  publisher = {{ACM Press}},
  address = {{Honolulu, Hawaii, USA}},
  doi = {10.1145/2642918.2647358},
  abstract = {InterState is a new programming language and environment that addresses the challenges of writing and reusing user interface code. InterState represents interactive behaviors clearly and concisely using a combination of novel forms of state machines and constraints. It also introduces new language features that allow programmers to easily modularize and reuse behaviors. InterState uses a new visual notation that allows programmers to better understand and navigate their code. InterState also includes a live editor that immediately updates the running application in response to changes in the editor and vice versa to help programmers understand the state of their program. Finally, InterState can interface with code and widgets written in other languages, for example to create a user interface in InterState that communicates with a database. We evaluated the understandability of InterState's programming primitives in a comparative laboratory study. We found that participants were twice as fast at understanding and modifying GUI components when they were implemented with InterState than when they were implemented in a conventional textual event-callback style. We evaluated InterState's scalability with a series of benchmarks and example applications and found that it can scale to implement complex behaviors involving thousands of objects and constraints.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/oney2014.md;/Users/geoffreylitt/Zotero/storage/E7C3ZJFX/Oney et al. - 2014 - InterState a language and environment for express.pdf},
  isbn = {978-1-4503-3069-5},
  language = {en}
}

@article{ophir2009,
  title = {Cognitive {{Control}} in {{Media Multitaskers}}},
  author = {Ophir, Eyal and Nass, Clifford and Wagner, Anthony D.},
  year = {2009},
  month = sep,
  volume = {106},
  pages = {15583--15587},
  issn = {0027-8424, 1091-6490},
  doi = {10.1073/pnas.0903620106},
  abstract = {Chronic media multitasking is quickly becoming ubiquitous, although processing multiple incoming streams of information is considered a challenge for human cognition. A series of experiments addressed whether there are systematic differences in information processing styles between chronically heavy and light media multitaskers. A trait media multitasking index was developed to identify groups of heavy and light media multitaskers. These two groups were then compared along established cognitive control dimensions. Results showed that heavy media multitaskers are more susceptible to interference from irrelevant environmental stimuli and from irrelevant representations in memory. This led to the surprising result that heavy media multitaskers performed worse on a test of task-switching ability, likely due to reduced ability to filter out interference from the irrelevant task set. These results demonstrate that media multitasking, a rapidly growing societal trend, is associated with a distinct approach to fundamental information processing.},
  journal = {Proceedings of the National Academy of Sciences},
  language = {en},
  number = {37}
}

@article{ottley2019,
  title = {The {{Curious Case}} of {{Combining Text}} and {{Visualization}}},
  author = {Ottley, Alvitta and Kaszowska, Aleksandra and Crouser, R Jordan and Peck, Evan M},
  year = {2019},
  pages = {5},
  abstract = {Visualization research has made significant progress in demonstrating the value of graphical data representation. Even still, the value added by static visualization is disputed in some areas. When presenting Bayesian reasoning information, for example, some studies suggest that combining text and visualizations could have an interactive effect. In this paper, we use eye tracking to compare how people extract information from text and visualization. Using a Bayesian reasoning problem as a test bed, we provide evidence that a visualization makes it easier to identify critical information, but that once identified as critical, information is more easily extracted from text. These tendencies persist even when text and visualization are presented together, indicating that users do not integrate information well across the two representation types. We discuss these findings and argue that effective representations should consider the ease of both information identification and extraction.},
  language = {en}
}

@article{parnas1979,
  title = {Designing {{Software}} for {{Ease}} of {{Extension}} and {{Contraction}}},
  author = {Parnas, D.L.},
  year = {1979},
  month = mar,
  volume = {SE-5},
  pages = {128--138},
  issn = {0098-5589},
  doi = {10.1109/TSE.1979.234169},
  abstract = {Designing software to be extensible and easily contracted is discussed as a special case of design for change. A number of ways that extension and contraction problems manifest themselves in current software are explained. Four steps in the design of software that is more flexible are then discussed. The most critical step is the design of a software structure called the "uses" relation. Some criteria for design decisions are given and illustrated using a small example. It is shown that the identification of minimal subsets and minimal extensions can lead to software that can be tailored to the needs of a broad variety of users.},
  file = {/Users/geoffreylitt/Zotero/storage/89JWQHHD/Parnas - 1979 - Designing Software for Ease of Extension and Contr.pdf},
  journal = {IEEE Transactions on Software Engineering},
  language = {en},
  number = {2}
}

@incollection{patel2007,
  title = {At the {{Flick}} of a {{Switch}}: {{Detecting}} and {{Classifying Unique Electrical Events}} on the {{Residential Power Line}} ({{Nominated}} for the {{Best Paper Award}})},
  shorttitle = {At the {{Flick}} of a {{Switch}}},
  booktitle = {{{UbiComp}} 2007: {{Ubiquitous Computing}}},
  author = {Patel, Shwetak N. and Robertson, Thomas and Kientz, Julie A. and Reynolds, Matthew S. and Abowd, Gregory D.},
  editor = {Krumm, John and Abowd, Gregory D. and Seneviratne, Aruna and Strang, Thomas},
  year = {2007},
  volume = {4717},
  pages = {271--288},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  abstract = {Activity sensing in the home has a variety of important applications, including healthcare, entertainment, home automation, energy monitoring and post-occupancy research studies. Many existing systems for detecting occupant activity require large numbers of sensors, invasive vision systems, or extensive installation procedures. We present an approach that uses a single plug-in sensor to detect a variety of electrical events throughout the home. This sensor detects the electrical noise on residential power lines created by the abrupt switching of electrical devices and the noise created by certain devices while in operation. We use machine learning techniques to recognize electrically noisy events such as turning on or off a particular light switch, a television set, or an electric stove. We tested our system in one home for several weeks and in five homes for one week each to evaluate the system performance over time and in different types of houses. Results indicate that we can learn and classify various electrical events with accuracies ranging from 85-90\%.},
  isbn = {978-3-540-74852-6},
  language = {en}
}

@inproceedings{patel2010,
  title = {Avaaj {{Otalo}} \textemdash{} {{A Field Study}} of an {{Interactive Voice Forum}} for {{Small Farmers}} in {{Rural India}}},
  booktitle = {Proceedings of the {{Conference}} on {{Human Factors}} in {{Computing Systems}} \textendash{} {{CHI}} 2010},
  author = {Patel, Neil and Chittamuru, Deepti and Jain, Anupam and Dave, Paresh and Parikh, Tapan S.},
  year = {2010},
  month = apr,
  address = {{Atlanta, GA}},
  abstract = {In this paper we present the results of a field study of Avaaj Otalo (literally, ``voice stoop''), an interactive voice application for small-scale farmers in Gujarat, India. Through usage data and interviews, we describe how 51 farmers used the system over a seven month pilot deployment. The most popular feature of Avaaj Otalo was a forum for asking questions and browsing others ' questions and responses on a range of agricultural topics. The forum developed into a lively social space with the emergence of norms, persistent moderation, and a desire for both structured interaction with institutionally sanctioned authorities and open discussion with peers. For all 51 users this was the first experience participating in an online community of any sort. In terms of usability, simple menu-based navigation was readily learned, with users preferring numeric input over speech. We conclude by discussing implications of our findings for designing voice-based social media serving rural communities in India and elsewhere. Author Keywords Voice user interface, social media, forum, India, rural}
}

@misc{patterson2013,
  title = {Shotgun Parsers},
  author = {Patterson, Meredith and Bratus, Sergey and Hirsch, Dan},
  year = {2013}
}

@article{pawson2001,
  title = {Naked Objects: A Technique for Designing More Expressive Systems},
  shorttitle = {Naked Objects},
  author = {Pawson, Richard and Matthews, Robert},
  year = {2001},
  month = dec,
  volume = {36},
  pages = {61--67},
  issn = {0362-1340},
  doi = {10.1145/583960.583967},
  abstract = {Naked objects is an approach to systems design in which core business objects show directly through to the user interface, and in which all interaction consists of invoking methods on those objects in the noun-verb style. One advantage of this approach is that it results in systems that are more expressive from the viewpoint of the user: they treat the user like a problem solver, not as merely a process-follower. Another advantage is that the 1:1 mapping between the user's representation and the underlying model means that it is possible to auto-generate the former from the latter, which yields benefits to the development process. The authors have designed a Java-based, open source toolkit called Naked Objects which facilitates this style of development. This paper describes the design and operation of the toolkit and its application to the prototyping of a core business system. Some initial feedback from the project is provided, together with a list of future research directions both for the toolkit and for a methodology to apply the naked objects approach.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/Naked Objects (pawson2001).md;/Users/geoffreylitt/Zotero/storage/JCJZ82T5/Pawson and Matthews - 2001 - Naked objects a technique for designing more expr.pdf},
  journal = {ACM SIGPLAN Notices},
  number = {12}
}

@phdthesis{pawson2004,
  title = {Naked {{Objects}}},
  author = {Pawson, Richard},
  year = {2004},
  month = jun,
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/pawson2004.md;/Users/geoffreylitt/Zotero/storage/KS4LBZW3/Naked Objects.pdf}
}

@article{peleg,
  title = {Programming with a {{Read}}-{{Eval}}-{{Synth Loop}}},
  author = {Peleg, Hila and Gabay, Roi and Itzhaky, Shachar and Yahav, Eran},
  volume = {4},
  pages = {30},
  abstract = {HILA PELEG, UC San Diego, USA ROI GABAY, Technion, Israel SHACHAR ITZHAKY, Technion, Israel ERAN YAHAV, Technion, Israel A frequent programming pattern for small tasks, especially expressions, is to repeatedly evaluate the program on an input as its editing progresses. The Read-Eval-Print Loop (REPL) interaction model has been a successful model for this programming pattern. We present the new notion of Read-Eval-Synth Loop (RESL) that extends REPL by providing in-place synthesis on parts of the expression marked by the user. RESL eases programming by synthesizing parts of a required solution. The underlying synthesizer relies on a partial solution from the programmer and a few examples. RESL hinges on bottom-up synthesis with general predicates and sketching, generalizing programming by example. To make RESL practical, we present a formal framework that extends observational equivalence to non-example specifications. We evaluate RESL by conducting a controlled within-subjects user-study on 19 programmers from 8 companies, where programmers are asked to solve a small but challenging set of competitive programming problems. We find that programmers using RESL solve these problems with far less need to edit the code themselves and by browsing documentation far less. In addition, they are less likely to leave a task unfinished and more likely to be correct. CCS Concepts: \textbullet{} Software and its engineering \textrightarrow{} Source code generation; Automatic programming.},
  file = {/Users/geoffreylitt/Zotero/storage/JJJXDLWT/Peleg et al. - Programming with a Read-Eval-Synth Loop.pdf},
  language = {en}
}

@article{peleg2017,
  title = {Programming {{Not Only}} by {{Example}}},
  author = {Peleg, Hila and Shoham, Sharon and Yahav, Eran},
  year = {2017},
  month = oct,
  abstract = {In recent years, there has been tremendous progress in automated synthesis techniques that are able to automatically generate code based on some intent expressed by the programmer. A major challenge for the adoption of synthesis remains in having the programmer communicate their intent. When the expressed intent is coarsegrained (for example, restriction on the expected type of an expression), the synthesizer often produces a long list of results for the programmer to choose from, shifting the heavy-lifting to the user. An alternative approach, successfully used in end-user synthesis is programming by example (PBE), where the user leverages examples to interactively and iteratively refine the intent. However, using only examples is not expressive enough for programmers, who can observe the generated program and refine the intent by directly relating to parts of the generated program. We present a novel approach to interacting with a synthesizer using a granular interaction model. Our approach employs a rich interaction model where (i) the synthesizer decorates a candidate program with debug information that assists in understanding the program and identifying good or bad parts, and (ii) the user is allowed to provide feedback not only on the expected output of a program, but also on the underlying program itself. That is, when the user identifies a program as (partially) correct or incorrect, they can also explicitly indicate the good or bad parts, to allow the synthesizer to accept or discard parts of the program instead of discarding the program as a whole.},
  archivePrefix = {arXiv},
  eprint = {1710.01291},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/9SAIT9X5/Peleg et al. - 2017 - Programming Not Only by Example.pdf},
  journal = {arXiv:1710.01291 [cs]},
  keywords = {Computer Science - Programming Languages},
  language = {en},
  primaryClass = {cs}
}

@article{peleg2020,
  title = {Perfect Is the {{Enemy}} of {{Good}}: {{Best}}-{{Effort Program Synthesis}}},
  author = {Peleg, Hila and Polikarpova, Nadia},
  year = {2020},
  pages = {30},
  file = {/Users/geoffreylitt/Zotero/storage/LW43IQ5J/Peleg and Polikarpova - 2020 - Perfect is the Enemy of Good Best-Effort Program .pdf},
  keywords = {program synthesis,toread},
  language = {en}
}

@article{pelega,
  title = {Programming with a {{Read}}-{{Eval}}-{{Synth Loop}}},
  author = {Peleg, Hila and Gabay, Roi and Itzhaky, Shachar and Yahav, Eran},
  volume = {4},
  pages = {30},
  abstract = {HILA PELEG, UC San Diego, USA ROI GABAY, Technion, Israel SHACHAR ITZHAKY, Technion, Israel ERAN YAHAV, Technion, Israel A frequent programming pattern for small tasks, especially expressions, is to repeatedly evaluate the program on an input as its editing progresses. The Read-Eval-Print Loop (REPL) interaction model has been a successful model for this programming pattern. We present the new notion of Read-Eval-Synth Loop (RESL) that extends REPL by providing in-place synthesis on parts of the expression marked by the user. RESL eases programming by synthesizing parts of a required solution. The underlying synthesizer relies on a partial solution from the programmer and a few examples. RESL hinges on bottom-up synthesis with general predicates and sketching, generalizing programming by example. To make RESL practical, we present a formal framework that extends observational equivalence to non-example specifications. We evaluate RESL by conducting a controlled within-subjects user-study on 19 programmers from 8 companies, where programmers are asked to solve a small but challenging set of competitive programming problems. We find that programmers using RESL solve these problems with far less need to edit the code themselves and by browsing documentation far less. In addition, they are less likely to leave a task unfinished and more likely to be correct. CCS Concepts: \textbullet{} Software and its engineering \textrightarrow{} Source code generation; Automatic programming.},
  file = {/Users/geoffreylitt/Zotero/storage/XUYCPD9C/Peleg et al. - Programming with a Read-Eval-Synth Loop.pdf},
  language = {en}
}

@inproceedings{perezderosso2019,
  title = {Declarative Assembly of Web Applications from Predefined Concepts},
  booktitle = {Proceedings of the 2019 {{ACM SIGPLAN International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}}  - {{Onward}}! 2019},
  author = {Perez De Rosso, Santiago and Jackson, Daniel and Archie, Maryam and Lao, Czarina and McNamara III, Barry A.},
  year = {2019},
  pages = {79--93},
  publisher = {{ACM Press}},
  address = {{Athens, Greece}},
  doi = {10.1145/3359591.3359728},
  abstract = {A new approach to web application development is presented, in which an application is constructed by configuring and composing concepts drawn from a catalog developed by experts.},
  file = {/Users/geoffreylitt/Zotero/storage/BFQ7Z7MY/Perez De Rosso et al. - 2019 - Declarative assembly of web applications from pred.pdf},
  isbn = {978-1-4503-6995-4},
  language = {en}
}

@article{petricek,
  title = {Cultures of Programming},
  author = {Petricek, Tomas},
  volume = {1},
  pages = {75},
  file = {/Users/geoffreylitt/Zotero/storage/UV2U35Z5/Petricek - Cultures of programming.pdf},
  keywords = {toread},
  language = {en},
  number = {1}
}

@article{pike2000,
  title = {Systems {{Software Research}} Is {{Irrelevant}}},
  author = {Pike, Rob and Labs, Bell},
  year = {2000},
  month = feb,
  pages = {23},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/pike2000 @ Systems Research is Irrelevant.md;/Users/geoffreylitt/Zotero/storage/E4M9BBM9/Pike and Labs - Systems Software Research is Irrelevant.pdf},
  language = {en}
}

@incollection{pirolli2003,
  title = {Exploring and {{Finding Information}}},
  booktitle = {{{HCI Models}}, {{Theories}}, and {{Frameworks}}: {{Toward}} a {{Multidisciplinary Science}}},
  author = {Pirolli, Peter},
  editor = {Carroll, John M.},
  year = {2003},
  month = apr,
  publisher = {{Morgan Kaufmann}},
  address = {{Amsterdam; Boston}},
  abstract = {Finally-a thorough pedagogical survey of the multidisciplinary science of HCI.Human-Computer Interaction spans many disciplines, from the social and behavioral sciences to information and computer technology. But of all the textbooks on HCI technology and applications, none has adequately addressed HCI's multidisciplinary foundations-until now. HCI Models, Theories, and Frameworks fills a huge void in the education and training of advanced HCI students. Its authors comprise a veritable house of diamonds-internationally known HCI researchers, every one of whom has successfully applied a unique scientific method to solve practical problems.Each chapter focuses on a different scientific analysis or approach, but all in an identical format, especially designed to facilitate comparison of the various models.HCI Models, Theories, and Frameworks answers the question raised by the other HCI textbooks: How can HCI theory can support practice in HCI?* Traces HCI research from its origins* Surveys 14 different successful research approaches in HCI* Presents each approach in a common format to facilitate comparisons* Web-enhanced with teaching tools at http://www.HCImodels.com *Contributors are leading researchers in the field of Human-Comptuter Interaction *Fills a major gap in current literature about the rich scientific foundations of HCI *Provides a thorough pedogological survey of the science of HCI},
  isbn = {978-1-55860-808-5},
  language = {English}
}

@inproceedings{polikarpova2016,
  title = {Program Synthesis from Polymorphic Refinement Types},
  booktitle = {Proceedings of the 37th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}} - {{PLDI}} 2016},
  author = {Polikarpova, Nadia and Kuraj, Ivan and {Solar-Lezama}, Armando},
  year = {2016},
  pages = {522--538},
  publisher = {{ACM Press}},
  address = {{Santa Barbara, CA, USA}},
  doi = {10.1145/2908080.2908093},
  abstract = {We present a method for synthesizing recursive functions that provably satisfy a given specification in the form of a polymorphic refinement type. We observe that such specifications are particularly suitable for program synthesis for two reasons. First, they offer a unique combination of expressive power and decidability, which enables automatic verification\textemdash and hence synthesis\textemdash of nontrivial programs. Second, a type-based specification for a program can often be effectively decomposed into independent specifications for its components, causing the synthesizer to consider fewer component combinations and leading to a combinatorial reduction in the size of the search space. At the core of our synthesis procedure is a new algorithm for refinement type checking, which supports specification decomposition.},
  file = {/Users/geoffreylitt/Zotero/storage/LUWRV2RU/Polikarpova et al. - 2016 - Program synthesis from polymorphic refinement type.pdf},
  isbn = {978-1-4503-4261-2},
  language = {en}
}

@inproceedings{pollock2019,
  title = {Theia: Automatically Generating Correct Program State Visualizations},
  shorttitle = {Theia},
  booktitle = {Proceedings of the 2019 {{ACM SIGPLAN Symposium}} on {{SPLASH}}-{{E}}  - {{SPLASH}}-{{E}} 2019},
  author = {Pollock, Josh and Roesch, Jared and Woos, Doug and Tatlock, Zachary},
  year = {2019},
  pages = {46--56},
  publisher = {{ACM Press}},
  address = {{Athens, Greece}},
  doi = {10.1145/3358711.3361625},
  abstract = {Program state visualizations (PSVs) help programmers understand hidden program state like objects, references, and closures. Unfortunately, existing PSV tools do not support custom language semantics, which educators often use to introduce programming languages gradually. They also fail to visualize key pieces of program state, which can lead to incorrect and confusing visualizations.},
  file = {/Users/geoffreylitt/Zotero/storage/FNAG6CMM/Pollock et al. - 2019 - Theia automatically generating correct program st.pdf},
  isbn = {978-1-4503-6989-3},
  language = {en}
}

@inproceedings{pollock2019a,
  title = {Theia: Automatically Generating Correct Program State Visualizations},
  shorttitle = {Theia},
  booktitle = {Proceedings of the 2019 {{ACM SIGPLAN Symposium}} on {{SPLASH}}-{{E}}},
  author = {Pollock, Josh and Roesch, Jared and Woos, Doug and Tatlock, Zachary},
  year = {2019},
  month = oct,
  pages = {46--56},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3358711.3361625},
  abstract = {Program state visualizations (PSVs) help programmers understand hidden program state like objects, references, and closures. Unfortunately, existing PSV tools do not support custom language semantics, which educators often use to introduce programming languages gradually. They also fail to visualize key pieces of program state, which can lead to incorrect and confusing visualizations. Theia, a generic PSV framework, uses formal abstract machine definitions to produce complete, continuous, and consistent (CCC) PSVs. To produce CCC visualizations with Theia, an educator only needs to specify an abstract machine and optionally customize the resulting web page, allowing her to visualize custom language semantics without developing a language-specific tool.},
  file = {/Users/geoffreylitt/Zotero/storage/PIN45TIR/Pollock et al. - 2019 - Theia automatically generating correct program st.pdf},
  isbn = {978-1-4503-6989-3},
  keywords = {abstract machine,CS1,CS2,notional machine,operational semantics,program visualization},
  series = {{{SPLASH}}-{{E}} 2019}
}

@book{postrel2004,
  title = {The {{Substance}} of {{Style}}: {{How}} the {{Rise}} of {{Aesthetic Value Is Remaking Commerce}}, {{Culture}}, and {{Consciousness}}},
  shorttitle = {The {{Substance}} of {{Style}}},
  author = {Postrel, Virginia},
  year = {2004},
  month = sep,
  publisher = {{Harper Perennial}},
  address = {{New York}},
  abstract = {Whether it's sleek leather pants, a shiny new Apple computer, or a designer toaster, we make important decisions as consumers every day based on our sensory experience. Sensory appeals are everywhere, and they are intensifying, radically changing how Americans live and work. The twenty-first century has become the age of aesthetics, and whether we realize it or not, this influence has taken over the marketplace, and much more. In this penetrating, keenly observed book, Virginia Postrel makes the argument that appearance counts, that aesthetic value is real. Drawing from fields as diverse as fashion, real estate, politics, design, and economics, Postrel deftly chronicles our culture's aesthetic imperative and argues persuasively that it is a vital component of a healthy, forward-looking society. Intelligent, incisive, and thought-provoking, The Substance of Style is a groundbreaking portrait of the democratization of taste and a brilliant examination of the way we live now.},
  isbn = {978-0-06-093385-2},
  language = {English}
}

@article{pottier,
  title = {10 {{The Essence}} of {{ML Type Inference}}},
  author = {Pottier, Fran{\c c}ois and R{\'e}my, Didier},
  pages = {144},
  file = {/Users/geoffreylitt/Zotero/storage/F3N6R6XL/Pottier and Rémy - 10 The Essence of ML Type Inference.pdf},
  language = {en}
}

@article{preguica2018,
  title = {Conflict-Free {{Replicated Data Types}}: {{An Overview}}},
  shorttitle = {Conflict-Free {{Replicated Data Types}}},
  author = {Pregui{\c c}a, Nuno},
  year = {2018},
  month = jun,
  abstract = {Internet-scale distributed systems often replicate data at multiple geographic locations to provide low latency and high availability, despite node and network failures. Geo-replicated systems that adopt a weak consistency model allow replicas to temporarily diverge, requiring a mechanism for merging concurrent updates into a common state. Conflict-free Replicated Data Types (CRDT) provide a principled approach to address this problem. This document presents an overview of Conflict-free Replicated Data Types research and practice, organizing the presentation in the aspects relevant for the application developer, the system developer and the CRDT developer.},
  archivePrefix = {arXiv},
  eprint = {1806.10254},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/CRDT Overview (preguica2018).md;/Users/geoffreylitt/Zotero/storage/TFV6UFA9/TFV6UFA9.pdf;/Users/geoffreylitt/Zotero/storage/MLXQDE34/1806.html},
  journal = {arXiv:1806.10254 [cs]},
  keywords = {Computer Science - Data Structures and Algorithms,Computer Science - Distributed; Parallel; and Cluster Computing,crdt},
  primaryClass = {cs}
}

@inproceedings{qian2012,
  title = {Sample-Driven Schema Mapping},
  booktitle = {Proceedings of the 2012 International Conference on {{Management}} of {{Data}} - {{SIGMOD}} '12},
  author = {Qian, Li and Cafarella, Michael J. and Jagadish, H. V.},
  year = {2012},
  pages = {73},
  publisher = {{ACM Press}},
  address = {{Scottsdale, Arizona, USA}},
  doi = {10.1145/2213836.2213846},
  abstract = {End-users increasingly find the need to perform light-weight, customized schema mapping. State-of-the-art tools provide powerful functions to generate schema mappings, but they usually require an in-depth understanding of the semantics of multiple schemas and their correspondences, and are thus not suitable for users who are technically unsophisticated or when a large number of mappings must be performed.},
  file = {/Users/geoffreylitt/Zotero/storage/LXJRSGRQ/Qian et al. - 2012 - Sample-driven schema mapping.pdf},
  isbn = {978-1-4503-1247-9},
  language = {en}
}

@inproceedings{radle2017,
  title = {Codestrates: {{Literate Computing}} with {{Webstrates}}},
  shorttitle = {Codestrates},
  booktitle = {Proceedings of the 30th {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  author = {R{\"a}dle, Roman and Nouwens, Midas and Antonsen, Kristian and Eagan, James R. and Klokmose, Clemens N.},
  year = {2017},
  month = oct,
  pages = {715--725},
  publisher = {{ACM}},
  address = {{Qu\'ebec City QC Canada}},
  doi = {10.1145/3126594.3126642},
  abstract = {We introduce Codestrates, a literate computing approach to developing interactive software. Codestrates blurs the dis\- tinction between the use and development of applications. It builds on the literate computing approach, commonly found in interactive notebooks such as Jupyter notebook. Literate computing weaves together prose and live computation in the same document. However, literate computing in interactive notebooks are limited to computation and it is challenging to extend their user interface, reprogram their functionality, or develop stand-alone applications. Codestrates builds literate computing capabilities on top of Webstrates and demonstrates how it can be used for (i) collaborative interactive notebooks, (ii) extending its functionality from within itself, and (iii) de\- veloping reprogrammable applications.},
  file = {/Users/geoffreylitt/Zotero/storage/4ES6UBXC/Rädle et al. - 2017 - Codestrates Literate Computing with Webstrates.pdf},
  isbn = {978-1-4503-4981-9},
  language = {en}
}

@article{radul,
  title = {The {{Art}} of the {{Propagator}}},
  author = {Radul, Alexey and Sussman, Gerald Jay},
  pages = {52},
  abstract = {We develop a programming model built on the idea that the basic computational elements are autonomous machines interconnected by shared cells through which they communicate. Each machine continuously examines the cells it is interested in, and adds information to some based on deductions it can make from information from the others. This model makes it easy to smoothly combine expressionoriented and constraint-based programming; it also easily accommodates implicit incremental distributed search in ordinary programs. This work builds on the original research of Guy Lewis Steele Jr. [19] and was developed more recently with the help of Chris Hanson.},
  file = {/Users/geoffreylitt/Zotero/storage/FL4V664U/Radul and Sussman - The Art of the Propagator.pdf},
  language = {en}
}

@article{radula,
  title = {The {{Art}} of the {{Propagator}}},
  author = {Radul, Alexey and Sussman, Gerald Jay},
  pages = {52},
  abstract = {We develop a programming model built on the idea that the basic computational elements are autonomous machines interconnected by shared cells through which they communicate. Each machine continuously examines the cells it is interested in, and adds information to some based on deductions it can make from information from the others. This model makes it easy to smoothly combine expressionoriented and constraint-based programming; it also easily accommodates implicit incremental distributed search in ordinary programs. This work builds on the original research of Guy Lewis Steele Jr. [19] and was developed more recently with the help of Chris Hanson.},
  file = {/Users/geoffreylitt/Zotero/storage/TCIQ7ZRX/Radul and Sussman - The Art of the Propagator.pdf},
  language = {en}
}

@book{raskin2000,
  title = {The {{Humane Interface}}: {{New Directions}} for {{Designing Interactive Systems}}},
  shorttitle = {The {{Humane Interface}}},
  author = {Raskin, Jef},
  year = {2000},
  month = mar,
  publisher = {{Addison-Wesley Professional}},
  address = {{Reading, Mass}},
  abstract = {Deep thinking is rare in this field where most companies are glad to copy designs that were great back in the 1970s. The Humane Interface is a gourmet dish from a master chef. Five mice! --Jakob Nielsen, Nielsen Norman Group Author of Designing Web Usability: The Practice of Simplicity This unique guide to interactive system design reflects the experience and vision of Jef Raskin, the creator of the Apple Macintosh. Other books may show how to use todays widgets and interface ideas effectively. Raskin, however, demonstrates that many current interface paradigms are dead ends, and that to make computers significantly easier to use requires new approaches. He explains how to effect desperately needed changes, offering a wealth of innovative and specific interface ideas for software designers, developers, and product managers. The Apple Macintosh helped to introduce a previous revolution in computer interface design, drawing on the best available technology to establish many of the interface techniques and methods now universal in the computer industry. With this book, Raskin proves again both his farsightedness and his practicality. He also demonstrates how design ideas must be bui},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/The Humane Interface (raskin2000).md},
  isbn = {978-0-201-37937-2},
  language = {English}
}

@misc{rees2019,
  title = {A {{Survey}} of {{Information Visualization Books}}},
  author = {Rees, D. and Laramee, R. S.},
  year = {2019},
  month = feb,
  howpublished = {https://onlinelibrary.wiley.com/doi/abs/10.1111/cgf.13595},
  journal = {Computer Graphics Forum},
  language = {en}
}

@incollection{regis-gianas2008,
  title = {A {{Hoare Logic}} for {{Call}}-by-{{Value Functional Programs}}},
  booktitle = {Mathematics of {{Program Construction}}},
  author = {{R{\'e}gis-Gianas}, Yann and Pottier, Fran{\c c}ois},
  editor = {Audebaud, Philippe and {Paulin-Mohring}, Christine},
  year = {2008},
  volume = {5133},
  pages = {305--335},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  issn = {0302-9743, 1611-3349},
  doi = {10.1007/978-3-540-70594-9_17},
  abstract = {We present a Hoare logic for a call-by-value programming language equipped with recursive, higher-order functions, algebraic data types, and a polymorphic type system in the style of Hindley and Milner. It is the theoretical basis for a tool that extracts proof obligations out of programs annotated with logical assertions. These proof obligations, expressed in a typed, higher-order logic, are discharged using off-theshelf automated or interactive theorem provers. Although the technical apparatus that we exploit is by now standard, its application to callby-value functional programming languages appears to be new, and (we claim) deserves attention. As a sample application, we check the partial correctness of a balanced binary search tree implementation.},
  file = {/Users/geoffreylitt/Zotero/storage/UUKUG8HJ/Régis-Gianas and Pottier - 2008 - A Hoare Logic for Call-by-Value Functional Program.pdf},
  isbn = {978-3-540-70593-2 978-3-540-70594-9},
  language = {en}
}

@article{reid2020,
  title = {Towards Making Formal Methods Normal: Meeting Developers Where They Are},
  shorttitle = {Towards Making Formal Methods Normal},
  author = {Reid, Alastair and Church, Luke and Flur, Shaked and {de Haas}, Sarah and Johnson, Maritza and Laurie, Ben},
  year = {2020},
  month = oct,
  abstract = {Formal verification of software is a bit of a niche activity: it is only applied to the most safety-critical or security-critical software and it is typically only performed by specialized verification engineers. This paper considers whether it would be possible to increase adoption of formal methods by integrating formal methods with developers' existing practices and workflows. We do not believe that widespread adoption will follow from making the prevailing formal methods argument that correctness is more important than engineering teams realize. Instead, our focus is on what we would need to do to enable programmers to make effective use of formal verification tools and techniques. We do this by considering how we might make verification tooling that both serves developers' needs and fits into their existing development lifecycle. We propose a target of two orders of magnitude increase in adoption within a decade driven by ensuring a positive `weekly cost-benefit' ratio for developer time invested.},
  archivePrefix = {arXiv},
  eprint = {2010.16345},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/MDA8UBRJ/Reid et al. - 2020 - Towards making formal methods normal meeting deve.pdf;/Users/geoffreylitt/Zotero/storage/YFW5M52K/2010.html},
  journal = {arXiv:2010.16345 [cs]},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Software Engineering,D.2.4,D.2.5,F.3.1,H.1.2},
  primaryClass = {cs}
}

@inproceedings{reiss2003,
  title = {{{JIVE}}: Visualizing {{Java}} in Action Demonstration Description},
  shorttitle = {{{JIVE}}},
  booktitle = {Proceedings of the 25th {{International Conference}} on {{Software Engineering}}},
  author = {Reiss, Steven P.},
  year = {2003},
  month = may,
  pages = {820--821},
  publisher = {{IEEE Computer Society}},
  address = {{Portland, Oregon}},
  abstract = {Dynamic software visualization should provide a programmer with insights as to what the program is doing. Most current dynamic visualizations either use program traces to show information about prior runs, slow the program down substantially, show only minimal information, or force the programmer to indicate when to turn visualizations on or off. We have developed a dynamic Java visualizer that provides a view of a program in action with low enough overhead that it can be used almost all the time by programmers to understand what their program is doing while it is doing it.},
  file = {/Users/geoffreylitt/Zotero/storage/X42G8K2G/Reiss - 2003 - JIVE visualizing Java in action demonstration des.pdf},
  isbn = {978-0-7695-1877-0},
  series = {{{ICSE}} '03}
}

@inproceedings{reiss2005,
  title = {Jove: Java as It Happens},
  shorttitle = {Jove},
  booktitle = {Proceedings of the 2005 {{ACM}} Symposium on {{Software}} Visualization  - {{SoftVis}} '05},
  author = {Reiss, Steven P. and Renieris, Manos},
  year = {2005},
  pages = {115},
  publisher = {{ACM Press}},
  address = {{St. Louis, Missouri}},
  doi = {10.1145/1056018.1056034},
  abstract = {Dynamic software visualization is designed to provide programmers with insights as to what the program is doing. Most current dynamic visualizations either use program traces to show information about prior runs, slow the program down substantially, show only minimal information, or force the programmer to indicate when to turn visualizations on or off. We have developed a dynamic Java visualizer that provides a statement-level view of a Java program in action with low enough overhead so that it can be used almost all the time by programmers to understand what their program is doing while it is doing it.},
  file = {/Users/geoffreylitt/Zotero/storage/V8H4ET9K/Reiss and Renieris - 2005 - Jove java as it happens.pdf},
  isbn = {978-1-59593-073-6},
  language = {en}
}

@article{reiss2007,
  title = {Visual Representations of Executing Programs},
  author = {Reiss, Steven P.},
  year = {2007},
  doi = {10.1016/j.jvlc.2007.01.003},
  abstract = {Programmers have always been curious about what their programs are doing while it is executing, especially when the behavior is not what they are expecting. Since program execution is intricate and involved, visualization has long been used to provide the programmer with appropriate insights into program execution. This paper looks at the evolution of on-line visual representations of executing programs, showing how they have moved from concrete representations of relatively small programs to abstract representations of larger systems. Based on this examination, we describe the challenges implicit in future execution visualizations and methodologies that can meet these challenges.},
  file = {/Users/geoffreylitt/Zotero/storage/28TMHIMW/jvlexec-1.pdf},
  journal = {J. Vis. Lang. Comput.}
}

@misc{resnick2016,
  title = {Designing for {{Wide Walls}}},
  shorttitle = {Mitchel {{Resnick}}},
  author = {Resnick, Mitchel},
  year = {2016},
  month = aug,
  abstract = {It's not enough to provide a single path from low floor to high ceiling; we need to provide wide walls so that kids can explore multiple pathways from floor to ceiling.},
  file = {/Users/geoffreylitt/Zotero/storage/CI562PI7/mitchel-resnick-designing-for-wide-walls.html},
  howpublished = {https://design.blog/2016/08/25/mitchel-resnick-designing-for-wide-walls/},
  journal = {Design.blog},
  language = {en}
}

@inproceedings{retelny2014,
  title = {Expert Crowdsourcing with Flash Teams},
  booktitle = {Proceedings of the 27th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '14},
  author = {Retelny, Daniela and Robaszkiewicz, S{\'e}bastien and To, Alexandra and Lasecki, Walter S. and Patel, Jay and Rahmati, Negar and Doshi, Tulsee and Valentine, Melissa and Bernstein, Michael S.},
  year = {2014},
  pages = {75--85},
  publisher = {{ACM Press}},
  address = {{Honolulu, Hawaii, USA}},
  doi = {10.1145/2642918.2647409},
  abstract = {We introduce flash teams, a framework for dynamically assembling and managing paid experts from the crowd. Flash teams advance a vision of expert crowd work that accomplishes complex, interdependent goals such as engineering and design. These teams consist of sequences of linked modular tasks and handoffs that can be computationally managed. Interactive systems reason about and manipulate these teams' structures: for example, flash teams can be recombined to form larger organizations and authored automatically in response to a user's request. Flash teams can also hire more people elastically in reaction to task needs, and pipeline intermediate output to accelerate completion times. To enable flash teams, we present Foundry, an end-user authoring platform and runtime manager. Foundry allows users to author modular tasks, then manages teams through handoffs of intermediate work. We demonstrate that Foundry and flash teams enable crowdsourcing of a broad class of goals including design prototyping, course development, and film animation, in half the work time of traditional self-managed teams.},
  isbn = {978-1-4503-3069-5},
  language = {en}
}

@book{rheingold2000,
  title = {Tools for {{Thought}}: {{The History}} and {{Future}} of {{Mind}}-{{Expanding Technology}}},
  shorttitle = {Tools for {{Thought}}},
  author = {Rheingold, Howard},
  year = {2000},
  month = apr,
  edition = {Revised, Subsequent Edition},
  publisher = {{The MIT Press}},
  address = {{Cambridge, Mass}},
  abstract = {In a highly engaging style, Rheingold tells the story of what he calls the patriarchs, pioneers, and infonauts of the computer, focusing in particular on such pioneers as J. C. R. Licklider, Doug Engelbart, Bob Taylor, and Alan Kay.The digital revolution did not begin with the teenage millionaires of Silicon Valley, claims Howard Rheingold, but with such early intellectual giants as Charles Babbage, George Boole, and John von Neumann. In a highly engaging style, Rheingold tells the story of what he calls the patriarchs, pioneers, and infonauts of the computer, focusing in particular on such pioneers as J. C. R. Licklider, Doug Engelbart, Bob Taylor, and Alan Kay. Taking the reader step by step from nineteenth-century mathematics to contemporary computing, he introduces a fascinating collection of eccentrics, mavericks, geniuses, and visionaries.The book was originally published in 1985, and Rheingold's attempt to envision computing in the 1990s turns out to have been remarkably prescient. This edition contains an afterword, in which Rheingold interviews some of the pioneers discussed in the book. As an exercise in what he calls "retrospective futurism," Rheingold also looks back at how he looked forward.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/Tools for Thought (rheingold2000).md},
  isbn = {978-0-262-68115-5},
  language = {English}
}

@article{robertson2008,
  title = {Effectiveness of {{Animation}} in {{Trend Visualization}}},
  author = {Robertson, G. and Fernandez, R. and Fisher, D. and Lee, B. and Stasko, J.},
  year = {2008},
  month = nov,
  volume = {14},
  pages = {1325--1332},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2008.125},
  abstract = {Animation has been used to show trends in multi-dimensional data. This technique has recently gained new prominence for presentations, most notably with Gapminder Trendalyzer. In Trendalyzer, animation together with interesting data and an engaging presenter helps the audience understand the results of an analysis of the data. It is less clear whether trend animation is effective for analysis. This paper proposes two alternative trend visualizations that use static depictions of trends: one which shows traces of all trends overlaid simultaneously in one display and a second that uses a small multiples display to show the trend traces side-by-side. The paper evaluates the three visualizations for both analysis and presentation. Results indicate that trend animation can be challenging to use even for presentations; while it is the fastest technique for presentation and participants find it enjoyable and exciting, it does lead to many participant errors. Animation is the least effective form for analysis; both static depictions of trends are significantly faster than animation, and the small multiples display is more accurate.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  language = {en},
  number = {6}
}

@incollection{robinson1993,
  title = {Design for Unanticipated Use.....},
  booktitle = {Proceedings of the {{Third European Conference}} on {{Computer}}-{{Supported Cooperative Work}} 13\textendash 17 {{September}} 1993, {{Milan}}, {{Italy ECSCW}} '93},
  author = {Robinson, Mike},
  editor = {{de Michelis}, Giorgio and Simone, Carla and Schmidt, Kjeld},
  year = {1993},
  pages = {187--202},
  publisher = {{Springer Netherlands}},
  address = {{Dordrecht}},
  doi = {10.1007/978-94-011-2094-4_13},
  abstract = {Support for work practice is better conceptualised as support for activity taking place in a multidimensional space than as prescription of temporal task sequences. The notion of ``common artefact'' is introduced to illustrate, unify, and summarise recent research that identifies significant dimensions of cooperative work. Common artefacts may be mundane, everyday objects like hotel keyracks or sophisticated computer tools. Both are multidimensional, in that they provide orthogonal features. They are predictable; help people see at a glance what others are doing (peripheral awareness); support implicit communications through the material being worked on; provide a focus for discussion of difficulties and negotiation of compromises (double level language); and afford an overview of the work process that would not otherwise be available. It is argued that CSCW should support these dimensions of work, rather than trying to anticipate its specific sequentiality.},
  file = {/Users/geoffreylitt/Zotero/storage/YI7YP66J/Robinson - 1993 - Design for unanticipated use......pdf},
  isbn = {978-94-011-2094-4},
  keywords = {Common Artefact,Computer Support Cooperative Work,Cooperative Work,Explicit Communication,Flight Level},
  language = {en}
}

@article{robison2002,
  title = {Representation and Misrepresentation: {{Tufte}} and the {{Morton Thiokol}} Engineers on the {{Challenger}}},
  shorttitle = {Representation and Misrepresentation},
  author = {Robison, Wade},
  year = {2002},
  month = mar,
  volume = {8},
  pages = {59--81},
  issn = {1353-3452, 1471-5546},
  doi = {10.1007/s11948-002-0033-2},
  abstract = {This paper examines the role of the Morton Thiokol engineers in the decisions surrounding the launch of the Challenger, particularly with reference to an analysis of this event by Edward Tufte. The engineers at Morton Thiokol recommended against the launch of Challenger because the projected launch temperature between 26\textdegree F to 29\textdegree F was far outside their field database of successful launches. The engineers had asked for, but not received, data necessary to determine the cause of massive blow-by on the launch the previous January, and they had informed their managers and NASA that continuing flights could be catastrophic if the cause of the problems with the launches was not discovered. The authors conclude that the engineers thus did what they were ethically as well as professionally obligated to do.},
  journal = {Science and Engineering Ethics},
  language = {en},
  number = {1}
}

@inproceedings{rule2018,
  title = {Exploration and {{Explanation}} in {{Computational Notebooks}}},
  booktitle = {Proceedings of the 2018 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Rule, Adam and Tabard, Aur{\'e}lien and Hollan, James D.},
  year = {2018},
  pages = {32:1-32:12},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3173574.3173606},
  abstract = {Computational notebooks combine code, visualizations, and text in a single document. Researchers, data analysts, and even journalists are rapidly adopting this new medium. We present three studies of how they are using notebooks to document and share exploratory data analyses. In the first, we analyzed over 1 million computational notebooks on GitHub, finding that one in four had no explanatory text but consisted entirely of visualizations or code. In a second study, we examined over 200 academic computational notebooks, finding that although the vast majority described methods, only a minority discussed reasoning or results. In a third study, we interviewed 15 academic data analysts, finding that most considered computational notebooks personal, exploratory, and messy. Importantly, they typically used other media to share analyses. These studies demonstrate a tension between exploration and explanation in constructing and sharing computational notebooks. We conclude with opportunities to encourage explanation in computational media without hindering exploration.},
  isbn = {978-1-4503-5620-6},
  keywords = {computational notebook,data analysis,data science,jupyter notebook,narrative},
  series = {{{CHI}} '18}
}

@article{sarkar2018,
  title = {Calculation {{View}}: Multiple-Representation Editing in Spreadsheets},
  shorttitle = {Calculation {{View}}},
  author = {Sarkar, Advait and Gordon, Andy and Jones, Simon Peyton and Toronto, Neil},
  year = {2018},
  month = oct,
  abstract = {Spreadsheet errors are ubiquitous and costly, an unfortunate combination that is well-reported. A large class of these errors can be attributed to the inability to clearly see the underlying computational structure, as well as poor support for abstraction (encapsulation, re-use, etc). In this paper we propose a novel solution: a multiple-representation spreadsheet containing additional representations \ldots},
  file = {/Users/geoffreylitt/Zotero/storage/H9QZBRSC/Sarkar et al. - 2018 - Calculation View multiple-representation editing .pdf;/Users/geoffreylitt/Zotero/storage/7EV4V9XU/calculation-view-multiple-representation-editing-in-spreadsheets.html},
  language = {en-US}
}

@article{sarrafzadeh,
  title = {Characterizing {{Stage}}-{{Aware Writing Assistance}} in {{Collaborative Document Authoring}}},
  author = {Sarrafzadeh, Bahareh and Jauhar, Sujay Kumar and Gamon, Michael and Lank, Edward and White, Ryen W},
  volume = {4},
  pages = {29},
  file = {/Users/geoffreylitt/Zotero/storage/9IGJ23IF/Sarrafzadeh et al. - Characterizing Stage-Aware Writing Assistance in C.pdf},
  language = {en}
}

@article{satyanarayan,
  title = {Vega-{{Lite}}: {{A Grammar}} of {{Interactive Graphics}}},
  author = {Satyanarayan, Arvind and Moritz, Dominik and Wongsuphasawat, Kanit and Heer, Jeffrey},
  pages = {10},
  abstract = {We present Vega-Lite, a high-level grammar that enables rapid specification of interactive data visualizations. Vega-Lite combines a traditional grammar of graphics, providing visual encoding rules and a composition algebra for layered and multi-view displays, with a novel grammar of interaction. Users specify interactive semantics by composing selections. In Vega-Lite, a selection is an abstraction that defines input event processing, points of interest, and a predicate function for inclusion testing. Selections parameterize visual encodings by serving as input data, defining scale extents, or by driving conditional logic. The Vega-Lite compiler automatically synthesizes requisite data flow and event handling logic, which users can override for further customization. In contrast to existing reactive specifications, Vega-Lite selections decompose an interaction design into concise, enumerable semantic units. We evaluate Vega-Lite through a range of examples, demonstrating succinct specification of both customized interaction methods and common techniques such as panning, zooming, and linked selection.},
  file = {/Users/geoffreylitt/Zotero/storage/7NMHQC79/Satyanarayan et al. - Vega-Lite A Grammar of Interactive Graphics.pdf},
  language = {en}
}

@article{satyanarayan2017,
  title = {Vega-{{Lite}}: {{A Grammar}} of {{Interactive Graphics}}},
  shorttitle = {Vega-{{Lite}}},
  author = {Satyanarayan, A. and Moritz, D. and Wongsuphasawat, K. and Heer, J.},
  year = {2017},
  month = jan,
  volume = {23},
  pages = {341--350},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2016.2599030},
  abstract = {We present Vega-Lite, a high-level grammar that enables rapid specification of interactive data visualizations. Vega-Lite combines a traditional grammar of graphics, providing visual encoding rules and a composition algebra for layered and multi-view displays, with a novel grammar of interaction. Users specify interactive semantics by composing selections. In Vega-Lite, a selection is an abstraction that defines input event processing, points of interest, and a predicate function for inclusion testing. Selections parameterize visual encodings by serving as input data, defining scale extents, or by driving conditional logic. The Vega-Lite compiler automatically synthesizes requisite data flow and event handling logic, which users can override for further customization. In contrast to existing reactive specifications, Vega-Lite selections decompose an interaction design into concise, enumerable semantic units. We evaluate Vega-Lite through a range of examples, demonstrating succinct specification of both customized interaction methods and common techniques such as panning, zooming, and linked selection.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  keywords = {Brushes,composition algebra,conditional logic,customized interaction methods,data visualisation,Data visualization,declarative specification,Encoding,Grammar,grammars,high-level grammar,inclusion testing,Information visualization,interaction,interactive data visualizations,interactive graphics,interactive systems,linked selection,multiview displays,program compilers,systems,toolkits,Transforms,Vega-Lite compiler,visual encoding rules,visual encodings,Visualization},
  number = {1}
}

@inproceedings{scaffidi2005,
  title = {Estimating the {{Numbers}} of {{End Users}} and {{End User Programmers}}},
  booktitle = {2005 {{IEEE Symposium}} on {{Visual Languages}} and {{Human}}-{{Centric Computing}} ({{VL}}/{{HCC}}'05)},
  author = {Scaffidi, C. and Shaw, M. and Myers, B.},
  year = {2005},
  pages = {207--214},
  publisher = {{IEEE}},
  address = {{Dallas, TX, USA}},
  doi = {10.1109/VLHCC.2005.34},
  abstract = {In 1995, Boehm predicted that by 2005, there would be ``55 million performers'' of ``end user programming'' in the United States. The original context and method which generated this number had two weaknesses, both of which we address. First, it relies on undocumented, judgment based factors to estimate the number of end user programmers based on the total number of end users; we address this weakness by identifying specific end user sub populations and then estimating their sizes. Second, Boehm's estimate relies on additional undocumented, judgment based factors to adjust for rising computer usage rates; we address this weakness by integrating fresh Bureau of Labor Statistics (BLS) data and projections as well as a richer estimation method.},
  file = {/Users/geoffreylitt/Zotero/storage/9HPVDWWQ/Scaffidi et al. - 2005 - Estimating the Numbers of End Users and End User P.pdf},
  isbn = {978-0-7695-2443-6},
  language = {en}
}

@incollection{scaffidi2010,
  title = {Reuse in the World of End User Programmers},
  booktitle = {No {{Code Required}}},
  author = {Scaffidi, Christopher and Shaw, Mary},
  year = {2010},
  pages = {407--421},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00021-3},
  abstract = {End user programmers often reuse one another's code when creating new programs, but this reuse is rarely as clean or simple as the black box reuse that professional programmers aspire to achieve. In this chapter, we explore the motivations that drive reuse of end user code, the challenges that impede reuse of end user code, and several approaches that facilitate reuse of end user code. We give particular emphasis to the problem of helping end users to identify high-quality reusable code amid the millions of scripts, macros, spreadsheets, and other programs produced by essentially anonymous users out on the Web. Based on a review of empirical studies, we find that reusable code is often characterized by certain traits, suggesting that it might be possible to help end user programmers to find reusable code by automatically gathering, analyzing, and synthesizing information about whether code has these desirable traits. We close the chapter with a discussion of future research opportunities aimed at helping end users to identify, understand, and adapt reusable code.},
  file = {/Users/geoffreylitt/Zotero/storage/CI7I9DDW/Scaffidi and Shaw - 2010 - Reuse in the world of end user programmers.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@article{schulz2018,
  title = {Interactive Exploration of Design Trade-Offs},
  author = {Schulz, Adriana and Wang, Harrison and Grinspun, Eitan and Solomon, Justin and Matusik, Wojciech},
  year = {2018},
  month = jul,
  volume = {37},
  pages = {131:1--131:14},
  issn = {0730-0301},
  doi = {10.1145/3197517.3201385},
  abstract = {Typical design for manufacturing applications requires simultaneous optimization of conflicting performance objectives: Design variations that improve one performance metric may decrease another performance metric. In these scenarios, there is no unique optimal design but rather a set of designs that are optimal for different trade-offs (called Pareto-optimal). In this work, we propose a novel approach to discover the Pareto front, allowing designers to navigate the landscape of compromises efficiently. Our approach is based on a first-order approximation of the Pareto front, which allows entire neighborhoods rather than individual points on the Pareto front to be captured. In addition to allowing for efficient discovery of the Pareto front and the corresponding mapping to the design space, this approach allows us to represent the entire trade-off manifold as a small collection of patches that comprise a high-quality and piecewise-smooth approximation. We illustrate how this technique can be used for navigating performance trade-offs in computer-aided design (CAD) models.},
  file = {/Users/geoffreylitt/Zotero/storage/CJGX8IID/Schulz et al. - 2018 - Interactive exploration of design trade-offs.pdf},
  journal = {ACM Transactions on Graphics},
  keywords = {design for manufacturing,pareto optimality,shape modeling},
  number = {4}
}

@article{schwall2020,
  title = {Waymo {{Public Road Safety Performance Data}}},
  author = {Schwall, Matthew and Daniel, Tom and Victor, Trent and Favaro, Francesca and Hohnhold, Henning},
  year = {2020},
  month = oct,
  abstract = {Waymo's mission to reduce traffic injuries and fatalities and improve mobility for all has led us to expand deployment of automated vehicles on public roads without a human driver behind the wheel. As part of this process, Waymo is committed to providing the public with informative and relevant data regarding the demonstrated safety of Waymo's automated driving system, which we call the Waymo Driver. The data presented in this paper represents more than 6.1 million miles of automated driving in the Phoenix, Arizona metropolitan area, including operations with a trained operator behind the steering wheel from calendar year 2019 and 65,000 miles of driverless operation without a human behind the steering wheel from 2019 and the first nine months of 2020. The paper includes every collision and minor contact experienced during these operations as well as every predicted contact identified using Waymo's counterfactual, what if, simulation of events had the vehicle's trained operator not disengaged automated driving. There were 47 contact events that occurred over this time period, consisting of 18 actual and 29 simulated contact events, none of which would be expected to result in severe or life threatening injuries. This paper presents the collision typology and severity for each actual and simulated event, along with diagrams depicting each of the most significant events. Nearly all the events involved one or more road rule violations or other errors by a human driver or road user, including all eight of the most severe events, which we define as involving actual or expected airbag deployment in any involved vehicle. When compared to national collision statistics, the Waymo Driver completely avoided certain collision modes that human driven vehicles are frequently involved in, including road departure and collisions with fixed objects.},
  archivePrefix = {arXiv},
  eprint = {2011.00038},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/K8WGY7E7/Schwall et al. - 2020 - Waymo Public Road Safety Performance Data.pdf;/Users/geoffreylitt/Zotero/storage/XDI2I4ZW/2011.html},
  journal = {arXiv:2011.00038 [cs]},
  keywords = {Computer Science - Robotics,I.2.9},
  primaryClass = {cs}
}

@article{sedlmair2012,
  title = {Design {{Study Methodology}}: {{Reflections}} from the {{Trenches}} and the {{Stacks}}},
  shorttitle = {Design {{Study Methodology}}},
  author = {Sedlmair, Michael and Meyer, Miriah and Munzner, Tamara},
  year = {2012},
  month = dec,
  volume = {18},
  pages = {2431--2440},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2012.213},
  abstract = {Design studies are an increasingly popular form of problem-driven visualization research, yet there is little guidance available about how to do them effectively. In this paper we reflect on our combined experience of conducting twenty-one design studies, as well as reading and reviewing many more, and on an extensive literature review of other field work methods and methodologies. Based on this foundation we provide definitions, propose a methodological framework, and provide practical guidance for conducting design studies. We define a design study as a project in which visualization researchers analyze a specific real-world problem faced by domain experts, design a visualization system that supports solving this problem, validate the design, and reflect about lessons learned in order to refine visualization design guidelines. We characterize two axes\textemdash a task clarity axis from fuzzy to crisp and an information location axis from the domain expert's head to the computer\textemdash and use these axes to reason about design study contributions, their suitability, and uniqueness from other approaches. The proposed methodological framework consists of 9 stages: learn, winnow, cast, discover, design, implement, deploy, reflect, and write. For each stage we provide practical guidance and outline potential pitfalls. We also conducted an extensive literature survey of related methodological approaches that involve a significant amount of qualitative field work, and compare design study methodology to that of ethnography, grounded theory, and action research.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  language = {en},
  number = {12}
}

@article{segel2010,
  title = {Narrative {{Visualization}}: {{Telling Stories}} with {{Data}}},
  shorttitle = {Narrative {{Visualization}}},
  author = {Segel, E. and Heer, J.},
  year = {2010},
  month = nov,
  volume = {16},
  pages = {1139--1148},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2010.179},
  abstract = {Data visualization is regularly promoted for its ability to reveal stories within data, yet these ``data stories'' differ in important ways from traditional forms of storytelling. Storytellers, especially online journalists, have increasingly been integrating visualizations into their narratives, in some cases allowing the visualization to function in place of a written story. In this paper, we systematically review the design space of this emerging class of visualizations. Drawing on case studies from news media to visualization research, we identify distinct genres of narrative visualization. We characterize these design differences, together with interactivity and messaging, in terms of the balance between the narrative flow intended by the author (imposed by graphical elements and the interface) and story discovery on the part of the reader (often through interactive exploration). Our framework suggests design strategies for narrative visualization, including promising under-explored approaches to journalistic storytelling and educational media.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  keywords = {case study,data story,data visualisation,data visualization,Data visualization,design differences,design methods,Economics,educational aids,educational media,Engineering profession,humanities,Image color analysis,journalism,journalistic storytelling,Media,narrative visualization,Narrative visualization,online journalists,social data analysis,storytelling,telling story,Visualization,visualization research},
  number = {6}
}

@article{seidel,
  title = {Dynamic {{Witnesses}} for {{Static Type Errors}} (or, {{Ill}}-{{Typed Programs Usually Go Wrong}})},
  author = {Seidel, Eric L and Jhala, Ranjit and Weimer, Westley},
  pages = {15},
  abstract = {Static type errors are a common stumbling block for newcomers to typed functional languages. We present a dynamic approach to explaining type errors by generating counterexample witness inputs that illustrate how an ill-typed program goes wrong. First, given an ill-typed function, we symbolically execute the body to synthesize witness values that make the program go wrong. We prove that our procedure synthesizes general witnesses in that if a witness is found, then for all inhabited input types, there exist values that can make the function go wrong. Second, we show how to extend the above procedure to produce a reduction graph that can be used to interactively visualize and debug witness executions. Third, we evaluate the coverage of our approach on two data sets comprising over 4,500 ill-typed student programs. Our technique is able to generate witnesses for 88\% of the programs, and our reduction graph yields small counterexamples for 81\% of the witnesses. Finally, we evaluate whether our witnesses help students understand and fix type errors, and find that students presented with our witnesses show a greater understanding of type errors than those presented with a standard error message.},
  file = {/Users/geoffreylitt/Zotero/storage/DD4U2UZD/Seidel et al. - Dynamic Witnesses for Static Type Errors (or, Ill-.pdf},
  language = {en}
}

@article{seidel2018,
  title = {Dynamic {{Witnesses}} for {{Static Type Errors}} (or, {{Ill}}-{{Typed Programs Usually Go Wrong}})},
  author = {Seidel, Eric L. and Jhala, Ranjit and Weimer, Westley},
  year = {2018},
  month = mar,
  abstract = {Static type errors are a common stumbling block for newcomers to typed functional languages. We present a dynamic approach to explaining type errors by generating counterexample witness inputs that illustrate how an ill-typed program goes wrong. First, given an ill-typed function, we symbolically execute the body to synthesize witness values that make the program go wrong. We prove that our procedure synthesizes general witnesses in that if a witness is found, then for all inhabited input types, there exist values that can make the function go wrong. Second, we show how to extend this procedure to produce a reduction graph that can be used to interactively visualize and debug witness executions. Third, we evaluate the coverage of our approach on two data sets comprising over 4,500 ill-typed student programs. Our technique is able to generate witnesses for around 85\% of the programs, our reduction graph yields small counterexamples for over 80\% of the witnesses, and a simple heuristic allows us to use witnesses to locate the source of type errors with around 70\% accuracy. Finally, we evaluate whether our witnesses help students understand and fix type errors, and find that students presented with our witnesses show a greater understanding of type errors than those presented with a standard error message.},
  archivePrefix = {arXiv},
  eprint = {1606.07557},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/CGHV28G2/Seidel et al. - 2018 - Dynamic Witnesses for Static Type Errors (or, Ill-.pdf;/Users/geoffreylitt/Zotero/storage/7ICFIZ7R/1606.html},
  journal = {arXiv:1606.07557 [cs]},
  keywords = {Computer Science - Programming Languages,D.3.2,D.3.4,F.3.3},
  primaryClass = {cs}
}

@article{shani1983,
  title = {Should Program Editors Not Abandon Text Oriented Commands?},
  author = {Shani, Uri},
  year = {1983},
  month = jan,
  volume = {18},
  pages = {35--41},
  issn = {0362-1340},
  doi = {10.1145/948093.948098},
  file = {/Users/geoffreylitt/Zotero/storage/W6X726L6/Shani - 1983 - Should program editors not abandon text oriented c.pdf},
  journal = {ACM SIGPLAN Notices},
  keywords = {structured editors,toread},
  number = {1}
}

@incollection{shapiro2011,
  title = {Conflict-{{Free Replicated Data Types}}},
  booktitle = {Stabilization, {{Safety}}, and {{Security}} of {{Distributed Systems}}},
  author = {Shapiro, Marc and Pregui{\c c}a, Nuno and Baquero, Carlos and Zawirski, Marek},
  editor = {D{\'e}fago, Xavier and Petit, Franck and Villain, Vincent},
  year = {2011},
  volume = {6976},
  pages = {386--400},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-24550-3_29},
  abstract = {Replicating data under Eventual Consistency (EC) allows any replica to accept updates without remote synchronisation. This ensures performance and scalability in largescale distributed systems (e.g., clouds). However, published EC approaches are ad-hoc and error-prone. Under a formal Strong Eventual Consistency (SEC) model, we study sufficient conditions for convergence. A data type that satisfies these conditions is called a Conflictfree Replicated Data Type (CRDT). Replicas of any CRDT are guaranteed to converge in a self-stabilising manner, despite any number of failures. This paper formalises two popular approaches (state- and operation-based) and their relevant sufficient conditions. We study a number of useful CRDTs, such as sets with clean semantics, supporting both add and remove operations, and consider in depth the more complex Graph data type. CRDT types can be composed to develop large-scale distributed applications, and have interesting theoretical properties.},
  file = {/Users/geoffreylitt/Zotero/storage/DXFKYLIR/Shapiro et al. - 2011 - Conflict-Free Replicated Data Types.pdf},
  isbn = {978-3-642-24549-7 978-3-642-24550-3},
  keywords = {toread},
  language = {en}
}

@article{shneiderman1983,
  title = {Direct {{Manipulation}}: {{A Step Beyond Programming Languages}}},
  shorttitle = {Direct {{Manipulation}}},
  author = {Shneiderman, B.},
  year = {1983},
  month = aug,
  volume = {16},
  pages = {57--69},
  issn = {0018-9162},
  doi = {10.1109/MC.1983.1654471},
  abstract = {First Page of the Article},
  file = {/Users/geoffreylitt/Zotero/storage/ML6V6C9N/Shneiderman - 1983 - Direct Manipulation A Step Beyond Programming Lan.pdf},
  journal = {Computer},
  number = {8}
}

@inproceedings{shneiderman1996,
  title = {The {{Eyes Have It}}: {{A Task}} by {{Data Type Taxonomy}} for {{Information Visualizations}}},
  shorttitle = {The {{Eyes Have It}}},
  booktitle = {Proceedings of the 1996 {{IEEE Symposium}} on {{Visual Languages}}},
  author = {Shneiderman, Ben},
  year = {1996},
  pages = {336--343},
  publisher = {{IEEE Computer Society}},
  address = {{Washington, DC, USA}},
  abstract = {A useful starting point for designing advanced graphical user interfaces is the Visual Information-Seeking Mantra: overview first, zoom and filter, then details on demand. But this is only a starting point in trying to understand the rich and varied set of information visualizations that have been proposed in recent years. This paper offers a task by data type taxonomy with seven data types (one-, two-, three-dimensional data, temporal and multi-dimensional data, and tree and network data) and seven tasks (overview, zoom, filter, details-on-demand, relate, history, and extracts).},
  isbn = {978-0-8186-7508-9},
  keywords = {graphical user interfaces,information visualization,visualization},
  series = {{{VL}} '96}
}

@article{shue2017,
  title = {Responsible for What? {{Carbon}} Producer {{CO2}} Contributions and the Energy Transition},
  shorttitle = {Responsible for What?},
  author = {Shue, Henry},
  year = {2017},
  month = oct,
  volume = {144},
  pages = {591--596},
  issn = {0165-0009, 1573-1480},
  doi = {10.1007/s10584-017-2042-9},
  abstract = {Judgments of moral responsibility should be informed by both scientific analysis and societal standards. Society distinguishes responsibilities into positive and negative, general and special, and backward-looking and forward-looking. Ekwurzel et al. in Clim Chang 2017 shows that 90 major carbon producers have contributed most of the atmospheric CO2 emissions. Once it became clear no later than the 1960s that continuing CO2 emissions would progressively undermine the climate, the major carbon producers could see that they were marketing harmful products. The simple and merely negative responsibility to ``do no harm'' required them to reduce that harm rapidly either by modifying the product in order to capture its dangerous emissions or by developing safe substitutes to perform the same function, that is, by developing non-carbon-based forms of energy. The seriousness of the harms brought by climate change made this responsibility especially compelling. Ceasing to contribute to harm includes ending exploration for additional fossil fuels. The half century of failure by corporate carbon producers to reduce the harms caused by their products now gives them additional responsibility to correct the damage done by their decades of neglect of the underlying negative responsibility. If major carbon producers also wish to fulfill the general responsibility to make more than a minimal positive social contribution, their distinctive capacities of political power, wealth, and expertise qualify them for leadership in the transition to an energy regime that would be safe for future generations to rely on.},
  file = {/Users/geoffreylitt/Zotero/storage/RSKJYIPD/Shue - 2017 - Responsible for what Carbon producer CO2 contribu.pdf},
  journal = {Climatic Change},
  language = {en},
  number = {4}
}

@article{simon1988,
  title = {The {{Science}} of {{Design}}: {{Creating}} the {{Artificial}}},
  shorttitle = {The {{Science}} of {{Design}}},
  author = {Simon, Herbert A.},
  year = {1988},
  volume = {4},
  pages = {67},
  issn = {07479360},
  doi = {10.2307/1511391},
  journal = {Design Issues},
  language = {en},
  number = {1/2}
}

@book{simon2008,
  title = {The {{Sciences}} of the {{Artificial}}},
  author = {Simon, Herbert Alexander},
  year = {2008},
  publisher = {{MIT Press}},
  address = {{Cambridge, MA}},
  isbn = {978-0-262-19374-0 978-0-262-69191-8},
  language = {en}
}

@incollection{smith1995,
  title = {Programming as an {{Experience}}: {{The Inspiration}} for {{Self}}},
  shorttitle = {Programming as an {{Experience}}},
  booktitle = {Object-{{Oriented Programming}}},
  author = {Smith, Randall B. and Ungar, David},
  editor = {Tokoro, Mario and Pareschi, Remo},
  year = {1995},
  volume = {952},
  pages = {303--330},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-49538-X_15},
  abstract = {The Self system attempts to integrate intellectual and non-intellectual aspects of programming to create an overall experience. The language semantics, user interface, and implementation each help create this integrated experience. The language semantics embed the programmer in a uniform world of simple objects that can be modified without appealing to definitions of abstractions. In a similar way, the graphical interface puts the user into a uniform world of tangible objects that can be directly manipulated and changed without switching modes. The implementation strives to support the world-of-objects illusion by minimizing perceptible pauses and by providing true source-level semantics without sacrificing performance. As a side benefit, it encourages factoring. Although we see areas that fall short of the vision, on the whole, the language, interface, and implementation conspire so that the Self programmer lives and acts in a consistent and malleable world of objects.},
  file = {/Users/geoffreylitt/Zotero/storage/Q2BZ6JDG/Smith and Ungar - 1995 - Programming as an Experience The Inspiration for .pdf},
  isbn = {978-3-540-60160-9},
  language = {en}
}

@article{spencer2015,
  title = {Brittleness and {{Bureaucracy}}: {{Software}} as a {{Material}} for {{Science}}},
  shorttitle = {Brittleness and {{Bureaucracy}}},
  author = {Spencer, Matt},
  year = {2015},
  month = nov,
  volume = {23},
  pages = {466--484},
  issn = {1063-6145, 1530-9274},
  doi = {10.1162/POSC_a_00184},
  file = {/Users/geoffreylitt/Zotero/storage/QYIANLYK/Spencer - 2015 - Brittleness and Bureaucracy Software as a Materia.pdf},
  journal = {Perspectives on Science},
  keywords = {toread},
  language = {en},
  number = {4}
}

@article{srivastava,
  title = {From {{Program Verification}} to {{Program Synthesis}}},
  author = {Srivastava, Saurabh and Gulwani, Sumit and Foster, Jeffrey S},
  pages = {14},
  abstract = {This paper describes a novel technique for the synthesis of imperative programs. Automated program synthesis has the potential to make programming and the design of systems easier by allowing programs to be specified at a higher-level than executable code. In our approach, which we call proof-theoretic synthesis, the user provides an input-output functional specification, a description of the atomic operations in the programming language, and a specification of the synthesized program's looping structure, allowed stack space, and bound on usage of certain operations. Our technique synthesizes a program, if there exists one, that meets the inputoutput specification and uses only the given resources.},
  file = {/Users/geoffreylitt/Zotero/storage/58YWURBB/Srivastava et al. - From Program Veriﬁcation to Program Synthesis.pdf},
  language = {en}
}

@misc{stallmanrichard,
  title = {{{EMACS}}: {{The Extensible}}, {{Customizable Display Editor}}},
  author = {Stallman, Richard},
  file = {/Users/geoffreylitt/Zotero/storage/ZQS7ACB2/emacs-paper.html},
  howpublished = {https://www.gnu.org/software/emacs/emacs-paper.html\#SEC15},
  keywords = {customizable software,toread}
}

@article{stasko1990,
  title = {Tango: {{A Framework}} and {{System}} for {{Algorithm Animation}}},
  shorttitle = {Tango},
  author = {Stasko, John T.},
  year = {1990},
  month = sep,
  volume = {23},
  pages = {27--39},
  issn = {0018-9162},
  doi = {10.1109/2.58216},
  abstract = {The role of animation in understanding and evaluating programs and developing new programs is discussed. A framework for algorithm animation, called Tango, and a system based on that framework are introduced. Related work is reviewed, and the conceptual framework on which Tango is based is examined. The implementation of the Tango system is described. The first-fit bin-packing algorithm is animated to illustrate how the path-transition paradigm simplifies algorithm animation.},
  journal = {Computer},
  number = {9}
}

@article{steele,
  title = {Growing a {{Language}}},
  author = {Steele, Guy},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Growing a Language.md;/Users/geoffreylitt/Zotero/storage/KRJUGAT8/steele.pdf}
}

@book{stevens2009,
  title = {Bidirectional Model Transformations in {{QVT}}: Semantic Issues and Open Questions},
  shorttitle = {Bidirectional Model Transformations in {{QVT}}},
  author = {Stevens, Perdita},
  year = {2009},
  abstract = {We consider the OMG's Queries, Views and Transformations},
  file = {/Users/geoffreylitt/Zotero/storage/YLWWBNFH/Stevens - 2009 - Bidirectional model transformations in QVT semant.pdf;/Users/geoffreylitt/Zotero/storage/IU7T7GPI/summary.html}
}

@incollection{stokes1997,
  title = {Transforming the {{Paradigm}}},
  booktitle = {Pasteur's {{Quadrant}}: {{Basic Science}} and {{Technological Innovation}}},
  author = {Stokes, Donald E.},
  year = {1997},
  pages = {58--89},
  publisher = {{Brookings Institution Press}},
  address = {{Washington, D.C.}}
}

@book{stokes1997a,
  title = {Pasteur's {{Quadrant}}: {{Basic Science}} and {{Technological Innovation}}},
  shorttitle = {Pasteur's {{Quadrant}}},
  author = {Stokes, Donald E.},
  year = {1997},
  month = aug,
  publisher = {{Brookings Institution Press}},
  address = {{Washington, D.C}},
  abstract = {Over fifty years ago, Vannevar Bush released his enormously influential report, Science, the Endless Frontier, which asserted a dichotomy between basic and applied science. This view was at the core of the compact between government and science that led to the golden age of scientific research after World War II\textemdash a compact that is currently under severe stress. In this book, Donald Stokes challenges Bush's view and maintains that we can only rebuild the relationship between government and the scientific community when we understand what is wrong with that view. Stokes begins with an analysis of the goals of understanding and use in scientific research. He recasts the widely accepted view of the tension between understanding and use, citing as a model case the fundamental yet use-inspired studies by which Louis Pasteur laid the foundations of microbiology a century ago. Pasteur worked in the era of the "second industrial revolution," when the relationship between basic science and technological change assumed its modern form. Over subsequent decades, technology has been increasingly science-based. But science has been increasingly technology-based--with the choice of problems and the conduct of research often inspired by societal needs. An example is the work of the quantum-effects physicists who are probing the phenomena revealed by the miniaturization of semiconductors from the time of the transistor's discovery after World War II. On this revised, interactive view of science and technology, Stokes builds a convincing case that by recognizing the importance of use-inspired basic research we can frame a new compact between science and government. His conclusions have major implications for both the scientific and policy communities and will be of great interest to those in the broader public who are troubled by the current role of basic science in American democracy.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/stokes1997a.md},
  isbn = {978-0-8157-8177-6},
  language = {English}
}

@article{stolte2003,
  title = {Multiscale {{Visualization Using Data Cubes}}},
  author = {Stolte, Chris and Tang, Diane and Hanrahan, Pat},
  year = {2003},
  month = apr,
  volume = {9},
  pages = {176--187},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2003.1196005},
  abstract = {Most analysts start with an overview of the data before gradually refining their view to be more focused and detailed. Multiscale pan-and-zoom systems are effective because they directly support this approach. However, generating abstract overviews of large data sets is difficult and most systems take advantage of only one type of abstraction: visual abstraction. Furthermore, these existing systems limit the analyst to a single zooming path on their data and thus to a single set of abstract views. This paper presents: 1) a formalism for describing multiscale visualizations of data cubes with both data and visual abstraction and 2) a method for independently zooming along one or more dimensions by traversing a zoom graph with nodes at different levels of detail. As an example of how to design multiscale visualizations using our system, we describe four design patterns using our formalism. These design patterns show the effectiveness of multiscale visualization of general relational databases.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  keywords = {database visualization,graphic formalism.,Multiscale visualization},
  number = {2}
}

@article{stonebraker,
  title = {My 10 {{Fears}} about the {{Future}} of the {{DBMS Field}}},
  author = {Stonebraker, Michael},
  pages = {28},
  file = {/Users/geoffreylitt/Zotero/storage/V6J42JTD/Stonebraker - My 10 Fears about the Future of the DBMS Field.pdf},
  language = {en}
}

@misc{streak,
  title = {{{InboxSDK}}},
  author = {Streak},
  file = {/Users/geoffreylitt/Zotero/storage/TK2FCLM5/www.inboxsdk.com.html},
  howpublished = {https://www.inboxsdk.com/}
}

@misc{streams2012,
  title = {Twitter Takes on Third-Party Developers with Strict New Rules},
  author = {Streams, Kimber},
  year = {2012},
  month = aug,
  abstract = {Twitter has released details of its long-hinted crackdown on third-party apps that mimic the "mainstream Twitter consumer client experience" in a blog post that sparked both confusion and outrage. ...},
  file = {/Users/geoffreylitt/Zotero/storage/WZYEH487/twitter-api-third-party-developers.html},
  howpublished = {https://www.theverge.com/2012/8/23/3263481/twitter-api-third-party-developers},
  journal = {The Verge},
  language = {en}
}

@article{suchman,
  title = {{{PLANS AND SITUATED ACTIONS}}:},
  author = {Suchman, Lucy A},
  pages = {163},
  file = {/Users/geoffreylitt/Zotero/storage/9PQ9CFAQ/Suchman - PLANS AND SITUATED ACTIONS.pdf},
  language = {en}
}

@book{suchman1985,
  title = {Plans and {{Situated Actions}}: {{The Problem}} of {{Human}}-{{Machine Communication}}},
  author = {Suchman, Lucy A.},
  year = {1985},
  month = feb,
  publisher = {{Palo Alto Research Center, Xerox Corporation}},
  address = {{Palo Alto, CA}},
  language = {en}
}

@article{sun2020,
  title = {Real {{Differences}} between {{OT}} and {{CRDT}} in {{Correctness}} and {{Complexity}} for {{Consistency Maintenance}} in {{Co}}-{{Editors}}},
  author = {Sun, David and Sun, Chengzheng and Ng, Agustina and Cai, Weiwei},
  year = {2020},
  month = may,
  volume = {4},
  pages = {1--30},
  issn = {2573-0142, 2573-0142},
  doi = {10.1145/3392825},
  abstract = {OT (Operational Transformation) was invented for supporting real-time co-editors in the late 1980s and has evolved to become core techniques widely used in today's working co-editors and adopted in industrial products. CRDT (Commutative Replicated Data Type) for co-editors was first proposed around 2006, under the name of WOOT (WithOut Operational Transformation). Follow-up CRDT variations are commonly labeled as "post-OT" techniques capable of making concurrent operations natively commutative in co-editors. On top of that, CRDT solutions have made broad claims of superiority over OT solutions, and often portrayed OT as an incorrect and inefficient technique. Over one decade later, however, CRDT is rarely found in working co-editors; OT remains the choice for building the vast majority of today's co-editors. Contradictions between the reality and CRDT's purported advantages have been the source of much confusion and debate among co-editing researcher sand developers. To seek truth from facts, we set out to conduct a comprehensive and critical review on representative OT and CRDT solutions and co-editors based on them. From this work, we have made important discoveries about OT and CRDT, and revealed facts and evidences that refute CRDT claims over OT on all accounts. These discoveries help explain the underlying reasons for the choice between OT and CRDT in the real world. We report these results in a series of three articles. In the second article of this series, we reveal the differences between OT and CRDT in their basic approaches to realizing the same general transformation and how such differences had resulted in different challenges and consequential correctness and complexity issues. Moreover, we reveal hidden complexity and algorithmic flaws with representative CRDT solutions, and discuss common myths and facts related to correctness and complexity of OT and CRDT.},
  archivePrefix = {arXiv},
  eprint = {1905.01302},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/K6N2ZLQE/Sun et al. - 2020 - Real Differences between OT and CRDT in Correctnes.pdf;/Users/geoffreylitt/Zotero/storage/94ZV4NXD/1905.html},
  journal = {Proceedings of the ACM on Human-Computer Interaction},
  keywords = {Computer Science - Distributed; Parallel; and Cluster Computing,Computer Science - Human-Computer Interaction,Computer Science - Software Engineering},
  number = {CSCW1}
}

@phdthesis{sutherland1963,
  title = {Sketchpad: {{A Man}}-{{Machine Graphical Communication System}}},
  author = {Sutherland, Ivan Edward},
  year = {1963},
  month = jan,
  address = {{Cambridge, MA}},
  language = {en},
  school = {Massachusetts Institute of Technology},
  type = {Ph.{{D}}. {{Thesis}}}
}

@article{szafir2018,
  title = {The Good, the Bad, and the Biased: Five Ways Visualizations Can Mislead (and How to Fix Them)},
  shorttitle = {The Good, the Bad, and the Biased},
  author = {Szafir, Danielle Albers},
  year = {2018},
  month = jun,
  volume = {25},
  pages = {26--33},
  issn = {10725520},
  doi = {10.1145/3231772},
  journal = {Interactions},
  language = {en},
  number = {4}
}

@misc{talwar2019,
  title = {Gmail.Js},
  author = {Talwar, Kartik},
  year = {2019},
  abstract = {Gmail JavaScript API},
  file = {/Users/geoffreylitt/Zotero/storage/EQIGCWJM/master.html},
  howpublished = {https://github.com/KartikTalwar/gmail.js},
  journal = {GitHub},
  language = {en}
}

@inproceedings{tchernavskij2018,
  title = {Critique of `Files as Directories: Some Thoughts on Accessing Structured Data within Files' (1)},
  shorttitle = {Critique of `files as Directories},
  booktitle = {Conference {{Companion}} of the 2nd {{International Conference}} on {{Art}}, {{Science}}, and {{Engineering}} of {{Programming}} - {{Programming}}'18 {{Companion}}},
  author = {Tchernavskij, Philip},
  year = {2018},
  pages = {171--174},
  publisher = {{ACM Press}},
  address = {{Nice, France}},
  doi = {10.1145/3191697.3214324},
  abstract = {In this critique of Files as Directories (FAD) by Raphael Wimmer, I argue that FAD as presented applies primarily to traditional programming tasks, consider FAD as a broader subversion of app-like software, and speculate about the hypothetical design space of FAD beyond programming.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/tchernavskij2018-zotero.md;/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/tchernavskij2018.md;/Users/geoffreylitt/Zotero/storage/J4YWXQTL/J4YWXQTL.pdf},
  isbn = {978-1-4503-5513-1},
  language = {en}
}

@phdthesis{Tchernavskij2019,
  title = {Designing and Programming Malleable Software},
  author = {Tchernavskij, Philip},
  year = {2019},
  file = {/Users/geoffreylitt/Zotero/storage/HGMLC9GV/Tchernavskij - Designing and Programming Malleable Software.pdf},
  school = {Universit\'e Paris-Saclay, \'Ecole doctorale n\textordmasculine 580 Sciences et Technologies de l'Information et de la Communication (STIC)},
  type = {{{PhD}} Thesis}
}

@inproceedings{teevan2004,
  title = {The {{Perfect Search Engine}} Is {{Not Enough}}: {{A Study}} of {{Orienteering Behavior}} in {{Directed Search}}},
  shorttitle = {The {{Perfect Search Engine}} Is {{Not Enough}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Teevan, Jaime and Alvarado, Christine and Ackerman, Mark S. and Karger, David R.},
  year = {2004},
  pages = {415--422},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/985692.985745},
  abstract = {This paper presents a modified diary study that investigated how people performed personally motivated searches in their email, in their files, and on the Web. Although earlier studies of directed search focused on keyword search, most of the search behavior we observed did not involve keyword search. Instead of jumping directly to their information target using keywords, our participants navigated to their target with small, local steps using their contextual knowledge as a guide, even when they knew exactly what they were looking for in advance. This stepping behavior was especially common for participants with unstructured information organization. The observed advantages of searching by taking small steps include that it allowed users to specify less of their information need and provided a context in which to understand their results. We discuss the implications of such advantages for the design of personal information management tools.},
  isbn = {978-1-58113-702-6},
  keywords = {context,information seeking,observational study,orienteering,search,teleporting},
  series = {{{CHI}} '04}
}

@article{tian2020,
  title = {A {{System}} for {{Interleaving Discussion}} and {{Summarization}} in {{Online Collaboration}}},
  author = {Tian, Sunny and Zhang, Amy X. and Karger, David},
  year = {2020},
  month = sep,
  abstract = {In many instances of online collaboration, ideation and deliberation about what to write happen separately from the synthesis of the deliberation into a cohesive document. However, this may result in a final document that has little connection to the discussion that came before. In this work, we present interleaved discussion and summarization, a process where discussion and summarization are woven together in a single space, and collaborators can switch back and forth between discussing ideas and summarizing discussion until it results in a final document that incorporates and references all discussion points. We implement this process into a tool called Wikum+ that allows groups working together on a project to create living summaries-artifacts that can grow as new collaborators, ideas, and feedback arise and shrink as collaborators come to consensus. We conducted studies where groups of six people each collaboratively wrote a proposal using Wikum+ and a proposal using a messaging platform along with Google Docs. We found that Wikum+'s integration of discussion and summarization helped users be more organized, allowing for light-weight coordination and iterative improvements throughout the collaboration process. A second study demonstrated that in larger groups, Wikum+ is more inclusive of all participants and more comprehensive in the final document compared to traditional tools.},
  archivePrefix = {arXiv},
  eprint = {2009.07446},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/ALCP59EB/Tian et al. - 2020 - A System for Interleaving Discussion and Summariza.pdf;/Users/geoffreylitt/Zotero/storage/TQIHAQHW/2009.html},
  journal = {arXiv:2009.07446 [cs]},
  keywords = {Computer Science - Human-Computer Interaction},
  primaryClass = {cs}
}

@inproceedings{tohidi2006,
  title = {Getting the {{Right Design}} and the {{Design Right}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Tohidi, Maryam and Buxton, William and Baecker, Ronald and Sellen, Abigail},
  year = {2006},
  pages = {1243--1252},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1124772.1124960},
  abstract = {We present a study comparing usability testing of a single interface versus three functionally equivalent but stylistically distinct designs. We found that when presented with a single design, users give significantly higher ratings and were more reluctant to criticize than when presented with the same design in a group of three. Our results imply that by presenting users with alternative design solutions, subjective ratings are less prone to inflation and give rise to more and stronger criticisms when appropriate. Contrary to our expectations, our results also suggest that usability testing by itself, even when multiple designs are presented, is not an effective vehicle for soliciting constructive suggestions about how to improve the design from end users. It is a means to identify problems, not provide solutions.},
  isbn = {978-1-59593-372-0},
  keywords = {design,evaluation,methods,participatory design,prototyping,usability testing,user centered design},
  series = {{{CHI}} '06}
}

@inproceedings{toomim2009,
  title = {Attaching {{UI}} Enhancements to Websites with End Users},
  booktitle = {Proceedings of the 27th International Conference on {{Human}} Factors in Computing Systems - {{CHI}} 09},
  author = {Toomim, Michael and Drucker, Steven M. and Dontcheva, Mira and Rahimi, Ali and Thomson, Blake and Landay, James A.},
  year = {2009},
  pages = {1859},
  publisher = {{ACM Press}},
  address = {{Boston, MA, USA}},
  doi = {10.1145/1518701.1518987},
  abstract = {We present reform, a step toward write-once apply-anywhere user interface enhancements. The reform system envisions roles for both programmers and end users in enhancing existing websites to support new goals. First, a programmer authors a traditional mashup or browser extension, but they do not write a web scraper. Instead they use reform, which allows novice end users to attach the enhancement to their favorite sites with a scraping by-example interface. reform makes enhancements easier to program while also carrying the benefit that end users can apply the enhancements to any number of new websites. We present reform's architecture, user interface, interactive by-example extraction algorithm for novices, and evaluation, along with five example reform enabled enhancements.},
  file = {/Users/geoffreylitt/Zotero/storage/ZH2NT4E3/Toomim et al. - 2009 - Attaching UI enhancements to websites with end use.pdf},
  isbn = {978-1-60558-246-7},
  language = {en}
}

@inproceedings{toomim2009a,
  title = {Attaching {{UI}} Enhancements to Websites with End Users},
  booktitle = {Proceedings of the 27th International Conference on {{Human}} Factors in Computing Systems - {{CHI}} 09},
  author = {Toomim, Michael and Drucker, Steven M. and Dontcheva, Mira and Rahimi, Ali and Thomson, Blake and Landay, James A.},
  year = {2009},
  pages = {1859},
  publisher = {{ACM Press}},
  address = {{Boston, MA, USA}},
  doi = {10.1145/1518701.1518987},
  abstract = {We present reform, a step toward write-once apply-anywhere user interface enhancements. The reform system envisions roles for both programmers and end users in enhancing existing websites to support new goals. First, a programmer authors a traditional mashup or browser extension, but they do not write a web scraper. Instead they use reform, which allows novice end users to attach the enhancement to their favorite sites with a scraping by-example interface. reform makes enhancements easier to program while also carrying the benefit that end users can apply the enhancements to any number of new websites. We present reform's architecture, user interface, interactive by-example extraction algorithm for novices, and evaluation, along with five example reform enabled enhancements.},
  file = {/Users/geoffreylitt/Zotero/storage/SIP82BD6/Toomim et al. - 2009 - Attaching UI enhancements to websites with end use.pdf},
  isbn = {978-1-60558-246-7},
  language = {en}
}

@inproceedings{torlak2007,
  title = {Kodkod: {{A}} Relational Model Finder},
  shorttitle = {Kodkod},
  booktitle = {International {{Conference}} on {{Tools}} and {{Algorithms}} for the {{Construction}} and {{Analysis}} of {{Systems}}},
  author = {Torlak, Emina and Jackson, Daniel},
  year = {2007},
  pages = {632--647},
  publisher = {{Springer}},
  file = {/Users/geoffreylitt/Zotero/storage/JD7XJVQD/Torlak and Jackson - 2007 - Kodkod A relational model finder.pdf;/Users/geoffreylitt/Zotero/storage/GP83CYAX/978-3-540-71209-1_49.html}
}

@inproceedings{trigg1994,
  title = {From Implementation to Design: Tailoring and the Emergence of Systematization in {{CSCW}}},
  shorttitle = {From Implementation to Design},
  booktitle = {Proceedings of the 1994 {{ACM}} Conference on {{Computer}} Supported Cooperative Work},
  author = {Trigg, Randall H. and B{\o}dker, Susanne},
  year = {1994},
  month = oct,
  pages = {45--54},
  publisher = {{Association for Computing Machinery}},
  address = {{Chapel Hill, North Carolina, USA}},
  doi = {10.1145/192844.192869},
  abstract = {In this paper, we look at how people working in a governmental labor inspection agency tailor their shared PC environment. Starting with standard off-the-shelf software, the tailors adapt that software to the particular workplace in which they are embedded, at the same time that they modify and extend the practices of that workplace. Over time, their adaptations and the tailoring processes themselves become structured and systematized within the organization. This tendency toward systematization is in part a response to the requirement that the results of tailoring be sharable across groups of users. Our study focuses on several dimensions of the work of tailoring: construction, organizational change, learning, and politics. We draw two kinds of lessons for system development: how better to support the work of tailors, and how system developers can learn from and cooperate with tailors.},
  file = {/Users/geoffreylitt/Zotero/storage/YKXY2L95/Trigg and Bødker - 1994 - From implementation to design tailoring and the e.pdf},
  isbn = {978-0-89791-689-9},
  keywords = {customizable software,customization,development and use of shared standards,emergent use of standard technology,tailoring},
  series = {{{CSCW}} '94}
}

@book{tufte1997,
  title = {Visual {{Explanations}}: {{Images}} and {{Quantities}}, {{Evidence}} and {{Narrative}}},
  author = {Tufte, Edward R.},
  year = {1997},
  publisher = {{Graphics Press}},
  address = {{Cheshire, CT}},
  abstract = {This book describes design strategies - the proper arrangement in space and time of images, words, and numbers - for presenting information about motion, process, mechanism, cause and effect.},
  isbn = {0-9613921-2-6 978-0-9613921-2-3 978-1-930824-15-7 1-930824-15-7 0-9613921-7-7 978-0-9613921-7-8},
  keywords = {\#nosource},
  language = {English}
}

@book{tufte2001,
  title = {The {{Visual Display}} of {{Quantitative Information}}},
  author = {Tufte, Edward R.},
  year = {2001},
  publisher = {{Graphics Press}},
  address = {{Cheshire, CT}},
  keywords = {\#nosource}
}

@book{tufte2003,
  title = {The {{Cognitive Style}} of {{Powerpoint}}},
  author = {Tufte, Edward R.},
  year = {2003},
  publisher = {{Graphics Press}},
  address = {{Cheshire, CT}},
  abstract = {Using specific examples, Tufte explains how PowerPoint's templates "usually weaken verbal and spatial reasoning and almost always corrupt statistical analysis," and describes concrete ways to improve content of presentations.},
  isbn = {0-9613921-5-0 978-0-9613921-5-4},
  keywords = {\#nosource},
  language = {English}
}

@book{tufte2006,
  title = {Beautiful {{Evidence}}},
  author = {Tufte, Edward R.},
  year = {2006},
  publisher = {{Graphics Press}},
  address = {{Cheshire, CT}},
  keywords = {\#nosource}
}

@book{tufte2006a,
  title = {Envisioning {{Information}}},
  author = {Tufte, Edward R.},
  year = {2006},
  publisher = {{Graphics Press}},
  address = {{Cheshire, CT}},
  isbn = {978-0-9613921-1-6 0-9613921-1-8},
  keywords = {\#nosource},
  language = {English}
}

@inproceedings{tunnellwilson2017,
  title = {Can We Crowdsource Language Design?},
  booktitle = {Proceedings of the 2017 {{ACM SIGPLAN International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}}},
  author = {Tunnell Wilson, Preston and Pombrio, Justin and Krishnamurthi, Shriram},
  year = {2017},
  month = oct,
  pages = {1--17},
  publisher = {{ACM}},
  address = {{Vancouver BC Canada}},
  doi = {10.1145/3133850.3133863},
  abstract = {Most programming languages have been designed by commi ees or individuals. What happens if, instead, we throw open the design process and let lots of programmers weigh in on semantic choices? Will they avoid well-known mistakes like dynamic scope? What do they expect of aliasing? What kind of overloading behavior will they choose? We investigate this issue by posing questions to programmers on Amazon Mechanical Turk. We examine several language features, in each case using multiple-choice questions to explore programmer preferences. We check the responses for consensus (agreement between people) and consistency (agreement across responses from one person). In general we nd low consistency and consensus, potential confusion over mainstream features, and arguably poor design choices. In short, this preliminary evidence does not argue in favor of designing languages based on programmer preference.},
  file = {/Users/geoffreylitt/Zotero/storage/JTGPSFZJ/JTGPSFZJ.pdf},
  isbn = {978-1-4503-5530-8},
  language = {en}
}

@article{tversky2002,
  title = {Animation: Can It Facilitate?},
  shorttitle = {Animation},
  author = {Tversky, Barbara and Morrison, Julie Bauer and Betrancourt, Mireille},
  year = {2002},
  month = oct,
  volume = {57},
  pages = {247--262},
  issn = {10715819},
  doi = {10.1006/ijhc.2002.1017},
  journal = {International Journal of Human-Computer Studies},
  language = {en},
  number = {4}
}

@misc{unknown2009,
  title = {{{DUB For}} the {{Future}}: {{I}} Give up on {{CHI}}/{{UIST}}},
  shorttitle = {{{DUB For}} the {{Future}}},
  author = {Unknown},
  year = {2009},
  month = nov,
  file = {/Users/geoffreylitt/Zotero/storage/HN7J2QR3/i-give-up-on-chiuist.html},
  journal = {DUB For the Future},
  keywords = {CHI community reviewing broken}
}

@inproceedings{valentine2017,
  title = {Flash {{Organizations}}: {{Crowdsourcing Complex Work}} by {{Structuring Crowds As Organizations}}},
  shorttitle = {Flash {{Organizations}}},
  booktitle = {Proceedings of the 2017 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}  - {{CHI}} '17},
  author = {Valentine, Melissa A. and Retelny, Daniela and To, Alexandra and Rahmati, Negar and Doshi, Tulsee and Bernstein, Michael S.},
  year = {2017},
  pages = {3523--3537},
  publisher = {{ACM Press}},
  address = {{Denver, Colorado, USA}},
  doi = {10.1145/3025453.3025811},
  abstract = {This paper introduces flash organizations: crowds structured like organizations to achieve complex and open-ended goals. Microtask workflows, the dominant crowdsourcing structures today, only enable goals that are so simple and modular that their path can be entirely pre-defined. We present a system that organizes crowd workers into computationally-represented structures inspired by those used in organizations \textemdash{} roles, teams, and hierarchies \textemdash{} which support emergent and adaptive coordination toward open-ended goals. Our system introduces two technical contributions: 1) encoding the crowd's division of labor into de-individualized roles, much as movie crews or disaster response teams use roles to support coordination between on-demand workers who have not worked together before; and 2) reconfiguring these structures through a model inspired by version control, enabling continuous adaptation of the work and the division of labor. We report a deployment in which flash organizations successfully carried out open-ended and complex goals previously out of reach for crowdsourcing, including product design, software development, and game production. This research demonstrates digitally networked organizations that flexibly assemble and reassemble themselves from a globally distributed online workforce to accomplish complex work.},
  isbn = {978-1-4503-4655-9},
  language = {en}
}

@article{valiant1984,
  title = {A Theory of the Learnable},
  author = {Valiant, Leslie},
  year = {1984},
  volume = {27},
  pages = {9},
  abstract = {Humans appear to be able to learn new concepts without needing to be programmed explicitly in any conventional sense. In this paper we regard learning as the phenomenon of knowledge acquisition in the absence of explicit programming. We give a precise methodology for studying this phenomenon from a computational viewpoint. It consists of choosing an appropriate information gathering mechanism, the learning protocol, and exploring the class of concepts that can be learned using it in a reasonable (polynomial) number of steps. Although inherent algorithmic complexity appears to set serious limits to the range of concepts that can be learned, we show that there are some important nontrivial classes of propositional concepts that can be learned in a realistic sense.},
  file = {/Users/geoffreylitt/Zotero/storage/5U9B4ZMA/Waltz - 1984 - A theory of the learnable.pdf},
  keywords = {toread},
  language = {en},
  number = {11}
}

@incollection{vandevanter1995,
  title = {Practical Language-Based Editing for Software Engineers},
  booktitle = {Software {{Engineering}} and {{Human}}-{{Computer Interaction}}},
  author = {Van De Vanter, Michael L.},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Taylor, Richard N. and Coutaz, Jo{\"e}lle},
  year = {1995},
  volume = {896},
  pages = {251--267},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/BFb0035821},
  abstract = {Language-basedediting systemshave the potential to become a\textasciitilde practical, central, and powerful part of every software engineer's toolkit, but progress has been limited by inattention to user-centered design issues. Major usability requirements for such systems include familiar, unrestricted text editing; coherent user interaction with software; rich, dynamic information display; multiple alternative views; uninterrupted service in the presence of ill-formedhess, incompleteness,and inconsistency;description-drivensupport for multiple languages; and extensibility and customizability.Solutions require better understanding of software engineers and their tasks, appropriate design metaphors, new architecturalorganizations,and design for adaptation and extension.},
  file = {/Users/geoffreylitt/Zotero/storage/CHBVSMQS/Van De Vanter - 1995 - Practical language-based editing for software engi.pdf},
  isbn = {978-3-540-59008-8 978-3-540-49173-6},
  keywords = {structured editors,toread},
  language = {en}
}

@inproceedings{vanhardenberg2020,
  title = {{{PushPin}}: Towards Production-Quality Peer-to-Peer Collaboration},
  shorttitle = {{{PushPin}}},
  booktitle = {Proceedings of the {{7thWorkshop}} on {{Principles}} and {{Practice}} of {{Consistency}} for {{Distributed Data}}},
  author = {{van Hardenberg}, Peter and Kleppmann, Martin},
  year = {2020},
  month = apr,
  pages = {1--10},
  publisher = {{ACM}},
  address = {{Heraklion Greece}},
  doi = {10.1145/3380787.3393683},
  abstract = {Fully peer-to-peer application software promises many benefits over cloud software, in particular, being able to function indefinitely without requiring servers. Research on distributed consistency mechanisms such as CRDTs has laid the foundation for P2P data synchronisation and collaboration. In this paper we report on our experience in taking these technologies beyond research prototypes, and working towards commercial-grade P2P collaboration software. We identify approaches that work well in our experience, such as the functional reactive programming paradigm, and highlight areas in need of further research, such as the reliability of NAT traversal and usability challenges.},
  file = {/Users/geoffreylitt/Zotero/storage/YBEKKZLA/van Hardenberg and Kleppmann - 2020 - PushPin towards production-quality peer-to-peer c.pdf},
  isbn = {978-1-4503-7524-5},
  language = {en}
}

@incollection{vankleek2010,
  title = {Mixing the Reactive with the Personal},
  booktitle = {No {{Code Required}}},
  author = {Van Kleek, Max and Andr{\'e}, Paul and Moore, Brennan and Karger, David and {schraefel}, m.c.},
  year = {2010},
  pages = {127--149},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00007-9},
  abstract = {The transition of personal information management (PIM) tools off the desktop to the Web presents an opportunity to augment these tools with capabilities provided by the wealth of real-time information readily available. In this chapter, we describe a personal information assistance engine that lets end users delegate to it various simple context- and activity-reactive tasks and reminders. Our system, Atomate, treats RSS/ATOM feeds from social networking and life-tracking sites as sensor streams, integrating information from such feeds into a simple unified RDF world model representing people, places, and things and their time-varying states and activities. Combined with other information sources on the Web, including the user's online calendar, Web-based email client, news feeds and messaging services, Atomate can be made to automatically carry out a variety of simple tasks for the user, ranging from context-aware filtering and messaging, to sharing and social coordination actions. Atomate's open architecture and world model easily accommodate new information sources and actions via the addition of feeds and Web services. To make routine use of the system easy for nonprogrammers, Atomate provides a constrained-input, controlled natural language interface (CNLI) for behavior specification, and a direct-manipulation interface for inspecting and updating its world model.},
  file = {/Users/geoffreylitt/Zotero/storage/L4DJNUYA/Van Kleek et al. - 2010 - Mixing the reactive with the personal.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@inproceedings{verou2016,
  title = {Mavo: {{Creating Interactive Data}}-{{Driven Web Applications}} by {{Authoring HTML}}},
  shorttitle = {Mavo},
  booktitle = {Proceedings of the 29th {{Annual Symposium}} on {{User Interface Software}} and {{Technology}} - {{UIST}} '16},
  author = {Verou, Lea and Zhang, Amy X. and Karger, David R.},
  year = {2016},
  pages = {483--496},
  publisher = {{ACM Press}},
  address = {{Tokyo, Japan}},
  doi = {10.1145/2984511.2984551},
  abstract = {Many people can author static web pages with HTML and CSS but find it hard or impossible to program persistent, interactive web applications. We show that for a broad class of CRUD (Create, Read, Update, Delete) applications, this gap can be bridged. Mavo extends the declarative syntax of HTML to describe Web applications that manage, store and transform data. Using Mavo, authors with basic HTML knowledge define complex data schemas implicitly as they design their HTML layout. They need only add a few attributes and expressions to their HTML elements to transform their static design into a persistent, data-driven web application whose data can be edited by direct manipulation of the content in the browser. We evaluated Mavo with 20 users who marked up static designs\textemdash some provided by us, some their own creation\textemdash to transform them into fully functional web applications. Even users with no programming experience were able to quickly craft Mavo applications.},
  file = {/Users/geoffreylitt/Zotero/storage/WDIPZUY3/Verou et al. - 2016 - Mavo Creating Interactive Data-Driven Web Applica.pdf},
  isbn = {978-1-4503-4189-9},
  language = {en}
}

@inproceedings{verou2016a,
  title = {Mavo: {{Creating Interactive Data}}-{{Driven Web Applications}} by {{Authoring HTML}}},
  shorttitle = {Mavo},
  booktitle = {Proceedings of the 29th {{Annual Symposium}} on {{User Interface Software}} and {{Technology}}},
  author = {Verou, Lea and Zhang, Amy X. and Karger, David R.},
  year = {2016},
  month = oct,
  pages = {483--496},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2984511.2984551},
  abstract = {Many people can author static web pages with HTML and CSS but find it hard or impossible to program persistent, interactive web applications. We show that for a broad class of CRUD (Create, Read, Update, Delete) applications, this gap can be bridged. Mavo extends the declarative syntax of HTML to describe Web applications that manage, store and transform data. Using Mavo, authors with basic HTML knowledge define complex data schemas implicitly as they design their HTML layout. They need only add a few attributes and expressions to their HTML elements to transform their static design into a persistent, data-driven web application whose data can be edited by direct manipulation of the content in the browser. We evaluated Mavo with 20 users who marked up static designs---some provided by us, some their own creation---to transform them into fully functional web applications. Even users with no programming experience were able to quickly craft Mavo applications.},
  file = {/Users/geoffreylitt/Zotero/storage/YD42TAYH/Verou et al. - 2016 - Mavo Creating Interactive Data-Driven Web Applica.pdf},
  isbn = {978-1-4503-4189-9},
  keywords = {end-user programming,information architecture,semantic publishing,web design},
  series = {{{UIST}} '16}
}

@misc{victor2011,
  title = {Up and {{Down}} the {{Ladder}} of {{Abstraction}}},
  author = {Victor, Bret},
  year = {2011},
  month = oct,
  howpublished = {http://worrydream.com/LadderOfAbstraction/},
  journal = {Bret Victor}
}

@misc{victor2012,
  title = {Learnable {{Programming}}},
  author = {Victor, Bret},
  year = {2012},
  month = sep,
  file = {/Users/geoffreylitt/Zotero/storage/TD257V6J/LearnableProgramming.html},
  howpublished = {http://worrydream.com/LearnableProgramming/},
  keywords = {program visualization}
}

@misc{victor2013,
  title = {Media for {{Thinking}} the {{Unthinkable}}},
  author = {Victor, Bret},
  year = {2013},
  month = apr,
  howpublished = {http://worrydream.com/MediaForThinkingTheUnthinkable/},
  journal = {Bret Victor}
}

@misc{victor2020,
  title = {Dynamicland},
  author = {Victor, Bret},
  year = {2020},
  abstract = {incubating a humane dynamic medium},
  file = {/Users/geoffreylitt/Zotero/storage/JIP78YH7/dynamicland.org.html},
  howpublished = {https://dynamicland.org/}
}

@incollection{vonhippel2005,
  title = {Application: {{Toolkits}} for {{User Innovation}} and {{Custom Design}}},
  shorttitle = {Application},
  booktitle = {Democratizing {{Innovation}}},
  author = {{von Hippel}, Eric},
  year = {2005},
  pages = {147--164},
  publisher = {{The MIT Press}},
  isbn = {978-0-262-28563-6},
  language = {en}
}

@article{walker,
  title = {Implemen'ng {{OCaml}} in {{OCaml}}},
  author = {Walker, David},
  pages = {77},
  file = {/Users/geoffreylitt/Zotero/storage/Q9PPR3MC/Walker - Implemen'ng OCaml in OCaml.pdf},
  language = {en}
}

@article{wang2019,
  title = {Visualization by Example},
  author = {Wang, Chenglong and Feng, Yu and Bodik, Rastislav and Cheung, Alvin and Dillig, Isil},
  year = {2019},
  month = dec,
  volume = {4},
  pages = {1--28},
  issn = {24751421},
  doi = {10.1145/3371117},
  abstract = {CHENGLONG WANG, University of Washington, USA YU FENG, University of California, Santa Barbara, USA RASTISLAV BODIK, University of Washington, USA ALVIN CHEUNG, University of California, Berkeley, USA ISIL DILLIG, University of Texas at Austin, USA While visualizations play a crucial role in gaining insights from data, generating useful visualizations from a complex dataset is far from an easy task. In particular, besides understanding the functionality provided by existing visualization libraries, generating the desired visualization also requires reshaping and aggregating the underlying data as well as composing different visual elements to achieve the intended visual narrative. This paper aims to simplify visualization tasks by automatically synthesizing the required program from simple visual sketches provided by the user. Specifically, given an input data set and a visual sketch that demonstrates how to visualize a very small subset of this data, our technique automatically generates a program that can be used to visualize the entire data set. From a program synthesis perspective, automating visualization tasks poses several challenges that are not addressed by prior techniques. First, because many visualization tasks require data wrangling in addition to generating plots from a given table, we need to decompose the end-to-end synthesis task into two separate sub-problems. Second, because the intermediate specification that results from the decomposition is necessarily imprecise, this makes the data wrangling task particularly challenging in our context. In this paper, we address these problems by developing a new compositional visualization-by-example technique that (a) decomposes the end-to-end task into two different synthesis problems over different DSLs and (b) leverages bi-directional program analysis to deal with the complexity that arises from having an imprecise intermediate specification. We have implemented our visualization-by-example approach in a tool called Viser and evaluate it on 83 visualization tasks collected from on-line forums and tutorials. Viser can solve 84\% of these benchmarks within a 600 second time limit, and, for those tasks that can be solved, the desired visualization is among the top-5 generated by Viser in 70\% of the cases. CCS Concepts: \textbullet{} Theory of computation \textrightarrow{} Program reasoning; \textbullet{} Human-centered computing \textrightarrow{} Visualization toolkits.},
  file = {/Users/geoffreylitt/Zotero/storage/2RWUSYKS/Wang et al. - 2019 - Visualization by example.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  keywords = {toread},
  language = {en},
  number = {POPL}
}

@misc{webb,
  title = {Revisiting {{Adaptive Design}}, a Lost Design Movement ({{Interconnected}})},
  author = {Webb, Matt},
  file = {/Users/geoffreylitt/Zotero/storage/4QDWIARB/adaptive_design.html},
  howpublished = {http://interconnected.org/home/2020/08/26/adaptive\_design}
}

@article{weiher,
  title = {Can {{Programmers Escape}} the {{Gentle Tyranny}} of Call/Return?},
  author = {Weiher, Marcel},
  pages = {21},
  abstract = {Although the call/return architectural style has served as the foundation of much of computing since its existence, it no longer matches a large proportion, probably the majority, of the programs or systems created today.},
  file = {/Users/geoffreylitt/Zotero/storage/CGSM3L8Y/Weiher - Can Programmers Escape the Gentle Tyranny of call.pdf},
  language = {en}
}

@inproceedings{weiher2019,
  title = {Storage Combinators},
  booktitle = {Proceedings of the 2019 {{ACM SIGPLAN International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}} - {{Onward}}! 2019},
  author = {Weiher, Marcel and Hirschfeld, Robert},
  year = {2019},
  pages = {111--127},
  publisher = {{ACM Press}},
  address = {{Athens, Greece}},
  doi = {10.1145/3359591.3359729},
  abstract = {The ability to compose software from high level components is as sought after as it is elusive. The REST architectural style used in the World Wide Web enables such plug-compatible components in distributed settings.},
  file = {/Users/geoffreylitt/Zotero/storage/TVHJY94Z/Weiher and Hirschfeld - 2019 - Storage combinators.pdf},
  isbn = {978-1-4503-6995-4},
  keywords = {toread},
  language = {en}
}

@article{weiser1999,
  title = {The {{Computer}} for the 21st {{Century}}},
  author = {Weiser, Mark},
  year = {1999},
  month = jul,
  volume = {3},
  pages = {3--11},
  issn = {1559-1662},
  doi = {10.1145/329124.329126},
  abstract = {Specialized elements of hardware and software, connected by wires, radio waves and infrared, will be so ubiquitous that no one will notice their presence.},
  journal = {SIGMOBILE Mobile Computing and Communications Review},
  number = {3}
}

@article{wickham2010,
  title = {A {{Layered Grammar}} of {{Graphics}}},
  author = {Wickham, Hadley},
  year = {2010},
  month = jan,
  volume = {19},
  pages = {3--28},
  issn = {1061-8600, 1537-2715},
  doi = {10.1198/jcgs.2009.07098},
  file = {/Users/geoffreylitt/Zotero/storage/W7MDYG2N/Wickham - 2010 - A Layered Grammar of Graphics.pdf},
  journal = {Journal of Computational and Graphical Statistics},
  language = {en},
  number = {1}
}

@incollection{wigdor2011,
  title = {Touch versus {{In}}-{{Air Gestures}}},
  booktitle = {Brave {{NUI World}}: {{Designing Natural User Interfaces}} for {{Touch}} and {{Gesture}}},
  author = {Wigdor, Daniel and Wixon, Dennis},
  year = {2011},
  pages = {97--103},
  publisher = {{Morgan Kaufmann Publishers}},
  address = {{Amsterdam}}
}

@book{wigdor2011a,
  title = {Brave {{NUI World}}: {{Designing Natural User Interfaces}} for {{Touch}} and {{Gesture}}},
  shorttitle = {Brave {{Nui World}}},
  author = {Wigdor, Daniel and Wixon, Dennis},
  year = {2011},
  publisher = {{Morgan Kaufmann}},
  address = {{Burlington, MA}},
  isbn = {978-0-12-382231-4},
  keywords = {Haptic devices,Human-computer interaction,User interfaces (Computer systems)},
  language = {en},
  lccn = {QA76.9.U83 W537 2011}
}

@article{wilson2018,
  title = {The {{Behavior}} of {{Gradual Types}}: {{A User Study}}},
  author = {Wilson, Preston Tunnell and Greenman, Ben and Pombrio, Justin and Krishnamurthi, Shriram},
  year = {2018},
  pages = {12},
  abstract = {There are several different gradual typing semantics, reflecting different trade-offs between performance and type soundness guarantees. Notably absent, however, are any data on which of these semantics developers actually prefer. We begin to rectify this shortcoming by surveying professional developers, computer science students, and Mechanical Turk workers on their preferences between three gradual typing semantics. These semantics reflect important points in the design space, corresponding to the behaviors of Typed Racket, TypeScript, and Reticulated Python. Our most important finding is that our respondents prefer a runtime semantics that fully enforces statically declared types.},
  file = {/Users/geoffreylitt/Zotero/storage/RPG2EQPS/Wilson et al. - 2018 - The Behavior of Gradual Types A User Study.pdf},
  keywords = {gradual-types,user-study},
  language = {en}
}

@inproceedings{wimmer2018,
  title = {Files as Directories: Some Thoughts on Accessing Structured Data within Files},
  shorttitle = {Files as Directories},
  booktitle = {Conference {{Companion}} of the 2nd {{International Conference}} on {{Art}}, {{Science}}, and {{Engineering}} of {{Programming}}  - {{Programming}}'18 {{Companion}}},
  author = {Wimmer, Raphael},
  year = {2018},
  pages = {166--170},
  publisher = {{ACM Press}},
  address = {{Nice, France}},
  doi = {10.1145/3191697.3214323},
  abstract = {This paper explores the concept of files as directories (FAD) as a unified interface to structured data within a file by representing such a file as (virtual) directory and the structured data as subdirectories and subfiles. Transparent conversion of files and their structured data into directory trees is to be handled by virtual filesystem providers. This allows for arbitrary applications and programming languages to read and write data within supported file types without the need to understand the file format - e.g., in order to modify pixel values within an image file, paragraphs in a text document, or settings in a configuration file.},
  file = {/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/obsidian-notes/Resources/wimmer2018.md;/Users/geoffreylitt/Library/Mobile Documents/com~apple~CloudDocs/Research/zotero metadata/wimmer2018-zotero.md;/Users/geoffreylitt/Zotero/storage/K97I2SCF/Wimmer - 2018 - Files as directories some thoughts on accessing s.pdf},
  isbn = {978-1-4503-5513-1},
  language = {en}
}

@inproceedings{wobbrock2009,
  title = {User-{{Defined Gestures}} for {{Surface Computing}}},
  booktitle = {Proceedings of the 27th {{International Conference}} on {{Human Factors}} in {{Computing Systems}} - {{CHI}} 09},
  author = {Wobbrock, Jacob O. and Morris, Meredith Ringel and Wilson, Andrew D.},
  year = {2009},
  pages = {1083},
  publisher = {{ACM Press}},
  address = {{Boston, MA, USA}},
  doi = {10.1145/1518701.1518866},
  abstract = {Many surface computing prototypes have employed gestures created by system designers. Although such gestures are appropriate for early investigations, they are not necessarily reflective of user behavior. We present an approach to designing tabletop gestures that relies on eliciting gestures from non-technical users by first portraying the effect of a gesture, and then asking users to perform its cause. In all, 1080 gestures from 20 participants were logged, analyzed, and paired with think-aloud data for 27 commands performed with 1 and 2 hands. Our findings indicate that users rarely care about the number of fingers they employ, that one hand is preferred to two, that desktop idioms strongly influence users' mental models, and that some commands elicit little gestural agreement, suggesting the need for on-screen widgets. We also present a complete user-defined gesture set, quantitative agreement scores, implications for surface technology, and a taxonomy of surface gestures. Our results will help designers create better gesture sets informed by user behavior.},
  isbn = {978-1-60558-246-7},
  language = {en}
}

@inproceedings{wong2007,
  title = {Making Mashups with Marmite: Towards End-User Programming for the Web},
  shorttitle = {Making Mashups with Marmite},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}  - {{CHI}} '07},
  author = {Wong, Jeffrey and Hong, Jason I.},
  year = {2007},
  pages = {1435--1444},
  publisher = {{ACM Press}},
  address = {{San Jose, California, USA}},
  doi = {10.1145/1240624.1240842},
  abstract = {There is a tremendous amount of web content available today, but it is not always in a form that supports end-users' needs. In many cases, all of the data and services needed to accomplish a goal already exist, but are not in a form amenable to an end-user. To address this problem, we have developed an end-user programming tool called Marmite, which lets end-users create so-called mashups that repurpose and combine existing web content and services. In this paper, we present the design, implementation, and evaluation of Marmite. An informal user study found that programmers and some spreadsheet users had little difficulty using the system.},
  file = {/Users/geoffreylitt/Zotero/storage/9QWLY8KD/Wong and Hong - 2007 - Making mashups with marmite towards end-user prog.pdf},
  isbn = {978-1-59593-593-9},
  language = {en}
}

@article{wongsuphasawat2016,
  title = {Voyager: {{Exploratory Analysis}} via {{Faceted Browsing}} of {{Visualization Recommendations}}},
  shorttitle = {Voyager},
  author = {Wongsuphasawat, Kanit and Moritz, Dominik and Anand, Anushka and Mackinlay, Jock and Howe, Bill and Heer, Jeffrey},
  year = {2016},
  month = jan,
  volume = {22},
  pages = {649--658},
  issn = {1077-2626},
  doi = {10.1109/TVCG.2015.2467191},
  abstract = {General visualization tools typically require manual specification of views: analysts must select data variables and then choose which transformations and visual encodings to apply. These decisions often involve both domain and visualization design expertise, and may impose a tedious specification process that impedes exploration. In this paper, we seek to complement manual chart construction with interactive navigation of a gallery of automatically-generated visualizations. We contribute Voyager, a mixed-initiative system that supports faceted browsing of recommended charts chosen according to statistical and perceptual measures. We describe Voyager's architecture, motivating design principles, and methods for generating and interacting with visualization recommendations. In a study comparing Voyager to a manual visualization specification tool, we find that Voyager facilitates exploration of previously unseen data and leads to increased data variable coverage. We then distill design implications for visualization tools, in particular the need to balance rapid exploration and targeted question-answering.},
  file = {/Users/geoffreylitt/Zotero/storage/N2PELLDU/Wongsuphasawat et al. - 2016 - Voyager Exploratory Analysis via Faceted Browsing.pdf},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  language = {en},
  number = {1}
}

@article{wood2019,
  title = {Design {{Exposition}} with {{Literate Visualization}}},
  author = {Wood, Jo and Kachkaev, Alexander and Dykes, Jason},
  year = {2019},
  month = jan,
  volume = {25},
  pages = {759--768},
  issn = {1077-2626, 1941-0506, 2160-9306},
  doi = {10.1109/TVCG.2018.2864836},
  abstract = {We propose a new approach to the visualization design and communication process, literate visualization, based upon and extending, Donald Knuth's idea of literate programming. It integrates the process of writing data visualization code with description of the design choices that led to the implementation (design exposition). We develop a model of design exposition characterised by four visualization designer architypes: the evaluator, the autonomist, the didacticist and the rationalist. The model is used to justify the key characteristics of literate visualization: `notebook' documents that integrate live coding input, rendered output and textual narrative; low cost of authoring textual narrative; guidelines to encourage structured visualization design and its documentation. We propose narrative schemas for structuring and validating a wide range of visualization design approaches and models, and branching narratives for capturing alternative designs and design views. We describe a new open source literate visualization environment, litvis, based on a declarative interface to Vega and Vega-Lite through the functional programming language Elm combined with markdown for formatted narrative. We informally assess the approach, its implementation and potential by considering three examples spanning a range of design abstractions: new visualization idioms; validation though visualization algebra; and feminist data visualization. We argue that the rich documentation of the design process provided by literate visualization offers the potential to improve the validity of visualization design and so benefit both academic visualization and visualization practice.},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  language = {en},
  number = {1}
}

@article{wrenn2020,
  title = {Using {{Relational Problems}} to {{Teach Property}}-{{Based Testing}}},
  author = {Wrenn, John and Nelson, Tim and Krishnamurthi, Shriram},
  year = {2020},
  month = oct,
  volume = {5},
  pages = {9},
  issn = {2473-7321},
  doi = {10.22152/programming-journal.org/2021/5/9},
  abstract = {Context The success of QuickCheck has led to the development of property-based testing ( ) libraries for many languages and the process is getting increasing attention. However, unlike regular testing, is not widespread in collegiate curricula.},
  file = {/Users/geoffreylitt/Zotero/storage/6A375CW4/Wrenn et al. - 2020 - Using Relational Problems to Teach Property-Based .pdf},
  journal = {The Art, Science, and Engineering of Programming},
  language = {en},
  number = {2}
}

@inproceedings{wu2020,
  title = {B2: {{Bridging Code}} and {{Interactive Visualization}} in {{Computational Notebooks}}},
  shorttitle = {B2},
  booktitle = {Proceedings of the 33rd {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  author = {Wu, Yifan and Hellerstein, Joseph M. and Satyanarayan, Arvind},
  year = {2020},
  month = oct,
  pages = {152--165},
  publisher = {{ACM}},
  address = {{Virtual Event USA}},
  doi = {10.1145/3379337.3415851},
  abstract = {Data scientists have embraced computational notebooks to author analysis code and accompanying visualizations within a single document. Currently, although these media may be interleaved, they remain siloed: interactive visualizations must be manually specified as they are divorced from the analysis provenance expressed via dataframes, while code cells have no access to users' interactions with visualizations, and hence no way to operate on the results of interaction. To bridge this divide, we present B2, a set of techniques grounded in treating data queries as a shared representation between the code and interactive visualizations. B2 instruments data frames to track the queries expressed in code and synthesize corresponding visualizations. These visualizations are displayed in a dashboard to facilitate interactive analysis. When an interaction occurs, B2 reifies it as a data query and generates a history log in a new code cell. Subsequent cells can use this log to further analyze interaction results and, when marked as reactive, to ensure that code is automatically recomputed when new interaction occurs. In an evaluative study with data scientists, we find that B2 promotes a tighter feedback loop between coding and interacting with visualizations. All participants frequently moved from code to visualization and vice-versa, which facilitated their exploratory data analysis in the notebook.},
  file = {/Users/geoffreylitt/Zotero/storage/UE4FGIIG/Wu et al. - 2020 - B2 Bridging Code and Interactive Visualization in.pdf},
  isbn = {978-1-4503-7514-6},
  language = {en}
}

@inproceedings{yankelovich1995,
  title = {Designing {{SpeechActs}}: Issues in Speech User Interfaces},
  shorttitle = {Designing {{SpeechActs}}},
  booktitle = {Proceedings of the {{SIGCHI}} Conference on {{Human}} Factors in Computing Systems - {{CHI}} '95},
  author = {Yankelovich, Nicole and Levow, Gina-Anne and Marx, Matt},
  year = {1995},
  pages = {369--376},
  publisher = {{ACM Press}},
  address = {{Denver, Colorado, United States}},
  doi = {10.1145/223904.223952},
  abstract = {SpeechActs is an experimental conversational speech system. Experience with redesigning the system based on user feedback indicates the importance of adhering to conversational conventions when designing speech interfaces, particularly in the face of speech recognition errors. Study results also suggest that speech-only interfaces should be designed from scratch rather than directly translated from their graphical counterparts. This paper examines a set of challenging issues facing speech interface designers and describes approaches to address some of these challenges.},
  isbn = {978-0-201-84705-5},
  language = {en}
}

@article{ye,
  title = {Penrose: {{From Mathematical Notation}} to {{Beautiful Diagrams}}},
  author = {Ye, Katherine and Ni, Wode and Krieger, Max and Ma'ayan, Dor and Wise, Jenna and Aldrich, Jonathan and Sunshine, Joshua and Crane, Keenan},
  volume = {39},
  pages = {16},
  file = {/Users/geoffreylitt/Zotero/storage/FVT2ABLX/Ye et al. - Penrose From Mathematical Notation to Beautiful D.pdf},
  language = {en},
  number = {4}
}

@incollection{zang2010,
  title = {The {{Web}}-Active End User},
  booktitle = {No {{Code Required}}},
  author = {Zang, Nan and Rosson, Mary Beth},
  year = {2010},
  pages = {389--405},
  publisher = {{Elsevier}},
  doi = {10.1016/B978-0-12-381541-5.00020-1},
  abstract = {In this chapter we present our work that has led to the idea of the Web-active end user \textendash{} individuals who actively seek and adopt new technologies and try to make the most of what the Web has to offer. Using the context of mashups \textendash{} a type of Web application that combines different data into one interface \textendash{} we explore how these users take advantage of the Web. We examine some of their ideas about online information and detail their use of a mashup tool. By focusing our work on the users themselves, we hope to better understand the needs of these users and provide a user-centered direction for future tools.},
  file = {/Users/geoffreylitt/Zotero/storage/VDXPJX97/Zang and Rosson - 2010 - The Web-active end user.pdf},
  isbn = {978-0-12-381541-5},
  language = {en}
}

@misc{zotero-1036,
  title = {Cape {{Malay Chicken Curry}}},
  abstract = {Our Cape Malay chicken curry recipe\textemdash made with boneless, skinless thighs\textemdash is lighter, brighter and faster than other curries and one of our all-time favorites.},
  howpublished = {https://www.177milkstreet.com/recipes/cape-malay-chicken-curry},
  journal = {Christopher Kimball's Milk Street},
  language = {en-US}
}

@misc{zotero-1056,
  title = {Feedback on {{Carbon Majors}} Article? - Gklitt@gmail.Com - {{Gmail}}},
  file = {/Users/geoffreylitt/Zotero/storage/3Q74SQY4/0.html},
  howpublished = {https://mail.google.com/mail/u/0/\#search/heede/KtbxLwgpqfxXWlHzHmPdgSDtnBWzXjtfwL}
}

@misc{zotero-109,
  title = {Cracking the Cocoa Nut | {{Proceedings}} of the 24th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology},
  file = {/Users/geoffreylitt/Zotero/storage/IU975ZTG/2047196.html},
  howpublished = {http://dl.acm.org/doi/abs/10.1145/2047196.2047226},
  language = {en}
}

@misc{zotero-1098,
  title = {Early {{Work}}},
  file = {/Users/geoffreylitt/Zotero/storage/ZMWYRIU2/early.html},
  howpublished = {http://paulgraham.com/early.html}
}

@misc{zotero-1125,
  title = {Interactive {{Program Synthesis}} by {{Augmented Examples}} | {{Proceedings}} of the 33rd {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  file = {/Users/geoffreylitt/Zotero/storage/ZSGDPQFM/3379337.html},
  howpublished = {https://dl-acm-org.libproxy.mit.edu/doi/10.1145/3379337.3415900}
}

@misc{zotero-1133,
  title = {{{SPLASH}} 2020},
  abstract = {Welcome to the website of the SPLASH 2020 conference!  SPLASH is the ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity. SPLASH embraces all aspects of software construction and delivery, to make it the premier conference on the applications of programming languages\textemdash at the intersection of programming languages and software engineering. SPLASH 2020 will take place from Sunday 15th to Friday 20th of November 2020.  SPLASH includes the following co-located conferences: OOPSLA, Onward!, GPCE, SLE, DLS, ECOOP and SAS; as well as a large array of w ...},
  file = {/Users/geoffreylitt/Zotero/storage/N7SYTC3Y/2020.splashcon.org.html},
  howpublished = {https://2020.splashcon.org/}
}

@article{zotero-117,
  title = {A Theory of the Learnable},
  file = {/Users/geoffreylitt/Zotero/storage/BJEDTPMG/1968.html},
  journal = {Communications of the ACM},
  language = {en}
}

@misc{zotero-1183,
  title = {Local-First Markdown Editor},
  file = {/Users/geoffreylitt/Zotero/storage/4NHEGXUF/edit.html},
  howpublished = {https://docs.google.com/document/u/0/d/1pWkarz3ob4YtXj-Js70S-zpP2lDcxoUdu1oc1px-\_hQ/edit?usp=embed\_facebook},
  journal = {Google Docs},
  language = {en}
}

@misc{zotero-1187,
  title = {Alexandr {{Wang}} on {{Twitter}}},
  abstract = {8/ The ultimate hack is to not rely on compressions at all. Be an engineer, salesperson, support rep, ops person. Develop uncompressed understandings of how everything works together, and use that to build the right thing. That has been the key to every great product I know of. https://t.co/tjsx2oqhby},
  file = {/Users/geoffreylitt/Zotero/storage/LMSJXE5N/tweet.html},
  howpublished = {https://twitter.com/alexandr\_wang/status/1335355219761188866},
  journal = {Twitter},
  language = {en}
}

@misc{zotero-1261,
  title = {Schema {{Evolution}} and {{Compatibility}} \textemdash{} {{Confluent Documentation}}},
  file = {/Users/geoffreylitt/Zotero/storage/LZP65MAC/avro.html},
  howpublished = {https://docs.confluent.io/platform/current/schema-registry/avro.html}
}

@misc{zotero-48,
  title = {Exhibit | {{Proceedings}} of the 16th International Conference on {{World Wide Web}}},
  file = {/Users/geoffreylitt/Zotero/storage/6KKT6UT4/1242572.html},
  howpublished = {http://dl.acm.org/doi/abs/10.1145/1242572.1242672},
  language = {en}
}

@misc{zotero-621,
  title = {Redux - {{A}} Predictable State Container for {{JavaScript}} Apps. | {{Redux}}},
  abstract = {A predictable state container for JavaScript apps.},
  file = {/Users/geoffreylitt/Zotero/storage/DIABRQN4/redux.js.org.html},
  howpublished = {https://redux.js.org/},
  language = {en}
}

@misc{zotero-700,
  title = {Cocoa {{Scripting}}},
  file = {/Users/geoffreylitt/Zotero/storage/IJQ3ZSSW/Scripting.html},
  howpublished = {https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/AppArchitecture/Concepts/Scripting.html}
}

@misc{zotero-733,
  title = {Forms/3: {{A}} First-Order Visual Language to Explore the Boundaries of the Spreadsheet Paradigm | {{Journal}} of {{Functional Programming}}},
  file = {/Users/geoffreylitt/Zotero/storage/SLSXALZJ/968486.html},
  howpublished = {https://dl-acm-org.libproxy.mit.edu/doi/10.5555/968486.968487}
}

@misc{zotero-760,
  title = {Welcome to {{Quotebacks}}},
  file = {/Users/geoffreylitt/Zotero/storage/X85ALCAH/welcome.html},
  howpublished = {https://quotebacks.net/welcome.html}
}

@article{zotero-768,
  title = {The {{Climate Deception Dossiers}}: {{Internal Fossil Fuel Industry Memos Reveal Decades}} of {{Corporate Disinformation}} (2015)},
  pages = {56},
  file = {/Users/geoffreylitt/Zotero/storage/U9FAYLYB/The Climate Deception Dossiers Internal Fossil Fu.pdf},
  language = {en}
}

@misc{zotero-872,
  title = {Core77 {{Articles}}: {{Insanely}} Great, or Just Good Enough?},
  file = {/Users/geoffreylitt/Zotero/storage/M4WSSV2F/opinion_02.04.html},
  howpublished = {http://www.core77.com/reactor/opinion\_02.04.asp}
}

@misc{zotero-953,
  title = {Why {{Do React Hooks Rely}} on {{Call Order}}?},
  abstract = {Lessons learned from mixins, render props, HOCs, and classes.},
  file = {/Users/geoffreylitt/Zotero/storage/ZWK8TXXG/why-do-hooks-rely-on-call-order.html},
  howpublished = {https://overreacted.io/why-do-hooks-rely-on-call-order/},
  language = {en}
}

@misc{zotero-961,
  title = {E.{{W}}.{{Dijkstra Archive}}: {{The}} Strengths of the Academic Enterprise ({{EWD}} 1175)},
  file = {/Users/geoffreylitt/Zotero/storage/4ISDNK45/EWD1175.html},
  howpublished = {https://www.cs.utexas.edu/users/EWD/transcriptions/EWD11xx/EWD1175.html}
}

@misc{zotero-968,
  title = {Re: {{Student Presentations}} at {{HCI Seminar}} - Gklitt@gmail.Com - {{Gmail}}},
  file = {/Users/geoffreylitt/Zotero/storage/9XDK44BD/0.html},
  howpublished = {https://mail.google.com/mail/u/0/\#inbox/FMfcgxwJZJQhCgxxnvLDVSjJMRkqbKdC}
}

@misc{zotero-982,
  title = {Towards {{Lightweight Scraping}} with {{Wildcard}}},
  abstract = {Towards Lightweight Scraping with Wildcard Gloria, Kapaya, Geoffrey},
  file = {/Users/geoffreylitt/Zotero/storage/GDYTSK2Q/edit.html},
  howpublished = {https://docs.google.com/presentation/d/1xZX7Za\_eTKskAZKRtZnJZMkzV-9-R5r4SJ0Ans4aj3A/edit?usp=drive\_web\&ouid=106872490491745736504\&usp=embed\_facebook},
  journal = {Google Docs},
  language = {en}
}

@misc{zotero-984,
  title = {Towards {{Lightweight Scraping}} with {{Wildcard}}},
  abstract = {Towards Lightweight Scraping with Wildcard Gloria, Kapaya, Geoffrey},
  file = {/Users/geoffreylitt/Zotero/storage/7264QBHD/edit.html},
  howpublished = {https://docs.google.com/presentation/d/1xZX7Za\_eTKskAZKRtZnJZMkzV-9-R5r4SJ0Ans4aj3A/edit?usp=drive\_web\&ouid=106872490491745736504\&usp=embed\_facebook},
  journal = {Google Docs},
  language = {en}
}

@book{zuboff1989,
  title = {In {{The Age Of The Smart Machine}}: {{The Future Of Work And Power}}},
  shorttitle = {In {{The Age Of The Smart Machine}}},
  author = {Zuboff, Shoshana},
  year = {1989},
  month = oct,
  edition = {Illustrated edition},
  publisher = {{Basic Books}},
  address = {{New York}},
  abstract = {A noted Harvard social scientist documents the pitfalls and promises of computerized technology in business life.},
  isbn = {978-0-465-03211-2},
  language = {English}
}


